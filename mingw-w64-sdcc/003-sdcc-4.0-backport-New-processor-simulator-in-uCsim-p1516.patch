From 5473a2204cccbc1f3508c553c65cc65527b53f00 Mon Sep 17 00:00:00 2001
From: drdani <drdani@4a8a32a2-be11-0410-ad9d-d568d2c75423>
Date: Mon, 8 Jun 2020 18:14:00 +0000
Subject: [PATCH] New processor simulator in uCsim: p1516

git-svn-id: https://svn.code.sf.net/p/sdcc/code/trunk@11660 4a8a32a2-be11-0410-ad9d-d568d2c75423
---
 sdcc/sim/ucsim/.version               |   2 +-
 sdcc/sim/ucsim/chars.cc               |  37 +++
 sdcc/sim/ucsim/charscl.h              |   5 +
 sdcc/sim/ucsim/cmd.src/cmd_uc.cc      |  46 +--
 sdcc/sim/ucsim/conf                   |   3 +
 sdcc/sim/ucsim/configure              |  16 +-
 sdcc/sim/ucsim/configure.ac           |   8 +
 sdcc/sim/ucsim/fuio.cc                |   4 +-
 sdcc/sim/ucsim/main_in.mk             |   1 +
 sdcc/sim/ucsim/p1516.src/(c).1        |  25 ++
 sdcc/sim/ucsim/p1516.src/Makefile.in  | 162 ++++++++++
 sdcc/sim/ucsim/p1516.src/clean.mk     |  30 ++
 sdcc/sim/ucsim/p1516.src/conf.mk      |  11 +
 sdcc/sim/ucsim/p1516.src/glob.cc      |  48 +++
 sdcc/sim/ucsim/p1516.src/glob.h       |  14 +
 sdcc/sim/ucsim/p1516.src/p1516.cc     | 442 ++++++++++++++++++++++++++
 sdcc/sim/ucsim/p1516.src/p1516cl.h    |  79 +++++
 sdcc/sim/ucsim/p1516.src/simp1516.cc  |  44 +++
 sdcc/sim/ucsim/p1516.src/simp1516cl.h |  45 +++
 sdcc/sim/ucsim/p1516.src/sp1516.cc    |  53 +++
 sdcc/sim/ucsim/packages_in.mk         |  13 +-
 sdcc/sim/ucsim/sim.src/uc.cc          |  61 ++++
 sdcc/sim/ucsim/sim.src/uccl.h         |   4 +-
 sdcc/sim/ucsim/utils.cc               |  17 +
 sdcc/sim/ucsim/utils.h                |   1 +
 25 files changed, 1143 insertions(+), 28 deletions(-)
 create mode 100644 sdcc/sim/ucsim/p1516.src/(c).1
 create mode 100644 sdcc/sim/ucsim/p1516.src/Makefile.in
 create mode 100644 sdcc/sim/ucsim/p1516.src/clean.mk
 create mode 100644 sdcc/sim/ucsim/p1516.src/conf.mk
 create mode 100644 sdcc/sim/ucsim/p1516.src/glob.cc
 create mode 100644 sdcc/sim/ucsim/p1516.src/glob.h
 create mode 100644 sdcc/sim/ucsim/p1516.src/p1516.cc
 create mode 100644 sdcc/sim/ucsim/p1516.src/p1516cl.h
 create mode 100644 sdcc/sim/ucsim/p1516.src/simp1516.cc
 create mode 100644 sdcc/sim/ucsim/p1516.src/simp1516cl.h
 create mode 100644 sdcc/sim/ucsim/p1516.src/sp1516.cc

diff --git a/sdcc/sim/ucsim/.version b/sdcc/sim/ucsim/.version
index b8d58209c..c01525a96 100644
--- a/sdcc/sim/ucsim/.version
+++ b/sdcc/sim/ucsim/.version
@@ -1 +1 @@
-0.6-pre61
+0.6-pre62
diff --git a/sdcc/sim/ucsim/chars.cc b/sdcc/sim/ucsim/chars.cc
index 47a3a120c..a561439e2 100644
--- a/sdcc/sim/ucsim/chars.cc
+++ b/sdcc/sim/ucsim/chars.cc
@@ -29,6 +29,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #include <string.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include <ctype.h>
 
 #include "charscl.h"
 
@@ -163,6 +164,33 @@ chars::token(chars delims)
 }
 
 
+void
+chars::ltrim(void)
+{
+  char *p= chars_string;
+  if (!p)
+    return;
+  while (*p && isspace(*p))
+    p++;
+  allocate_string(p);
+}
+
+void
+chars::rtrim(void)
+{
+  char *p= chars_string;
+  if (!p)
+    return;
+  if (*p == 0)
+    return;
+  p= p+len()-1;
+  while ((p!=chars_string) && isspace(*p))
+    p--;
+  if (isspace(*p))
+    *p= 0;
+}
+
+
 bool
 chars::starts_with(char *x)
 {
@@ -313,6 +341,15 @@ chars::operator=(char *s)
   return(*this);
 }
 
+/*
+chars &
+chars::operator=(const char *s)
+{
+  allocate_string((char*)s);
+  return(*this);
+}
+*/
+
 chars &
 chars::operator=(const chars &cs)
 {
diff --git a/sdcc/sim/ucsim/charscl.h b/sdcc/sim/ucsim/charscl.h
index 9a98001b5..849be3fc3 100644
--- a/sdcc/sim/ucsim/charscl.h
+++ b/sdcc/sim/ucsim/charscl.h
@@ -59,6 +59,9 @@ public:
   virtual void start_parse(void) { start_parse(0); }
   virtual void start_parse(int at) { pars_pos= at; }
   virtual chars token(chars delims);
+  virtual void ltrim(void);
+  virtual void rtrim(void);
+  virtual void trim() { ltrim(); rtrim(); }
   // search
   bool starts_with(char *x);
   bool starts_with(const char *x);
@@ -71,6 +74,7 @@ public:
   operator char*(void) const { return(chars_string); };
   // Assignment
   chars &operator=(char *s);
+  //chars &operator=(const char *s);
   chars &operator=(const chars &cs);
   // Arithmetic
   chars operator+(char c);
@@ -78,6 +82,7 @@ public:
   chars operator+(const chars &cs);
   chars &operator+=(char c) { return(append(c)); }
   chars &operator+=(char *s) { return(append(s)); }
+  chars &operator+=(const char *s) { return(append((char*)s)); }
   chars &operator+=(const chars &cs) { return(append((char*)cs)); }
   // Boolean
   bool equal(char *);
diff --git a/sdcc/sim/ucsim/cmd.src/cmd_uc.cc b/sdcc/sim/ucsim/cmd.src/cmd_uc.cc
index fcc445e0c..88d2422a1 100644
--- a/sdcc/sim/ucsim/cmd.src/cmd_uc.cc
+++ b/sdcc/sim/ucsim/cmd.src/cmd_uc.cc
@@ -169,7 +169,7 @@ COMMAND_DO_WORK_UC(cl_pc_cmd)
 	}
       if (!uc->inst_at(addr))
 	con->dd_printf("Warning: maybe not instruction at 0x%06x\n", AU(addr));
-      uc->PC= addr;
+      uc->set_PC(addr);
     }
   uc->print_disass(uc->PC, con);
   return(false);
@@ -300,27 +300,33 @@ COMMAND_DO_WORK_UC(cl_dump_cmd)
   if (cmdline->syntax_match(uc, MEMORY))
     {
       mem= cmdline->param(0)->value.memory.memory;
+      if (mem->width > 16) bpl/= 2;
       mem->dump(df, -1, -1, bpl, con/*->get_fout()*/);
     }
-  else if (cmdline->syntax_match(uc, MEMORY ADDRESS)) {
-    mem  = cmdline->param(0)->value.memory.memory;
-    start= cmdline->param(1)->value.address;
-    end  = start+10*8-1;
-    mem->dump(df, start, end, bpl, con/*->get_fout()*/);
-  }
-  else if (cmdline->syntax_match(uc, MEMORY ADDRESS ADDRESS)) {
-    mem  = cmdline->param(0)->value.memory.memory;
-    start= cmdline->param(1)->value.address;
-    end  = cmdline->param(2)->value.address;
-    mem->dump(df, start, end, bpl, con/*->get_fout()*/);
-  }
-  else if (cmdline->syntax_match(uc, MEMORY ADDRESS ADDRESS NUMBER)) {
-    mem  = cmdline->param(0)->value.memory.memory;
-    start= cmdline->param(1)->value.address;
-    end  = cmdline->param(2)->value.address;
-    bpl  = cmdline->param(3)->value.number;
-    mem->dump(df, start, end, bpl, con/*->get_fout()*/);
-  }
+  else if (cmdline->syntax_match(uc, MEMORY ADDRESS))
+    {
+      mem  = cmdline->param(0)->value.memory.memory;
+      start= cmdline->param(1)->value.address;
+      end  = start+10*8-1;
+      if (mem->width > 16) bpl/= 2;
+      mem->dump(df, start, end, bpl, con/*->get_fout()*/);
+    }
+  else if (cmdline->syntax_match(uc, MEMORY ADDRESS ADDRESS))
+    {
+      mem  = cmdline->param(0)->value.memory.memory;
+      start= cmdline->param(1)->value.address;
+      end  = cmdline->param(2)->value.address;
+      if (mem->width > 16) bpl/= 2;
+      mem->dump(df, start, end, bpl, con/*->get_fout()*/);
+    }
+  else if (cmdline->syntax_match(uc, MEMORY ADDRESS ADDRESS NUMBER))
+    {
+      mem  = cmdline->param(0)->value.memory.memory;
+      start= cmdline->param(1)->value.address;
+      end  = cmdline->param(2)->value.address;
+      bpl  = cmdline->param(3)->value.number;
+      mem->dump(df, start, end, bpl, con/*->get_fout()*/);
+    }
   else
     syntax_error(con);
 
diff --git a/sdcc/sim/ucsim/conf b/sdcc/sim/ucsim/conf
index ea498fec4..c29615171 100755
--- a/sdcc/sim/ucsim/conf
+++ b/sdcc/sim/ucsim/conf
@@ -55,6 +55,7 @@ case $TARGET in
 	    --enable-xa-port \
 	    --enable-stm8-port \
 	    --enable-st7-port \
+	    --enable-p15160port \
 	    "$@"
 	#--enable-ucsim
 	;;
@@ -79,6 +80,7 @@ case $TARGET in
 	    --enable-xa-port \
 	    --enable-stm8-port \
 	    --enable-st7-port \
+	    --enable-p1516-port \
 	    $HOST_OPT "$@"
 	#--enable-ucsim
 	;;
@@ -97,6 +99,7 @@ case $TARGET in
 	    --enable-xa-port \
 	    --enable-stm8-port \
 	    --enable-st7-port \
+	    --enable-p1516-port \
 	    $HOST_OPT "$@"
 	#--enable-ucsim
 	;;
diff --git a/sdcc/sim/ucsim/configure b/sdcc/sim/ucsim/configure
index d841990f7..f9f45a672 100755
--- a/sdcc/sim/ucsim/configure
+++ b/sdcc/sim/ucsim/configure
@@ -696,6 +696,7 @@ LDFLAGS
 CXXFLAGS
 CXX
 enable_serio
+enable_p1516_port
 enable_pdk_port
 enable_st7_port
 enable_stm8_port
@@ -777,6 +778,7 @@ enable_xa_port
 enable_stm8_port
 enable_pdk_port
 enable_st7_port
+enable_p1516_port
 enable_serio
 enable_statistic
 enable_shared
@@ -1449,6 +1451,7 @@ Optional Features:
   --disable-stm8-port     do not compile simulator for stm8
   --disable-pdk-port      do not compile simulator for pdk
   --enable-st7-port       compile simulator for st7
+  --enable-p1516-port     compile simulator for p1516
   --enable-serio          compile serio GUI tool (needs curses)
   --enable-statistic      compile statistical features (slower simulation)
   --enable-shared[=PKGS]  build shared libraries [default=yes]
@@ -2944,6 +2947,15 @@ else
   enable_st7_port="no"
 fi
 
+# Check whether --enable-p1516-port was given.
+if test "${enable_p1516_port+set}" = set; then :
+  enableval=$enable_p1516_port; if test $enable_p1516_port  != "no"; then
+    enable_p1516_port="yes"
+fi
+else
+  enable_p1516_port="yes"
+fi
+
 # Check whether --enable-serio was given.
 if test "${enable_serio+set}" = set; then :
   enableval=$enable_serio; if test $enable_serio != "no"; then
@@ -2971,6 +2983,7 @@ fi
 
 
 
+
 
 # Check whether --enable-statistic was given.
 if test "${enable_statistic+set}" = set; then :
@@ -18186,7 +18199,7 @@ _ACEOF
 # Generating output files
 # ===========================================================================
 
-ac_config_files="$ac_config_files Makefile main.mk:main_in.mk packages.mk:packages_in.mk sim.src/Makefile cmd.src/Makefile s51.src/Makefile avr.src/Makefile z80.src/Makefile tlcs.src/Makefile hc08.src/Makefile xa.src/Makefile stm8.src/Makefile pdk.src/Makefile st7.src/Makefile gui.src/Makefile gui.src/serio.src/Makefile doc/Makefile"
+ac_config_files="$ac_config_files Makefile main.mk:main_in.mk packages.mk:packages_in.mk sim.src/Makefile cmd.src/Makefile s51.src/Makefile avr.src/Makefile z80.src/Makefile tlcs.src/Makefile hc08.src/Makefile xa.src/Makefile stm8.src/Makefile pdk.src/Makefile st7.src/Makefile p1516.src/Makefile gui.src/Makefile gui.src/serio.src/Makefile doc/Makefile"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -19285,6 +19298,7 @@ do
     "stm8.src/Makefile") CONFIG_FILES="$CONFIG_FILES stm8.src/Makefile" ;;
     "pdk.src/Makefile") CONFIG_FILES="$CONFIG_FILES pdk.src/Makefile" ;;
     "st7.src/Makefile") CONFIG_FILES="$CONFIG_FILES st7.src/Makefile" ;;
+    "p1516.src/Makefile") CONFIG_FILES="$CONFIG_FILES p1516.src/Makefile" ;;
     "gui.src/Makefile") CONFIG_FILES="$CONFIG_FILES gui.src/Makefile" ;;
     "gui.src/serio.src/Makefile") CONFIG_FILES="$CONFIG_FILES gui.src/serio.src/Makefile" ;;
     "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
diff --git a/sdcc/sim/ucsim/configure.ac b/sdcc/sim/ucsim/configure.ac
index 6379862a4..3045e4d60 100644
--- a/sdcc/sim/ucsim/configure.ac
+++ b/sdcc/sim/ucsim/configure.ac
@@ -142,6 +142,12 @@ if test $enable_st7_port  != "no"; then
     enable_st7_port="yes"
 fi,
 enable_st7_port="no")
+AC_ARG_ENABLE(p1516-port,
+[  --enable-p1516-port     compile simulator for p1516],
+if test $enable_p1516_port  != "no"; then
+    enable_p1516_port="yes"
+fi,
+enable_p1516_port="yes")
 AC_ARG_ENABLE(serio,
 [  --enable-serio          compile serio GUI tool (needs curses)],
 if test $enable_serio != "no"; then
@@ -165,6 +171,7 @@ AC_SUBST(enable_xa_port)
 AC_SUBST(enable_stm8_port)
 AC_SUBST(enable_st7_port)
 AC_SUBST(enable_pdk_port)
+AC_SUBST(enable_p1516_port)
 AC_SUBST(enable_serio)
 
 AC_ARG_ENABLE(statistic,
@@ -714,6 +721,7 @@ xa.src/Makefile
 stm8.src/Makefile
 pdk.src/Makefile
 st7.src/Makefile
+p1516.src/Makefile
 gui.src/Makefile
 gui.src/serio.src/Makefile
 doc/Makefile
diff --git a/sdcc/sim/ucsim/fuio.cc b/sdcc/sim/ucsim/fuio.cc
index 0f4022e1d..b4cc545d4 100644
--- a/sdcc/sim/ucsim/fuio.cc
+++ b/sdcc/sim/ucsim/fuio.cc
@@ -88,8 +88,8 @@ cl_io::close(void)
   //file_f= NULL;
   file_id= -1;
   own= false;
-  file_name= 0;
-  file_mode= 0;
+  file_name= "";
+  file_mode= "";
 
   changed();
   return i;
diff --git a/sdcc/sim/ucsim/main_in.mk b/sdcc/sim/ucsim/main_in.mk
index eaca0f5cb..3f6063866 100644
--- a/sdcc/sim/ucsim/main_in.mk
+++ b/sdcc/sim/ucsim/main_in.mk
@@ -92,6 +92,7 @@ uninstall:
 	rm -f $(DESTDIR)$(bindir)/portmon$(EXEEXT)
 	rm -f $(DESTDIR)$(bindir)/sstm8$(EXEEXT)
 	rm -f $(DESTDIR)$(bindir)/sst7$(EXEEXT)
+	rm -f $(DESTDIR)$(bindir)/sp1516$(EXEEXT)
 
 
 # Performing self-test
diff --git a/sdcc/sim/ucsim/p1516.src/(c).1 b/sdcc/sim/ucsim/p1516.src/(c).1
new file mode 100644
index 000000000..d673f9fd8
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/(c).1
@@ -0,0 +1,25 @@
+/*
+ * Simulator of microcontrollers (@@F@@)
+ *
+ * Copyright (C) @@S@@,@@Y@@ Drotos Daniel, Talker Bt.
+ * 
+ * To contact author send email to drdani@mazsola.iit.uni-miskolc.hu
+ *
+ */
+
+/* This file is part of microcontroller simulator: ucsim.
+
+UCSIM is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+UCSIM is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with UCSIM; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA. */
diff --git a/sdcc/sim/ucsim/p1516.src/Makefile.in b/sdcc/sim/ucsim/p1516.src/Makefile.in
new file mode 100644
index 000000000..232a2d021
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/Makefile.in
@@ -0,0 +1,162 @@
+#
+# uCsim p1516.src/Makefile
+#
+# (c) Drotos Daniel, Talker Bt. 1997
+#
+
+STARTYEAR	= 1997
+
+SHELL		= /bin/sh
+CXX		= @CXX@
+CPP		= @CPP@
+CXXCPP		= @CXXCPP@
+RANLIB		= @RANLIB@
+INSTALL		= @INSTALL@
+STRIP		= @STRIP@
+MAKEDEP         = @MAKEDEP@
+
+top_builddir	= @top_builddir@
+top_srcdir	= @top_srcdir@
+
+transform	= @program_transform_name@
+
+DEFS            = $(subs -DHAVE_CONFIG_H,,@DEFS@)
+CPPFLAGS        = @CPPFLAGS@ -I$(srcdir) -I$(top_srcdir) -I$(top_builddir) \
+		  -I$(top_srcdir)/cmd.src -I$(top_srcdir)/sim.src \
+		  -I$(top_srcdir)/gui.src
+CFLAGS          = @CFLAGS@ @WALL_FLAG@
+CXXFLAGS        = @CXXFLAGS@ @WALL_FLAG@
+LDFLAGS         = @LDFLAGS@
+PICOPT		= @PICOPT@
+SHAREDLIB	= @SHAREDLIB@
+EXEEXT		= @EXEEXT@
+
+LIBS		= -L$(top_builddir) -lsim -lucsimutil -lguiucsim -lcmd -lsim @LIBS@
+DL		= @DL@
+dl_ok		= @dl_ok@
+
+prefix          = @prefix@
+exec_prefix     = @exec_prefix@
+bindir          = @bindir@
+libdir          = @libdir@
+datadir         = @datadir@
+datarootdir     = @datarootdir@
+includedir      = @includedir@
+mandir          = @mandir@
+man1dir         = $(mandir)/man1
+man2dir         = $(mandir)/man2
+infodir         = @infodir@
+srcdir          = @srcdir@
+VPATH           = @srcdir@
+
+OBJECTS_SHARED	= simp1516.o p1516.o glob.o
+
+OBJECTS_EXE	= sp1516.o
+OBJECTS		= $(OBJECTS_SHARED) $(OBJECTS_EXE)
+
+enable_dlso	= @enable_dlso@
+dlso_ok		= @dlso_ok@
+
+P1516ASM	=
+TEST_OBJ	= 
+
+
+# Compiling entire program or any subproject
+# ------------------------------------------
+all: checkconf otherlibs p1516.src
+
+
+# Compiling and installing everything and runing test
+# ---------------------------------------------------
+install: all installdirs
+	$(INSTALL) sp1516$(EXEEXT) $(DESTDIR)$(bindir)/`echo sp1516|sed '$(transform)'`$(EXEEXT)
+	$(STRIP) $(DESTDIR)$(bindir)/`echo sp1516|sed '$(transform)'`$(EXEEXT)
+
+
+# Deleting all the installed files
+# --------------------------------
+uninstall:
+	rm -f $(DESTDIR)$(bindir)/sp1516
+	rm -f $(DESTDIR)$(bindir)/`echo sp1516|sed '$(transform)'`$(EXEEXT)
+
+
+# Performing self-test
+# --------------------
+check: $(TEST_OBJ)
+
+test:
+
+
+# Performing installation test
+# ----------------------------
+installcheck:
+
+
+# Creating installation directories
+# ---------------------------------
+installdirs:
+	test -d $(DESTDIR)$(bindir) || $(INSTALL) -d $(DESTDIR)$(bindir)
+
+
+# Creating dependencies
+# ---------------------
+dep: Makefile.dep
+
+Makefile.dep: $(srcdir)/*.cc $(srcdir)/*.h
+	$(MAKEDEP) $(CPPFLAGS) $(filter %.cc,$^) >Makefile.dep
+
+-include Makefile.dep
+include $(srcdir)/clean.mk
+
+# My rules
+# --------
+.SUFFIXES: .asm .hex
+
+p1516.src: sp1516$(EXEEXT) ucsim_p1516$(EXEEXT) shared_lib
+
+sp1516$(EXEEXT): $(OBJECTS) $(top_builddir)/libcmd.a $(top_builddir)/libguiucsim.a $(top_builddir)/libsim.a $(top_builddir)/libucsimutil.a
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(OBJECTS) $(LIBS) -o $@
+
+ucsim_p1516$(EXEEXT): sp1516$(EXEEXT)
+	cp $< $@
+
+ifeq ($(dlso_ok),yes)
+shared_lib: $(top_builddir)/sp1516.so
+else
+shared_lib:
+	@$(top_srcdir)/mkecho $(top_builddir) "No P1516 shared lib made."
+	@$(top_srcdir)/mkecho $(top_builddir) "(SHAREDLIB="$(SHAREDLIB)",dl_ok="$(dl_ok)",enable_dlso="$(enable_dlso)")"
+endif
+
+$(top_builddir)/sp1516.so: $(OBJECTS_SHARED)
+	$(CXX) -shared $(LDFLAGS) $(OBJECTS_SHARED) -o $@
+
+otherlibs: $(top_builddir)/libcmd.a $(top_builddir)/libguiucsim.a $(top_builddir)/libsim.a $(top_builddir)/libucsimutil.a
+
+$(top_builddir)/libcmd.a:
+	$(MAKE) -C $(top_builddir)/cmd.src all
+
+$(top_builddir)/libguiucsim.a:
+	$(MAKE) -C $(top_builddir)/gui.src checkconf ucsim_lib
+
+$(top_builddir)/libsim.a:
+	$(MAKE) -C $(top_builddir)/sim.src all
+
+$(top_builddir)/libucsimutil.a:
+	$(MAKE) -C $(top_builddir) -f main.mk
+
+.cc.o:
+	$(CXX) $(CXXFLAGS) $(PICOPT) $(CPPFLAGS) $(TARGET_ARCH) -c $< -o $@
+
+.asm.hex:
+	$(P1516ASM) -l $< -o $@ -e $<.lst
+
+
+# Remaking configuration
+# ----------------------
+checkconf:
+	@if [ -f $(top_builddir)/devel ]; then\
+	  $(MAKE) -C $(top_builddir) -f conf.mk srcdir="$(srcdir)" top_builddir="$(top_builddir)" freshconf;\
+	fi
+
+# End of p1516.src/Makefile.in
diff --git a/sdcc/sim/ucsim/p1516.src/clean.mk b/sdcc/sim/ucsim/p1516.src/clean.mk
new file mode 100644
index 000000000..108ab2d85
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/clean.mk
@@ -0,0 +1,30 @@
+# p1516.src/clean.mk
+
+# Deleting all files created by building the program
+# --------------------------------------------------
+clean:
+	rm -f *core *[%~] *.[oa] *.map
+	rm -f .[a-z]*~
+	rm -f sp1516$(EXEEXT) sp1516.exe
+	rm -f ucsim_p1516$(EXEEXT) ucsim_p1516.exe
+
+
+# Deleting all files created by configuring or building the program
+# -----------------------------------------------------------------
+distclean: clean
+	rm -f config.cache config.log config.status
+	rm -f Makefile *.dep
+	rm -f *.obj *.list *.lst *.hex
+
+
+# Like clean but some files may still exist
+# -----------------------------------------
+mostlyclean: clean
+
+
+# Deleting everything that can reconstructed by this Makefile. It deletes
+# everything deleted by distclean plus files created by bison, etc.
+# -----------------------------------------------------------------------
+realclean: distclean
+
+# End of p1516.src/clean.mk
diff --git a/sdcc/sim/ucsim/p1516.src/conf.mk b/sdcc/sim/ucsim/p1516.src/conf.mk
new file mode 100644
index 000000000..6170a4e9d
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/conf.mk
@@ -0,0 +1,11 @@
+# p1516.src/conf.mk
+#
+# Makefile targets to remake configuration
+#
+
+freshconf: Makefile
+
+Makefile: $(srcdir)/Makefile.in $(top_srcdir)/configure.ac
+	cd $(top_builddir) && $(SHELL) ./config.status
+
+# End of p1516.src/conf.mk
diff --git a/sdcc/sim/ucsim/p1516.src/glob.cc b/sdcc/sim/ucsim/p1516.src/glob.cc
new file mode 100644
index 000000000..5006b2d78
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/glob.cc
@@ -0,0 +1,48 @@
+/*@1@*/
+
+#include "glob.h"
+
+
+struct dis_entry disass_p1516[]=
+  {
+   { 0x08000000, 0x08000000, ' ', 1, "call  %A", false },
+
+   { 0xb4f00000, 0xfff00000, 'M', 1, "jz    %O", false },
+   { 0x94f00000, 0xfff00000, 'M', 1, "jnz   %O", false },
+   { 0x74f00000, 0xfff00000, 'M', 1, "jc    %O", false },
+   { 0x54f00000, 0xfff00000, 'M', 1, "jnc   %O", false },
+   { 0x04f00000, 0x1ff00000, 'M', 1, "jmp   %O", false },
+   { 0x04f00000, 0x0ff00000, ' ', 1, "jump  %O", false },
+
+   { 0x00000000, 0x0f000000, ' ', 1, "nop", false },
+   { 0x01000000, 0x0f000000, ' ', 1, "ld    %d:=mem[%a]", false },
+   { 0x02000000, 0x0f000000, ' ', 1, "st    mem[%a]:=%d", false },
+   { 0x03000000, 0x0f000000, ' ', 1, "mov   %d:=%a", false },
+   { 0x04000000, 0x0f000000, ' ', 1, "ldl0  %d:=%0", false },
+   { 0x05000000, 0x0f000000, ' ', 1, "ldl   %d:=%l", false },
+   { 0x06000000, 0x0f000000, ' ', 1, "ldh   %d:=%h", false },
+
+   { 0x07000000, 0x0f000f80, ' ', 1, "add   %d:=%a+%b", false },
+   { 0x07000080, 0x0f000f80, ' ', 1, "addc  %d:=%a+%b", false },
+   { 0x07000100, 0x0f000f80, ' ', 1, "sub   %d:=%a-%b", false },
+   { 0x07000180, 0x0f000f80, ' ', 1, "sbb   %d:=%a-%b", false },
+   { 0x07000200, 0x0f000f80, ' ', 1, "inc   %d:=%a+1", false },
+   { 0x07000280, 0x0f000f80, ' ', 1, "dec   %d:=%a-1", false },
+   { 0x07000300, 0x0f000f80, ' ', 1, "and   %d:=%a&%b", false },
+   { 0x07000380, 0x0f000f80, ' ', 1, "or    %d:=%a|%b", false },
+   { 0x07000400, 0x0f000f80, ' ', 1, "xor   %d:=%a^%b", false },
+   { 0x07000480, 0x0f000f80, ' ', 1, "shl   %d:=u(%a)<<1", false },
+   { 0x07000500, 0x0f000f80, ' ', 1, "shr   %d:=u(%a)>>1", false },
+   { 0x07000800, 0x0f000f80, ' ', 1, "sha   %d:=s(%a)>>1", false },
+   { 0x07000580, 0x0f000f80, ' ', 1, "rol   %d:=(C,%a)<<1", false },
+   { 0x07000600, 0x0f000f80, ' ', 1, "ror   %d:=(%a,C)>>1", false },
+   { 0x07000680, 0x0f000f80, ' ', 1, "mul   %d:=%a*%b", false },
+   { 0x07000700, 0x0f000f80, ' ', 1, "div   %d:=%a/%b", false },
+   { 0x07000780, 0x0f000f80, ' ', 1, "cmp   F:=%a-%b", false },
+   { 0x07000880, 0x0f000f80, ' ', 1, "setc", false },
+   { 0x07000900, 0x0f000f80, ' ', 1, "clrc", false },
+   
+   { 0, 0, 0, 0, 0, 0 }
+  };
+
+/* End of p1516.src/glob.cc */
diff --git a/sdcc/sim/ucsim/p1516.src/glob.h b/sdcc/sim/ucsim/p1516.src/glob.h
new file mode 100644
index 000000000..d22d620c3
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/glob.h
@@ -0,0 +1,14 @@
+/*@1@*/
+
+#ifndef GLOB_HEADER
+#define GLOB_HEADER
+
+#include "stypes.h"
+
+
+extern struct dis_entry disass_p1516[];
+
+
+#endif
+
+/* End of p1516.src/glob.h */
diff --git a/sdcc/sim/ucsim/p1516.src/p1516.cc b/sdcc/sim/ucsim/p1516.src/p1516.cc
new file mode 100644
index 000000000..482e05d04
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/p1516.cc
@@ -0,0 +1,442 @@
+/*
+ * Simulator of microcontrollers (p1516.cc)
+ *
+ * Copyright (C) 2020,20 Drotos Daniel, Talker Bt.
+ * 
+ * To contact author send email to drdani@mazsola.iit.uni-miskolc.hu
+ *
+ */
+
+/* This file is part of microcontroller simulator: ucsim.
+
+UCSIM is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+UCSIM is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with UCSIM; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA. */
+/*@1@*/
+
+#include <stdlib.h>
+
+#include "glob.h"
+
+#include "p1516cl.h"
+
+
+cl_p1516::cl_p1516(class cl_sim *asim):
+  cl_uc(asim)
+{
+}
+
+int
+cl_p1516::init(void)
+{
+  int i;
+  cl_uc::init();
+  F= 0;
+  for (i=0; i<16; i++)
+    R[i]= 0;
+  return 0;
+}
+
+char *
+cl_p1516::id_string(void)
+{
+  return (char*)"P1516";
+}
+
+void
+cl_p1516::reset(void)
+{
+  PC= R[15]= 0;
+}
+  
+void
+cl_p1516::set_PC(t_addr addr)
+{
+  PC= R[15]= addr;
+}
+
+void
+cl_p1516::mk_hw_elements(void)
+{
+  //class cl_hw *h;
+  cl_uc::mk_hw_elements();
+  //add_hw(h= new cl_port(this));
+  //h->init();
+}
+
+void
+cl_p1516::make_memories(void)
+{
+  class cl_address_space *as;
+
+  rom= as= new cl_address_space("rom"/*MEM_ROM_ID*/, 0, 0x10000, 32);
+  as->init();
+  address_spaces->add(as);
+
+  class cl_address_decoder *ad;
+  class cl_memory_chip *chip;
+
+  chip= new cl_memory_chip("rom_chip", 0x10000, 32);
+  chip->init();
+  memchips->add(chip);
+  ad= new cl_address_decoder(as= rom/*address_space(MEM_ROM_ID)*/,
+			     chip, 0, 0xffff, 0);
+  ad->init();
+  as->decoders->add(ad);
+  ad->activate(0);
+}
+
+
+struct dis_entry *
+cl_p1516::dis_tbl(void)
+{
+  return(disass_p1516);
+}
+
+char *
+cl_p1516::disass(t_addr addr, const char *sep)
+{
+  chars work= chars(), temp= chars();
+  char *buf, *p;
+  const char *b;
+  t_mem code, data= 0;
+  int i;
+
+  //work= "";
+  //p= (char*)work;
+
+  code= rom->get(addr);
+  
+  i= 0;
+  while ((code & dis_tbl()[i].mask) != dis_tbl()[i].code &&
+	 dis_tbl()[i].mnemonic)
+    i++;
+  if (dis_tbl()[i].mnemonic == NULL)
+    {
+      buf= (char*)malloc(40);
+      strcpy(buf, "-- UNKNOWN/INVALID");
+      return(buf);
+    }
+  b= dis_tbl()[i].mnemonic;
+
+  data= (code&0xf0000000)>>28;
+  if (((data & 1) == 0) || (dis_tbl()[i].branch == 'M'))
+    work.append("   ");
+  else
+    {
+      switch (data>>2)
+	{
+	case 0: work.append("S"); break;
+	case 1: work.append("C"); break;
+	case 2: work.append("Z"); break;
+	case 3: work.append("O"); break;
+	}
+      if (data&2)
+	work.append("1 ");
+      else
+	work+= "0 ";
+    }
+
+  while (*b)
+    {
+      if (*b == '%')
+	{
+	  b++;
+	  switch (*(b++))
+	    {
+	    case 'd': // Rd
+	      data= (code & 0x00f00000)>>20;
+	      temp.format("r%d", data);
+	      break;
+	    case 'a': // Ra
+	      data= (code & 0x000f0000)>>16;
+	      temp.format("r%d", data);
+	      break;
+	    case 'b': // Rb
+	      data= (code & 0x0000f000)>>12;
+	      temp.format("r%d", data);
+	      break;
+	    case '0': // LDL0
+	      data= (code & 0x0000ffff);
+	      temp.format("0x0000%04x", data);
+	      break;
+	    case 'O': // LDL0
+	      data= (code & 0x0000ffff);
+	      temp.format("0x%04x", data);
+	      break;
+	    case 'l': // LDL
+	      data= (code & 0x0000ffff);
+	      temp.format("0x....%04x", data);
+	      break;
+	    case 'h': // LDH
+	      data= (code & 0x0000ffff);
+	      temp.format("0x%04x....", data);
+	      break;
+	    case 'A': // CALL
+	      data= (code & 0x07ffffff);
+	      temp.format("0x%x", data);
+	      break;
+	    default:
+	      temp= (char*)"?";
+	      break;
+	    }
+	  //t= temp;
+	  //while (*t) *(p++)= *(t++);
+	  work+= temp;
+	}
+      else
+	work.append(*(b++));
+    }
+  //*p= '\0';
+
+  p= (char*)work;
+  buf= strdup(p);
+  return(buf);
+}
+
+void
+cl_p1516::print_regs(class cl_console_base *con)
+{
+  int i;
+  con->dd_color("answer");
+  con->dd_printf("  F= 0x%x  ", F);
+  con->dd_printf("S=%c ", (F&S)?'1':'0');
+  con->dd_printf("C=%c ", (F&C)?'1':'0');
+  con->dd_printf("Z=%c ", (F&Z)?'1':'0');
+  con->dd_printf("O=%c ", (F&O)?'1':'0');
+  con->dd_printf("\n");
+  for (i= 0; i<16; i++)
+    {
+      if (i<10) con->dd_printf(" ");
+      con->dd_printf("R%d= 0x%08x ", i, R[i]);
+      if (i<10) con->dd_printf(" ");
+      con->dd_printf("[R%d]= 0x%08x", i, rom->get(R[i]));
+      if (i%2)
+	con->dd_printf("\n");
+      else
+	con->dd_printf(" ");
+    }
+  print_disass(PC, con);
+}
+
+
+t_mem
+cl_p1516::inst_ad(t_mem ra, t_mem rb, u32_t c)
+{
+  u64_t big;
+  u32_t rd;
+  
+  big= ra + rb + c;
+  F= 0;
+  if (big > 0xffffffff)
+    F|= C;
+  rd= big;
+  if (rd == 0)
+    F|= Z;
+  if (rd & 0x80000000)
+    F|= S;
+  big= (ra & 0x7fffffff) + (rb & 0x7fffffff) + c;
+  if ((big & 0x80000000) && !(F&C))
+    F|= O;
+  if (!(big & 0x80000000) && (F&C))
+    F|= O;
+  return rd;
+}
+
+int
+cl_p1516::inst_alu(t_mem code)
+{
+  u8_t d, a, b, Op;
+  u8_t c1, c2;
+  u64_t big;
+  
+  d= (code & 0x00f00000) >> 20;
+  a= (code & 0x000f0000) >> 16;
+  b= (code & 0x0000f000) >> 12;
+  Op=(code & 0x00000f80) >> 7;
+
+  switch (Op)
+    {
+    case 0: // ADD
+      R[d]= inst_ad(R[a], R[b], 0);
+      break;
+    case 1: // ADC
+      R[d]= inst_ad(R[a], R[b], (F&C)?1:0);
+      break;
+    case 2: // SUB
+      R[d]= inst_ad(R[a], ~R[b], 1);
+      break;
+    case 3: // SBB
+      R[d]= inst_ad(R[a], ~R[b], (F&C)?1:0);
+      break;
+
+    case 4: // INC
+      R[d]= R[a]+1;
+      break;
+    case 5: // DEC
+      R[d]= R[a]=1;
+      break;
+
+    case 6: // AND
+      R[d]= R[a] & R[b];
+      SET_Z(R[d]);
+      break;
+    case 7: // OR
+      R[d]= R[a] | R[b];
+      SET_Z(R[d]);
+      break;
+    case 8: // XOR
+      R[d]= R[a] ^ R[b];
+      SET_Z(R[d]);
+      break;
+
+    case 9: // SHL
+      SET_C(R[a] & 0x80000000);
+      R[d]= R[a] << 1;
+      SET_Z(R[d]);
+      break;
+    case 10: // SHR
+      SET_C(R[a] & 1);
+      R[d]= R[a] >> 1;
+      SET_Z(R[d]);
+      break;
+    case 16: // SHA
+      SET_C(R[a] & 1);
+      R[d]= ((i32_t)(R[a])) >> 1;
+      SET_Z(R[d]);
+      break;
+    case 11: // ROL
+      c1= (F&C)?1:0;
+      c2= (R[a] & 0x80000000)?1:0;
+      R[d]= (R[a]<<1) + c1;
+      SET_C(c2);
+      SET_Z(R[d]);
+      break;
+    case 12: // ROR
+      c1= (F&C)?1:0;
+      c2= R[a] & 1;
+      R[d]= R[a] >> 1;
+      if (c1)
+	R[d]|= 0x80000000;
+      SET_C(c2);
+      SET_Z(R[d]);
+      break;
+
+    case 13: // MUL
+      R[d]= R[a] * R[b];
+      SET_Z(R[d]);
+      SET_S(R[d] & 0x80000000);
+      break;
+    case 19: // MUH
+      big= R[a] * R[b];
+      R[d]= big >> 32;
+      SET_Z(R[d]);
+      SET_S(R[d] & 0x80000000);
+      break;
+    case 14: // DIV
+      break;
+
+    case 17: // SETC
+      SET_C(1);
+      break;
+    case 18: // CLRC
+      SET_C(0);
+      break;
+      
+    case 15: // CMP
+      inst_ad(R[a], ~R[b], 1);
+      break;
+    }
+  
+  return resGO;
+}
+
+int
+cl_p1516::exec_inst(void)
+{
+  t_mem code;
+  u8_t inst;
+  u8_t cond;
+  bool fe;
+  
+  PC= R[15];
+  instPC= PC;
+  fe= fetch(&code);
+  tick(1);
+  R[15]= PC;
+  if (fe)
+    return(resBREAKPOINT);
+
+  cond= (code & 0xf0000000) >> 28;
+  if ((cond&1) == 1)
+    {
+      u8_t flag, fv, v;
+      switch (cond>>2)
+	{
+	case 0: flag= F&S; break;
+	case 1: flag= F&C; break;
+	case 2: flag= F&Z; break;
+	case 3: flag= F&O; break;
+	}
+      fv= flag?1:0;
+      v= (cond&2)?1:0;
+      if (fv != v)
+	return resGO;
+    }
+  
+  inst= (code & 0x0f000000) >> 24;
+  if (code & 0x08000000)
+    {
+      // CALL
+      return resGO;
+    }
+
+  u8_t d, a;
+  d= (code & 0x00f00000) >> 20;
+  a= (code & 0x000f0000) >> 16;
+  switch (inst)
+    {
+    case 0: // nop
+      break;
+    case 1: // LD Rd,Ra
+      R[d]= rom->read(R[a]);
+      vc.rd++;
+      break;
+    case 2: // ST Rd,Ra
+      rom->write(R[a], R[d]);
+      vc.wr++;
+      break;
+    case 3: // MOV Rd,Ra
+      R[d]= R[a];
+      break;
+    case 4: // LDL0 Rd,data
+      R[d]= code & 0x0000ffff;
+      break;
+    case 5: // LDL Rd,data
+      R[d]= (R[d] & 0xffff0000) | (code & 0x0000ffff);
+      break;
+    case 6: // LDH Rd,data
+      R[d]= (R[d] & 0x0000ffff) | (code << 16);
+      break;
+    case 7: // ALU
+      inst_alu(code);
+      break;
+    }
+  PC= R[15];
+  
+  return resGO;
+}
+
+
+/* End of p1516.src/p1516.cc */
diff --git a/sdcc/sim/ucsim/p1516.src/p1516cl.h b/sdcc/sim/ucsim/p1516.src/p1516cl.h
new file mode 100644
index 000000000..ece51b06d
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/p1516cl.h
@@ -0,0 +1,79 @@
+/*
+ * Simulator of microcontrollers (p1516cl.h)
+ *
+ * Copyright (C) 2020,20 Drotos Daniel, Talker Bt.
+ * 
+ * To contact author send email to drdani@mazsola.iit.uni-miskolc.hu
+ *
+ */
+
+/* This file is part of microcontroller simulator: ucsim.
+
+UCSIM is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+UCSIM is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with UCSIM; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA. */
+/*@1@*/
+
+#ifndef P1516CL_HEADER
+#define P1516CL_HEADER
+
+#include "uccl.h"
+#include "memcl.h"
+
+
+/*
+ * Base of P1516 processor
+ */
+
+enum flags
+  {
+   S= 1,
+   C= 2,
+   Z= 4,
+   O= 8
+  };
+
+class cl_p1516: public cl_uc
+{
+public:
+  u8_t F;
+  u32_t R[16];
+public:
+  class cl_address_space *rom;
+ public:
+  cl_p1516(class cl_sim *asim);
+  virtual int init(void);
+  virtual char *id_string(void);
+  virtual void reset(void);
+  virtual void set_PC(t_addr addr);
+
+  virtual void mk_hw_elements(void);
+  virtual void make_memories(void);
+
+  virtual struct dis_entry *dis_tbl(void);
+  virtual char *disass(t_addr addr, const char *sep);
+  virtual void print_regs(class cl_console_base *con);
+
+  virtual t_mem inst_ad(t_mem ra, t_mem rb, u32_t c);
+  virtual int inst_alu(t_mem code);
+  virtual int exec_inst(void);
+};
+
+#define SET_C(v) ( F= (F&~C) | ((v)?C:0) )
+#define SET_Z(v) ( F= (F&~Z) | ((v==0)?Z:0) )
+#define SET_S(v) ( F= (F&~S) | ((v)?S:0) )
+
+#endif
+
+/* End of p1516.src/p1516.cc */
diff --git a/sdcc/sim/ucsim/p1516.src/simp1516.cc b/sdcc/sim/ucsim/p1516.src/simp1516.cc
new file mode 100644
index 000000000..976d5f929
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/simp1516.cc
@@ -0,0 +1,44 @@
+/*
+ * Simulator of microcontrollers (simp1516.cc)
+ *
+ * Copyright (C) 2020,20 Drotos Daniel, Talker Bt.
+ * 
+ * To contact author send email to drdani@mazsola.iit.uni-miskolc.hu
+ *
+ */
+
+/* This file is part of microcontroller simulator: ucsim.
+
+UCSIM is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+UCSIM is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with UCSIM; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA. */
+/*@1@*/
+
+// local
+#include "simp1516cl.h"
+#include "p1516cl.h"
+
+
+cl_simp1516::cl_simp1516(class cl_app *the_app):
+  cl_sim(the_app)
+{}
+
+class cl_uc *
+cl_simp1516::mk_controller(void)
+{
+  return(new cl_p1516(this));
+}
+
+
+/* End of p1516.src/simp1516.cc */
diff --git a/sdcc/sim/ucsim/p1516.src/simp1516cl.h b/sdcc/sim/ucsim/p1516.src/simp1516cl.h
new file mode 100644
index 000000000..c430cc778
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/simp1516cl.h
@@ -0,0 +1,45 @@
+/*
+ * Simulator of microcontrollers (simp1516cl.h)
+ *
+ * Copyright (C) 2020,20 Drotos Daniel, Talker Bt.
+ * 
+ * To contact author send email to drdani@mazsola.iit.uni-miskolc.hu
+ *
+ */
+
+/* This file is part of microcontroller simulator: ucsim.
+
+UCSIM is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+UCSIM is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with UCSIM; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA. */
+/*@1@*/
+
+#ifndef SIMP1516CL_HEADER
+#define SIMP1516CL_HEADER
+
+#include "simcl.h"
+
+
+class cl_simp1516: public cl_sim
+{
+public:
+  cl_simp1516(class cl_app *the_app);
+
+  virtual class cl_uc *mk_controller(void);
+};
+
+
+#endif
+
+/* End of p1516.src/simp1516cl.h */
diff --git a/sdcc/sim/ucsim/p1516.src/sp1516.cc b/sdcc/sim/ucsim/p1516.src/sp1516.cc
new file mode 100644
index 000000000..d50b2a826
--- /dev/null
+++ b/sdcc/sim/ucsim/p1516.src/sp1516.cc
@@ -0,0 +1,53 @@
+/*
+ * Simulator of microcontrollers (sp1516.cc)
+ *
+ * Copyright (C) 2020,20 Drotos Daniel, Talker Bt.
+ * 
+ * To contact author send email to drdani@mazsola.iit.uni-miskolc.hu
+ *
+ */
+
+/* This file is part of microcontroller simulator: ucsim.
+
+UCSIM is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+UCSIM is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with UCSIM; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA. */
+/*@1@*/
+
+// prj
+#include "globals.h"
+
+// local
+#include "simp1516cl.h"
+
+
+int
+main(int argc, char *argv[])
+{
+  class cl_sim *sim;
+  
+  application= new cl_app();
+  application->init(argc, argv);
+  sim= new cl_simp1516(application);
+  if (sim->init())
+    sim->state|= SIM_QUIT;
+  application->set_simulator(sim);
+  //sim->main();
+  application->run();
+  application->done();
+  delete application;
+  return(0);
+}
+
+/* End of p1516.src/sp1516.cc */
diff --git a/sdcc/sim/ucsim/packages_in.mk b/sdcc/sim/ucsim/packages_in.mk
index 6f5ac79b2..5f91f8584 100644
--- a/sdcc/sim/ucsim/packages_in.mk
+++ b/sdcc/sim/ucsim/packages_in.mk
@@ -14,7 +14,8 @@ enable_hc08_port    = @enable_hc08_port@
 enable_s08_port     = @enable_s08_port@
 enable_stm8_port    = @enable_stm8_port@
 enable_st7_port     = @enable_st7_port@
-enable_pdk_port    =  @enable_pdk_port@
+enable_pdk_port     = @enable_pdk_port@
+enable_p1516_port   = @enable_p1516_port@
 
 ifeq ($(enable_mcs51_port),yes)
 S51		= s51.src
@@ -94,10 +95,16 @@ else
 PDKD   =
 endif
 
+ifeq ($(enable_p1516_port),yes)
+P1516      	= p1516.src
+else
+P1516      =
+endif
+
 PKGS		= $(S51) $(S390) \
 		  $(SAVR) $(SZ80) $(SZ180) $(SGBZ80) $(SR2K) $(SR3KA) \
 		  $(TLCS) \
-		  $(SHC08) $(SS08) $(XA) $(STM8) $(ST7) $(PDK) doc
+		  $(SHC08) $(SS08) $(XA) $(STM8) $(ST7) $(PDK) $(P1516) doc
 
 PKGS_ALL	= cmd.src sim.src gui.src s51.src avr.src z80.src tlcs.src xa.src \
-		  hc08.src stm8.src st7.src pdk.src doc
+		  hc08.src stm8.src st7.src pdk.src p1516.src doc
diff --git a/sdcc/sim/ucsim/sim.src/uc.cc b/sdcc/sim/ucsim/sim.src/uc.cc
index 7440471f4..7750d9b29 100644
--- a/sdcc/sim/ucsim/sim.src/uc.cc
+++ b/sdcc/sim/ucsim/sim.src/uc.cc
@@ -1164,6 +1164,57 @@ cl_uc::read_omf_file(cl_f *f)
   return (written);
 }
 
+long
+cl_uc::read_asc_file(cl_f *f)
+{
+  int c;
+  chars line= chars();
+  bool in;
+  t_addr addr= 0;
+  
+  in= true;
+  while ((c= f->get_c()) &&
+	 (!f->eof()))
+    {
+      if (in)
+	{
+	  if ((c=='\n') || (c=='\r'))
+	    {
+	      in= false;
+	      {
+		chars word= chars();
+		char *s;
+		// process
+		line.trim();
+		line.start_parse();
+		word= line.token(" ");
+		s= (char*)word;
+		if (isxdigit(*s))
+		  {
+		    t_mem d= strtoll(s, 0, 16);
+		    set_rom(addr, d);
+		    addr++;
+		  }
+		line= (char*)"";
+	      }
+	    }
+	  else
+	    line.append(c);
+	}
+      else // out
+	{
+	  if ((c=='\n') || (c=='\r'))
+	    ;
+	  else
+	    {
+	      in= true;
+	      line.append(c);
+	    }
+	}
+    }
+  return addr;
+}
+  
 long
 cl_uc::read_cdb_file(cl_f *f)
 {
@@ -1243,6 +1294,11 @@ cl_uc::find_loadable_file(chars nam)
   if (o)
     return f;
 
+  c= chars("", "%s.asc", (char*)nam);
+  f->open(c, chars("r"));
+  o= (f->opened());
+  if (o)
+    return f;
   c= chars("", "%s.ihx", (char*)nam);
   f->open(c, chars("r"));
   o= (f->opened());
@@ -1281,6 +1337,11 @@ cl_uc::read_file(chars nam, class cl_console_base *con)
       return 0;
     }
   /*if (con) con->dd_*/printf("Loading from %s\n", f->get_file_name());
+  if (is_asc_file(f))
+    {
+      l= read_asc_file(f);
+      printf("%ld words read from %s\n", l, f->get_fname());
+    }
   if (is_hex_file(f))
     {
       l= read_hex_file(f);
diff --git a/sdcc/sim/ucsim/sim.src/uccl.h b/sdcc/sim/ucsim/sim.src/uccl.h
index 0f4518f72..7a4923298 100644
--- a/sdcc/sim/ucsim/sim.src/uccl.h
+++ b/sdcc/sim/ucsim/sim.src/uccl.h
@@ -241,7 +241,8 @@ public:
   virtual int init(void);
   virtual char *id_string(void);
   virtual void reset(void);
-
+  virtual void set_PC(t_addr addr) { PC= addr; }
+  
   // making objects
   virtual void make_memories(void);
   virtual void make_variables(void);
@@ -265,6 +266,7 @@ public:
   virtual long read_hex_file(cl_console_base *con);
   virtual long read_hex_file(cl_f *f);
   virtual long read_omf_file(cl_f *f);
+  virtual long read_asc_file(cl_f *f);
   virtual long read_cdb_file(cl_f *f);
   virtual cl_f *find_loadable_file(chars nam);
   virtual long read_file(chars nam, class cl_console_base *con);
diff --git a/sdcc/sim/ucsim/utils.cc b/sdcc/sim/ucsim/utils.cc
index 20a2c6f28..edf01876b 100644
--- a/sdcc/sim/ucsim/utils.cc
+++ b/sdcc/sim/ucsim/utils.cc
@@ -312,6 +312,23 @@ is_hex_file(class cl_f *f)
   return false;
 }
 
+bool
+is_asc_file(class cl_f *f)
+{
+  char *n;
+  if (!f)
+    return false;
+  n= f->get_file_name();
+  if (!n ||
+      !*n)
+    return false;
+
+  if (strend(n, cchars(".asc")))
+    return true;
+
+  return false;
+}
+
 bool
 is_omf_file(class cl_f *f)
 {
diff --git a/sdcc/sim/ucsim/utils.h b/sdcc/sim/ucsim/utils.h
index 5d0071745..cbcf7681e 100644
--- a/sdcc/sim/ucsim/utils.h
+++ b/sdcc/sim/ucsim/utils.h
@@ -62,6 +62,7 @@ extern bool strend(char *search_in, char *what);
 extern bool valid_sym_name(char *s);
 
 extern bool is_hex_file(class cl_f *f);
+extern bool is_asc_file(class cl_f *f);
 extern bool is_omf_file(class cl_f *f);
 extern bool is_cdb_file(class cl_f *f);
 
-- 
2.28.0.windows.1

