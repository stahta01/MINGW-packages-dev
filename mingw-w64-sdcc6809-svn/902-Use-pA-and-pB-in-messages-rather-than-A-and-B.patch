From 49a7900f5f2a8eb720c53f7e081abdcdf3a8959d Mon Sep 17 00:00:00 2001
From: Alan Modra <amodra@gmail.com>
Date: Mon, 19 Feb 2018 15:21:40 +1030
Subject: Use %pA and %pB in messages rather than %A and %B

First step towards compiler verification of _bfd_error_handler
arguments, and better verification of translated messages.

bfd/
	* bfd.c (_bfd_doprnt, _bfd_doprnt_scan): Handle %pA and %pB in place
	of %A and %B.
	* aout-adobe.c: Update all messages using %A and %B.
	* aout-cris.c: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* binary.c: Likewise.
	* cache.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coffswap.h: Likewise.
	* compress.c: Likewise.
	* cpu-arm.c: Likewise.
	* ecoff.c: Likewise.
	* elf-attrs.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-properties.c: Likewise.
	* elf-s390-common.c: Likewise.
	* elf.c: Likewise.
	* elf32-arc.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-d10v.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-epiphany.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-metag.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-moxie.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-nds32.c: Likewise.
	* elf32-nios2.c: Likewise.
	* elf32-or1k.c: Likewise.
	* elf32-pj.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-visium.c: Likewise.
	* elf32-wasm32.c: Likewise.
	* elf32-xgate.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfnn-aarch64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfnn-riscv.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elfxx-x86.c: Likewise.
	* hpux-core.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peXXigen.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* rs6000-core.c: Likewise.
	* srec.c: Likewise.
	* stabs.c: Likewise.
	* vms-alpha.c: Likewise.
	* xcofflink.c: Likewise.
---
 sdcc/support/sdbinutils/bfd/aout-adobe.c      |   2 +-
 sdcc/support/sdbinutils/bfd/aout-cris.c       |   6 +-
 sdcc/support/sdbinutils/bfd/aoutx.h           |  16 +-
 sdcc/support/sdbinutils/bfd/archive.c         |   2 +-
 sdcc/support/sdbinutils/bfd/bfd.c             | 108 +++++-----
 sdcc/support/sdbinutils/bfd/binary.c          |   2 +-
 sdcc/support/sdbinutils/bfd/cache.c           |   2 +-
 sdcc/support/sdbinutils/bfd/coff-alpha.c      |  10 +-
 sdcc/support/sdbinutils/bfd/coff-arm.c        |  36 ++--
 sdcc/support/sdbinutils/bfd/coff-i860.c       |   2 +-
 sdcc/support/sdbinutils/bfd/coff-mcore.c      |   8 +-
 sdcc/support/sdbinutils/bfd/coff-ppc.c        |  10 +-
 sdcc/support/sdbinutils/bfd/coff-rs6000.c     |   6 +-
 sdcc/support/sdbinutils/bfd/coff-sh.c         |  22 +-
 sdcc/support/sdbinutils/bfd/coff-tic4x.c      |   2 +-
 sdcc/support/sdbinutils/bfd/coff-tic54x.c     |   2 +-
 sdcc/support/sdbinutils/bfd/coff-tic80.c      |   2 +-
 sdcc/support/sdbinutils/bfd/coff64-rs6000.c   |   2 +-
 sdcc/support/sdbinutils/bfd/coffcode.h        |  44 ++--
 sdcc/support/sdbinutils/bfd/coffgen.c         |  12 +-
 sdcc/support/sdbinutils/bfd/cofflink.c        |  16 +-
 sdcc/support/sdbinutils/bfd/coffswap.h        |   4 +-
 sdcc/support/sdbinutils/bfd/compress.c        |   2 +-
 sdcc/support/sdbinutils/bfd/cpu-arm.c         |   6 +-
 sdcc/support/sdbinutils/bfd/ecoff.c           |   2 +-
 sdcc/support/sdbinutils/bfd/elf-attrs.c       |   6 +-
 sdcc/support/sdbinutils/bfd/elf-eh-frame.c    |  16 +-
 sdcc/support/sdbinutils/bfd/elf-ifunc.c       |   2 +-
 sdcc/support/sdbinutils/bfd/elf-m10300.c      |  10 +-
 sdcc/support/sdbinutils/bfd/elf-properties.c  |  12 +-
 sdcc/support/sdbinutils/bfd/elf-s390-common.c |   6 +-
 sdcc/support/sdbinutils/bfd/elf.c             | 104 +++++-----
 sdcc/support/sdbinutils/bfd/elf32-arc.c       |  40 ++--
 sdcc/support/sdbinutils/bfd/elf32-arm.c       | 190 +++++++++---------
 sdcc/support/sdbinutils/bfd/elf32-avr.c       |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-bfin.c      |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-cr16.c      |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-cr16c.c     |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-cris.c      |  42 ++--
 sdcc/support/sdbinutils/bfd/elf32-crx.c       |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-d10v.c      |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-d30v.c      |   4 +-
 sdcc/support/sdbinutils/bfd/elf32-epiphany.c  |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-fr30.c      |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-frv.c       |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-gen.c       |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-hppa.c      |  18 +-
 sdcc/support/sdbinutils/bfd/elf32-i370.c      |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-i386.c      |  32 +--
 sdcc/support/sdbinutils/bfd/elf32-i960.c      |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-ip2k.c      |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-iq2000.c    |   6 +-
 sdcc/support/sdbinutils/bfd/elf32-lm32.c      |   4 +-
 sdcc/support/sdbinutils/bfd/elf32-m32c.c      |   6 +-
 sdcc/support/sdbinutils/bfd/elf32-m32r.c      |  12 +-
 sdcc/support/sdbinutils/bfd/elf32-m68hc11.c   |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-m68hc12.c   |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-m68hc1x.c   |  10 +-
 sdcc/support/sdbinutils/bfd/elf32-m68k.c      |  16 +-
 sdcc/support/sdbinutils/bfd/elf32-mcore.c     |  10 +-
 sdcc/support/sdbinutils/bfd/elf32-mep.c       |   8 +-
 sdcc/support/sdbinutils/bfd/elf32-metag.c     |  14 +-
 .../support/sdbinutils/bfd/elf32-microblaze.c |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-moxie.c     |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-msp430.c    |  18 +-
 sdcc/support/sdbinutils/bfd/elf32-mt.c        |   4 +-
 sdcc/support/sdbinutils/bfd/elf32-nds32.c     |  42 ++--
 sdcc/support/sdbinutils/bfd/elf32-nios2.c     |   8 +-
 sdcc/support/sdbinutils/bfd/elf32-or1k.c      |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-pj.c        |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-ppc.c       |  88 ++++----
 sdcc/support/sdbinutils/bfd/elf32-rl78.c      |  24 +--
 sdcc/support/sdbinutils/bfd/elf32-rx.c        |  28 +--
 sdcc/support/sdbinutils/bfd/elf32-s390.c      |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-score.c     |   6 +-
 sdcc/support/sdbinutils/bfd/elf32-score7.c    |   6 +-
 .../support/sdbinutils/bfd/elf32-sh-symbian.c |   6 +-
 sdcc/support/sdbinutils/bfd/elf32-sh.c        |  64 +++---
 sdcc/support/sdbinutils/bfd/elf32-sh64.c      |  18 +-
 sdcc/support/sdbinutils/bfd/elf32-sparc.c     |   4 +-
 sdcc/support/sdbinutils/bfd/elf32-spu.c       |  28 +--
 sdcc/support/sdbinutils/bfd/elf32-tic6x.c     |  36 ++--
 sdcc/support/sdbinutils/bfd/elf32-tilepro.c   |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-v850.c      |  36 ++--
 sdcc/support/sdbinutils/bfd/elf32-vax.c       |  14 +-
 sdcc/support/sdbinutils/bfd/elf32-visium.c    |   4 +-
 sdcc/support/sdbinutils/bfd/elf32-wasm32.c    |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-xgate.c     |   2 +-
 sdcc/support/sdbinutils/bfd/elf32-xtensa.c    |  28 +--
 sdcc/support/sdbinutils/bfd/elf64-alpha.c     |  34 ++--
 sdcc/support/sdbinutils/bfd/elf64-gen.c       |   2 +-
 sdcc/support/sdbinutils/bfd/elf64-hppa.c      |   2 +-
 sdcc/support/sdbinutils/bfd/elf64-ia64-vms.c  |  50 ++---
 sdcc/support/sdbinutils/bfd/elf64-mmix.c      |  26 +--
 sdcc/support/sdbinutils/bfd/elf64-ppc.c       |  28 +--
 sdcc/support/sdbinutils/bfd/elf64-s390.c      |  16 +-
 sdcc/support/sdbinutils/bfd/elf64-sh64.c      |  16 +-
 sdcc/support/sdbinutils/bfd/elf64-sparc.c     |  18 +-
 sdcc/support/sdbinutils/bfd/elf64-x86-64.c    |  42 ++--
 sdcc/support/sdbinutils/bfd/elfcode.h         |   6 +-
 sdcc/support/sdbinutils/bfd/elfcore.h         |   2 +-
 sdcc/support/sdbinutils/bfd/elflink.c         | 118 +++++------
 sdcc/support/sdbinutils/bfd/elfnn-aarch64.c   |  34 ++--
 sdcc/support/sdbinutils/bfd/elfnn-ia64.c      |  38 ++--
 sdcc/support/sdbinutils/bfd/elfnn-riscv.c     |  20 +-
 sdcc/support/sdbinutils/bfd/elfxx-sparc.c     |  14 +-
 sdcc/support/sdbinutils/bfd/elfxx-tilegx.c    |  16 +-
 sdcc/support/sdbinutils/bfd/elfxx-x86.c       |  22 +-
 sdcc/support/sdbinutils/bfd/hpux-core.c       |   2 +-
 sdcc/support/sdbinutils/bfd/ieee.c            |  10 +-
 sdcc/support/sdbinutils/bfd/ihex.c            |  20 +-
 sdcc/support/sdbinutils/bfd/libbfd.c          |   2 +-
 sdcc/support/sdbinutils/bfd/linker.c          |  20 +-
 sdcc/support/sdbinutils/bfd/mach-o.c          |   2 +-
 sdcc/support/sdbinutils/bfd/merge.c           |   2 +-
 sdcc/support/sdbinutils/bfd/mmo.c             |  52 ++---
 sdcc/support/sdbinutils/bfd/oasys.c           |   2 +-
 sdcc/support/sdbinutils/bfd/pdp11.c           |   8 +-
 sdcc/support/sdbinutils/bfd/pe-mips.c         |   8 +-
 sdcc/support/sdbinutils/bfd/peXXigen.c        |  30 +--
 sdcc/support/sdbinutils/bfd/peicode.h         |  16 +-
 sdcc/support/sdbinutils/bfd/reloc.c           |  10 +-
 sdcc/support/sdbinutils/bfd/rs6000-core.c     |   2 +-
 sdcc/support/sdbinutils/bfd/srec.c            |   8 +-
 sdcc/support/sdbinutils/bfd/stabs.c           |   2 +-
 sdcc/support/sdbinutils/bfd/vms-alpha.c       |   8 +-
 sdcc/support/sdbinutils/bfd/xcofflink.c       |  26 +--
 127 files changed, 1112 insertions(+), 1108 deletions(-)

diff --git a/sdcc/support/sdbinutils/bfd/aout-adobe.c b/sdcc/support/sdbinutils/bfd/aout-adobe.c
index 4063a8a9c..7818f7f8f 100644
--- a/sdcc/support/sdbinutils/bfd/aout-adobe.c
+++ b/sdcc/support/sdbinutils/bfd/aout-adobe.c
@@ -123,7 +123,7 @@ aout_adobe_callback (bfd *abfd)
 	default:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: Unknown section type in a.out.adobe file: %x\n"),
+	    (_("%pB: Unknown section type in a.out.adobe file: %x\n"),
 	     abfd, ext->e_type[0]);
 	  goto no_more_sections;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/aout-cris.c b/sdcc/support/sdbinutils/bfd/aout-cris.c
index d1a236650..1c89fe34a 100644
--- a/sdcc/support/sdbinutils/bfd/aout-cris.c
+++ b/sdcc/support/sdbinutils/bfd/aout-cris.c
@@ -197,7 +197,7 @@ MY (swap_ext_reloc_out) (bfd *abfd,
   if (r_type > 2)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Invalid relocation type exported: %d"),
+      _bfd_error_handler (_("%pB: Invalid relocation type exported: %d"),
 			  abfd, r_type);
 
       bfd_set_error (bfd_error_wrong_format);
@@ -241,7 +241,7 @@ MY (swap_ext_reloc_in) (bfd *abfd,
   if (r_type > 2)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Invalid relocation type imported: %d"),
+      _bfd_error_handler (_("%pB: Invalid relocation type imported: %d"),
 			  abfd, r_type);
 
       bfd_set_error (bfd_error_wrong_format);
@@ -253,7 +253,7 @@ MY (swap_ext_reloc_in) (bfd *abfd,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: Bad relocation record imported: %d"), abfd, r_index);
+	(_("%pB: Bad relocation record imported: %d"), abfd, r_index);
 
       bfd_set_error (bfd_error_wrong_format);
 
diff --git a/sdcc/support/sdbinutils/bfd/aoutx.h b/sdcc/support/sdbinutils/bfd/aoutx.h
index eec9c4ad2..16a40343d 100644
--- a/sdcc/support/sdbinutils/bfd/aoutx.h
+++ b/sdcc/support/sdbinutils/bfd/aoutx.h
@@ -1281,7 +1281,7 @@ NAME (aout, set_section_contents) (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	   (_("%B: can not represent section `%A' in a.out object file format"),
+	   (_("%pB: can not represent section `%pA' in a.out object file format"),
 	     abfd, section);
 	  bfd_set_error (bfd_error_nonrepresentable_section);
 	  return FALSE;
@@ -1597,7 +1597,7 @@ translate_to_native_sym_flags (bfd *abfd,
 	 file.  */
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: can not represent section for symbol `%s' in a.out "
+	(_("%pB: can not represent section for symbol `%s' in a.out "
 	   "object file format"),
 	 abfd,
 	 cache_ptr->name != NULL ? cache_ptr->name : _("*unknown*"));
@@ -1633,7 +1633,7 @@ translate_to_native_sym_flags (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	   (_("%B: can not represent section `%A' in a.out object file format"),
+	   (_("%pB: can not represent section `%pA' in a.out object file format"),
 	     abfd, sec);
 	  bfd_set_error (bfd_error_nonrepresentable_section);
 	  return FALSE;
@@ -2420,7 +2420,7 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)
 	    {
 	      bfd_set_error (bfd_error_invalid_operation);
 	      _bfd_error_handler (_("\
-%B: attempt to write out unknown reloc type"), abfd);
+%pB: attempt to write out unknown reloc type"), abfd);
 	      return FALSE;
 	    }
 	  MY_swap_ext_reloc_out (abfd, *generic,
@@ -2438,7 +2438,7 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)
 	    {
 	      bfd_set_error (bfd_error_invalid_operation);
 	      _bfd_error_handler (_("\
-%B: attempt to write out unknown reloc type"), abfd);
+%pB: attempt to write out unknown reloc type"), abfd);
 	      return FALSE;
 	    }
 	  MY_swap_std_reloc_out (abfd, *generic,
@@ -4090,7 +4090,7 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,
       if (howto == NULL)
 	{
 	  (*flaginfo->info->callbacks->einfo)
-	    (_("%P: %B: unexpected relocation type\n"), input_bfd);
+	    (_("%P: %pB: unexpected relocation type\n"), input_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
@@ -4411,7 +4411,7 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,
       if (r_type >= TABLE_SIZE (howto_table_ext))
 	{
 	  (*flaginfo->info->callbacks->einfo)
-	    (_("%P: %B: unexpected relocation type\n"), input_bfd);
+	    (_("%P: %pB: unexpected relocation type\n"), input_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
@@ -5437,7 +5437,7 @@ NAME (aout, final_link) (bfd *abfd,
 		 by the reloc size.  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocatable link from %s to %s not supported"),
+		(_("%pB: relocatable link from %s to %s not supported"),
 		 abfd, sub->xvec->name, abfd->xvec->name);
 	      bfd_set_error (bfd_error_invalid_operation);
 	      goto error_return;
diff --git a/sdcc/support/sdbinutils/bfd/archive.c b/sdcc/support/sdbinutils/bfd/archive.c
index de08b19ee..2b0a7ac94 100644
--- a/sdcc/support/sdbinutils/bfd/archive.c
+++ b/sdcc/support/sdbinutils/bfd/archive.c
@@ -2418,7 +2418,7 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
 				     + (syms[src_count]->name[2] == '_'),
 				     "__gnu_lto_slim") == 0)
 			_bfd_error_handler
-			  (_("%B: plugin needed to handle lto object"),
+			  (_("%pB: plugin needed to handle lto object"),
 			   current);
 		      namelen = strlen (syms[src_count]->name);
 		      amt = sizeof (char *);
diff --git a/sdcc/support/sdbinutils/bfd/bfd.c b/sdcc/support/sdbinutils/bfd/bfd.c
index 05d475daa..18dcd2718 100644
--- a/sdcc/support/sdbinutils/bfd/bfd.c
+++ b/sdcc/support/sdbinutils/bfd/bfd.c
@@ -650,7 +650,7 @@ union _bfd_doprnt_args
 };
 
 /* This macro and _bfd_doprnt taken from libiberty _doprnt.c, tidied a
-   little and extended to handle '%A', '%B' and positional parameters.
+   little and extended to handle '%pA', '%pB' and positional parameters.
    'L' as a modifer for integer formats is used for bfd_vma and
    bfd_size_type args, which vary in size depending on BFD
    configuration.  */
@@ -867,53 +867,55 @@ _bfd_doprnt (FILE *stream, const char *format, union _bfd_doprnt_args *args)
 	      PRINT_TYPE (char *, p);
 	      break;
 	    case 'p':
-	      PRINT_TYPE (void *, p);
-	      break;
-	    case 'A':
-	      {
-		asection *sec;
-		bfd *abfd;
-		const char *group = NULL;
-		struct coff_comdat_info *ci;
-
-		sec = (asection *) args[arg_no].p;
-		if (sec == NULL)
-		  /* Invoking %A with a null section pointer is an
-		     internal error.  */
-		  abort ();
-		abfd = sec->owner;
-		if (abfd != NULL
-		    && bfd_get_flavour (abfd) == bfd_target_elf_flavour
-		    && elf_next_in_group (sec) != NULL
-		    && (sec->flags & SEC_GROUP) == 0)
-		  group = elf_group_name (sec);
-		else if (abfd != NULL
-			 && bfd_get_flavour (abfd) == bfd_target_coff_flavour
-			 && (ci = bfd_coff_get_comdat_section (sec->owner,
-							       sec)) != NULL)
-		  group = ci->name;
-		if (group != NULL)
-		  result = fprintf (stream, "%s[%s]", sec->name, group);
-		else
-		  result = fprintf (stream, "%s", sec->name);
-	      }
-	      break;
-	    case 'B':
-	      {
-		bfd *abfd;
-
-		abfd = (bfd *) args[arg_no].p;
-		if (abfd == NULL)
-		  /* Invoking %B with a null bfd pointer is an
-		     internal error.  */
-		  abort ();
-		else if (abfd->my_archive
-			 && !bfd_is_thin_archive (abfd->my_archive))
-		  result = fprintf (stream, "%s(%s)",
-				    abfd->my_archive->filename, abfd->filename);
-		else
-		  result = fprintf (stream, "%s", abfd->filename);
-	      }
+	      if (*ptr == 'A')
+		{
+		  asection *sec;
+		  bfd *abfd;
+		  const char *group = NULL;
+		  struct coff_comdat_info *ci;
+
+		  ptr++;
+		  sec = (asection *) args[arg_no].p;
+		  if (sec == NULL)
+		    /* Invoking %pA with a null section pointer is an
+		       internal error.  */
+		    abort ();
+		  abfd = sec->owner;
+		  if (abfd != NULL
+		      && bfd_get_flavour (abfd) == bfd_target_elf_flavour
+		      && elf_next_in_group (sec) != NULL
+		      && (sec->flags & SEC_GROUP) == 0)
+		    group = elf_group_name (sec);
+		  else if (abfd != NULL
+			   && bfd_get_flavour (abfd) == bfd_target_coff_flavour
+			   && (ci = bfd_coff_get_comdat_section (sec->owner,
+								 sec)) != NULL)
+		    group = ci->name;
+		  if (group != NULL)
+		    result = fprintf (stream, "%s[%s]", sec->name, group);
+		  else
+		    result = fprintf (stream, "%s", sec->name);
+		}
+	      else if (*ptr == 'B')
+		{
+		  bfd *abfd;
+
+		  ptr++;
+		  abfd = (bfd *) args[arg_no].p;
+		  if (abfd == NULL)
+		    /* Invoking %pB with a null bfd pointer is an
+		       internal error.  */
+		    abort ();
+		  else if (abfd->my_archive
+			   && !bfd_is_thin_archive (abfd->my_archive))
+		    result = fprintf (stream, "%s(%s)",
+				      abfd->my_archive->filename,
+				      abfd->filename);
+		  else
+		    result = fprintf (stream, "%s", abfd->filename);
+		}
+	      else
+		PRINT_TYPE (void *, p);
 	      break;
 	    default:
 	      abort();
@@ -1095,9 +1097,11 @@ _bfd_doprnt_scan (const char *format, union _bfd_doprnt_args *args)
 	      }
 	      break;
 	    case 's':
+	      arg_type = Ptr;
+	      break;
 	    case 'p':
-	    case 'A':
-	    case 'B':
+	      if (*ptr == 'A' || *ptr == 'B')
+		ptr++;
 	      arg_type = Ptr;
 	      break;
 	    default:
@@ -1117,8 +1121,8 @@ _bfd_doprnt_scan (const char *format, union _bfd_doprnt_args *args)
 /* This is the default routine to handle BFD error messages.
    Like fprintf (stderr, ...), but also handles some extra format specifiers.
 
-   %A section name from section.  For group components, prints group name too.
-   %B file name from bfd.  For archive components, prints archive too.
+   %pA section name from section.  For group components, prints group name too.
+   %pB file name from bfd.  For archive components, prints archive too.
 
    Beware: Only supports a maximum of 9 format arguments.  */
 
diff --git a/sdcc/support/sdbinutils/bfd/binary.c b/sdcc/support/sdbinutils/bfd/binary.c
index 518b8452a..3f0c8d992 100644
--- a/sdcc/support/sdbinutils/bfd/binary.c
+++ b/sdcc/support/sdbinutils/bfd/binary.c
@@ -273,7 +273,7 @@ binary_set_section_contents (bfd *abfd,
 	  if (s->filepos < 0)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("warning: writing section `%A' at huge (ie negative) "
+	      (_("warning: writing section `%pA' at huge (ie negative) "
 		 "file offset"),
 	       s);
 	}
diff --git a/sdcc/support/sdbinutils/bfd/cache.c b/sdcc/support/sdbinutils/bfd/cache.c
index d33301f31..4b14043ec 100644
--- a/sdcc/support/sdbinutils/bfd/cache.c
+++ b/sdcc/support/sdbinutils/bfd/cache.c
@@ -270,7 +270,7 @@ bfd_cache_lookup_worker (bfd *abfd, enum cache_flag flag)
     return (FILE *) abfd->iostream;
 
   /* xgettext:c-format */
-  _bfd_error_handler (_("reopening %B: %s\n"),
+  _bfd_error_handler (_("reopening %pB: %s\n"),
 		      orig_bfd, bfd_errmsg (bfd_get_error ()));
   return NULL;
 }
diff --git a/sdcc/support/sdbinutils/bfd/coff-alpha.c b/sdcc/support/sdbinutils/bfd/coff-alpha.c
index fe8669f86..f5cd8bff5 100644
--- a/sdcc/support/sdbinutils/bfd/coff-alpha.c
+++ b/sdcc/support/sdbinutils/bfd/coff-alpha.c
@@ -447,7 +447,7 @@ alpha_ecoff_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED,
 
   if (ALPHA_ECOFF_COMPRESSEDMAG (*internal_f))
     _bfd_error_handler
-      (_("%B: Cannot handle compressed Alpha binaries.\n"
+      (_("%pB: Cannot handle compressed Alpha binaries.\n"
 	 "   Use compiler flags, or objZ, to generate uncompressed binaries."),
        abfd);
 
@@ -599,7 +599,7 @@ alpha_adjust_reloc_in (bfd *abfd,
     {
       /* xgettext:c-format */
       _bfd_error_handler
-	(_("%B: unknown/unsupported relocation type %d"),
+	(_("%pB: unknown/unsupported relocation type %d"),
 	 abfd, intern->r_type);
       bfd_set_error (bfd_error_bad_value);
       rptr->addend = 0;
@@ -1500,14 +1500,14 @@ alpha_relocate_section (bfd *output_bfd,
 	{
 	case ALPHA_R_GPRELHIGH:
 	  _bfd_error_handler
-	    (_("%B: unsupported relocation: ALPHA_R_GPRELHIGH"),
+	    (_("%pB: unsupported relocation: ALPHA_R_GPRELHIGH"),
 	     input_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  continue;
 
 	case ALPHA_R_GPRELLOW:
 	  _bfd_error_handler
-	    (_("%B: unsupported relocation: ALPHA_R_GPRELLOW"),
+	    (_("%pB: unsupported relocation: ALPHA_R_GPRELLOW"),
 	     input_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  continue;
@@ -1515,7 +1515,7 @@ alpha_relocate_section (bfd *output_bfd,
 	default:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: unknown relocation type %d"),
+	    (_("%pB: unknown relocation type %d"),
 	     input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  continue;
diff --git a/sdcc/support/sdbinutils/bfd/coff-arm.c b/sdcc/support/sdbinutils/bfd/coff-arm.c
index 4e80a596e..c81b4337f 100644
--- a/sdcc/support/sdbinutils/bfd/coff-arm.c
+++ b/sdcc/support/sdbinutils/bfd/coff-arm.c
@@ -1034,7 +1034,7 @@ find_thumb_glue (struct bfd_link_info *info,
 
   if (myh == NULL)
     /* xgettext:c-format */
-    _bfd_error_handler (_("%B: unable to find THUMB glue '%s' for `%s'"),
+    _bfd_error_handler (_("%pB: unable to find THUMB glue '%s' for `%s'"),
 			input_bfd, tmp_name, name);
 
   free (tmp_name);
@@ -1063,7 +1063,7 @@ find_arm_glue (struct bfd_link_info *info,
 
   if (myh == NULL)
     /* xgettext:c-format */
-    _bfd_error_handler (_("%B: unable to find ARM glue '%s' for `%s'"),
+    _bfd_error_handler (_("%pB: unable to find ARM glue '%s' for `%s'"),
 			input_bfd, tmp_name, name);
 
   free (tmp_name);
@@ -1365,8 +1365,8 @@ coff_arm_relocate_section (bfd *output_bfd,
 			      && ! INTERWORK_FLAG (h_sec->owner))
 			    _bfd_error_handler
 			      /* xgettext:c-format */
-			      (_("%B(%s): warning: interworking not enabled.\n"
-				 "  first occurrence: %B: arm call to thumb"),
+			      (_("%pB(%s): warning: interworking not enabled.\n"
+				 "  first occurrence: %pB: arm call to thumb"),
 			       h_sec->owner, name, input_bfd);
 
 			  --my_offset;
@@ -1455,8 +1455,8 @@ coff_arm_relocate_section (bfd *output_bfd,
 			      && ! globals->support_old_code)
 			    _bfd_error_handler
 			      /* xgettext:c-format */
-			      (_("%B(%s): warning: interworking not enabled.\n"
-				 "  first occurrence: %B: thumb call to arm\n"
+			      (_("%pB(%s): warning: interworking not enabled.\n"
+				 "  first occurrence: %pB: thumb call to arm\n"
 				 "  consider relinking with --support-old-code enabled"),
 			       h_sec->owner, name, input_bfd);
 
@@ -1748,7 +1748,7 @@ coff_arm_relocate_section (bfd *output_bfd,
 	case bfd_reloc_outofrange:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: bad reloc address %#Lx in section `%A'"),
+	    (_("%pB: bad reloc address %#Lx in section `%pA'"),
 	     input_bfd, rel->r_vaddr, input_section);
 	  return FALSE;
 	case bfd_reloc_overflow:
@@ -2073,7 +2073,7 @@ bfd_arm_process_before_allocation (bfd *		   abfd,
 	  if (symndx >= obj_conv_table_size (abfd))
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B: illegal symbol index in reloc: %ld"),
+	      _bfd_error_handler (_("%pB: illegal symbol index in reloc: %ld"),
 				  abfd, symndx);
 	      continue;
 	    }
@@ -2205,7 +2205,7 @@ coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("error: %B is compiled for APCS-%d, whereas %B is compiled for APCS-%d"),
+		(_("error: %pB is compiled for APCS-%d, whereas %pB is compiled for APCS-%d"),
 		 ibfd, APCS_26_FLAG (ibfd) ? 26 : 32,
 		 obfd, APCS_26_FLAG (obfd) ? 26 : 32
 		 );
@@ -2219,12 +2219,12 @@ coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)
 	      if (APCS_FLOAT_FLAG (ibfd))
 		/* xgettext: c-format */
 		_bfd_error_handler (_("\
-error: %B passes floats in float registers, whereas %B passes them in integer registers"),
+error: %pB passes floats in float registers, whereas %pB passes them in integer registers"),
 				    ibfd, obfd);
 	      else
 		/* xgettext: c-format */
 		_bfd_error_handler (_("\
-error: %B passes floats in integer registers, whereas %B passes them in float registers"),
+error: %pB passes floats in integer registers, whereas %pB passes them in float registers"),
 				    ibfd, obfd);
 
 	      bfd_set_error (bfd_error_wrong_format);
@@ -2236,12 +2236,12 @@ error: %B passes floats in integer registers, whereas %B passes them in float re
 	      if (PIC_FLAG (ibfd))
 		/* xgettext: c-format */
 		_bfd_error_handler (_("\
-error: %B is compiled as position independent code, whereas target %B is absolute position"),
+error: %pB is compiled as position independent code, whereas target %pB is absolute position"),
 				    ibfd, obfd);
 	      else
 		/* xgettext: c-format */
 		_bfd_error_handler (_("\
-error: %B is compiled as absolute position code, whereas target %B is position independent"),
+error: %pB is compiled as absolute position code, whereas target %pB is position independent"),
 				    ibfd, obfd);
 
 	      bfd_set_error (bfd_error_wrong_format);
@@ -2268,12 +2268,12 @@ error: %B is compiled as absolute position code, whereas target %B is position i
 	      if (INTERWORK_FLAG (ibfd))
 		/* xgettext: c-format */
 		_bfd_error_handler (_("\
-Warning: %B supports interworking, whereas %B does not"),
+Warning: %pB supports interworking, whereas %pB does not"),
 				    ibfd, obfd);
 	      else
 		/* xgettext: c-format */
 		_bfd_error_handler (_("\
-Warning: %B does not support interworking, whereas %B does"),
+Warning: %pB does not support interworking, whereas %pB does"),
 				    ibfd, obfd);
 	    }
 	}
@@ -2363,10 +2363,10 @@ _bfd_coff_arm_set_private_flags (bfd * abfd, flagword flags)
   if (INTERWORK_SET (abfd) && (INTERWORK_FLAG (abfd) != flag))
     {
       if (flag)
-	_bfd_error_handler (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
+	_bfd_error_handler (_("Warning: Not setting interworking flag of %pB since it has already been specified as non-interworking"),
 			    abfd);
       else
-	_bfd_error_handler (_("Warning: Clearing the interworking flag of %B due to outside request"),
+	_bfd_error_handler (_("Warning: Clearing the interworking flag of %pB due to outside request"),
 			    abfd);
       flag = 0;
     }
@@ -2424,7 +2424,7 @@ coff_arm_copy_private_bfd_data (bfd * src, bfd * dest)
 		{
 		  /* xgettext:c-format */
 		  _bfd_error_handler (_("\
-Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
+Warning: Clearing the interworking flag of %pB because non-interworking code in %pB has been linked with it"),
 				      dest, src);
 		}
 
diff --git a/sdcc/support/sdbinutils/bfd/coff-i860.c b/sdcc/support/sdbinutils/bfd/coff-i860.c
index 13c84af31..b179e6322 100644
--- a/sdcc/support/sdbinutils/bfd/coff-i860.c
+++ b/sdcc/support/sdbinutils/bfd/coff-i860.c
@@ -610,7 +610,7 @@ i860_reloc_processing (arelent *cache_ptr, struct internal_reloc *dst,
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: warning: illegal symbol index %ld in relocs"),
+		(_("%pB: warning: illegal symbol index %ld in relocs"),
 		 abfd, dst->r_symndx);
 	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	      ptr = NULL;
diff --git a/sdcc/support/sdbinutils/bfd/coff-mcore.c b/sdcc/support/sdbinutils/bfd/coff-mcore.c
index 80432d1ee..5e3b7d4c7 100644
--- a/sdcc/support/sdbinutils/bfd/coff-mcore.c
+++ b/sdcc/support/sdbinutils/bfd/coff-mcore.c
@@ -242,7 +242,7 @@ mcore_coff_unsupported_reloc (bfd * abfd,
   BFD_ASSERT (reloc_entry->howto != (reloc_howto_type *)0);
 
   /* xgettext: c-format */
-  _bfd_error_handler (_("%B: Relocation %s (%d) is not currently supported.\n"),
+  _bfd_error_handler (_("%pB: Relocation %s (%d) is not currently supported.\n"),
 		      abfd,
 		      reloc_entry->howto->name,
 		      reloc_entry->howto->type);
@@ -368,7 +368,7 @@ coff_mcore_relocate_section (bfd * output_bfd,
     {
       _bfd_error_handler
 	/* xgettext: c-format */
-	(_("%B: compiled for a %s system and target is %s.\n"),
+	(_("%pB: compiled for a %s system and target is %s.\n"),
 	 input_bfd,
 	 bfd_big_endian (input_bfd) ? _("big endian") : _("little endian"),
 	 bfd_big_endian (output_bfd) ? _("big endian") : _("little endian"));
@@ -470,7 +470,7 @@ coff_mcore_relocate_section (bfd * output_bfd,
 	{
 	default:
 	  /* xgettext: c-format */
-	  _bfd_error_handler (_("%B: unsupported relocation type 0x%02x"),
+	  _bfd_error_handler (_("%pB: unsupported relocation type 0x%02x"),
 			      input_bfd, r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -478,7 +478,7 @@ coff_mcore_relocate_section (bfd * output_bfd,
 	case IMAGE_REL_MCORE_ABSOLUTE:
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("Warning: unsupported reloc %s <file %B, section %A>\n"
+	    (_("Warning: unsupported reloc %s <file %pB, section %pA>\n"
 	       "sym %ld (%s), r_vaddr %Ld (%#Lx)"),
 	     howto->name, input_bfd, input_section,
 	     rel->r_symndx, my_name, rel->r_vaddr, rel->r_vaddr);
diff --git a/sdcc/support/sdbinutils/bfd/coff-ppc.c b/sdcc/support/sdbinutils/bfd/coff-ppc.c
index 74f93d584..eb8958508 100644
--- a/sdcc/support/sdbinutils/bfd/coff-ppc.c
+++ b/sdcc/support/sdbinutils/bfd/coff-ppc.c
@@ -1040,7 +1040,7 @@ coff_ppc_relocate_section (bfd *output_bfd,
 	default:
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: unsupported relocation type 0x%02x"), input_bfd, r_type);
+	    (_("%pB: unsupported relocation type 0x%02x"), input_bfd, r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	case IMAGE_REL_PPC_TOCREL16:
@@ -1131,7 +1131,7 @@ coff_ppc_relocate_section (bfd *output_bfd,
 		      {
 			_bfd_error_handler
 			  /* xgettext: c-format */
-			  (_("%B: Relocation for %s of %#Lx exceeds "
+			  (_("%pB: Relocation for %s of %#Lx exceeds "
 			     "Toc size limit"),
 			   input_bfd, name, our_toc_offset);
 			bfd_set_error (bfd_error_bad_value);
@@ -1185,7 +1185,7 @@ coff_ppc_relocate_section (bfd *output_bfd,
 	      {
 		_bfd_error_handler
 		  /* xgettext: c-format */
-		  (_("%B: Relocation exceeds allocated TOC (%#Lx)"),
+		  (_("%pB: Relocation exceeds allocated TOC (%#Lx)"),
 		   input_bfd, toc_section->size);
 		bfd_set_error (bfd_error_bad_value);
 		return FALSE;
@@ -1240,7 +1240,7 @@ coff_ppc_relocate_section (bfd *output_bfd,
 
 	    _bfd_error_handler
 	      /* xgettext: c-format */
-	      (_("Warning: unsupported reloc %s <file %B, section %A>\n"
+	      (_("Warning: unsupported reloc %s <file %pB, section %pA>\n"
 		 "sym %ld (%s), r_vaddr %Ld (%#Lx)"),
 	       howto->name, input_bfd, input_section,
 	       rel->r_symndx, my_name, rel->r_vaddr, rel->r_vaddr);
@@ -1258,7 +1258,7 @@ coff_ppc_relocate_section (bfd *output_bfd,
 
 	    _bfd_error_handler
 	      /* xgettext: c-format */
-	      (_("%B: Out of order IMGLUE reloc for %s"), input_bfd, my_name);
+	      (_("%pB: Out of order IMGLUE reloc for %s"), input_bfd, my_name);
 	    bfd_set_error (bfd_error_bad_value);
 	    return FALSE;
 	  }
diff --git a/sdcc/support/sdbinutils/bfd/coff-rs6000.c b/sdcc/support/sdbinutils/bfd/coff-rs6000.c
index 2fc1feb1c..af6597944 100644
--- a/sdcc/support/sdbinutils/bfd/coff-rs6000.c
+++ b/sdcc/support/sdbinutils/bfd/coff-rs6000.c
@@ -2770,7 +2770,7 @@ xcoff_reloc_type_fail (bfd *input_bfd,
 {
   _bfd_error_handler
     /* xgettext: c-format */
-    (_("%B: unsupported relocation type 0x%02x"),
+    (_("%pB: unsupported relocation type 0x%02x"),
      input_bfd, (unsigned int) rel->r_type);
   bfd_set_error (bfd_error_bad_value);
   return FALSE;
@@ -2856,7 +2856,7 @@ xcoff_reloc_type_toc (bfd *input_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: TOC reloc at %#Lx to symbol `%s' with no TOC entry"),
+	    (_("%pB: TOC reloc at %#Lx to symbol `%s' with no TOC entry"),
 	     input_bfd, rel->r_vaddr, h->root.root.string);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -3602,7 +3602,7 @@ xcoff_create_csect_from_smclas (bfd *abfd,
     {
       _bfd_error_handler
 	/* xgettext: c-format */
-	(_("%B: symbol `%s' has unrecognized smclas %d"),
+	(_("%pB: symbol `%s' has unrecognized smclas %d"),
 	 abfd, symbol_name, aux->x_csect.x_smclas);
       bfd_set_error (bfd_error_bad_value);
     }
diff --git a/sdcc/support/sdbinutils/bfd/coff-sh.c b/sdcc/support/sdbinutils/bfd/coff-sh.c
index 3a921fd02..a6dc366e4 100644
--- a/sdcc/support/sdbinutils/bfd/coff-sh.c
+++ b/sdcc/support/sdbinutils/bfd/coff-sh.c
@@ -775,7 +775,7 @@ sh_relax_section (bfd *abfd,
       if (laddr >= sec->size)
 	{
 	  /* xgettext: c-format */
-	  _bfd_error_handler (_("%B: %#Lx: warning: bad R_SH_USES offset"),
+	  _bfd_error_handler (_("%pB: %#Lx: warning: bad R_SH_USES offset"),
 			      abfd, irel->r_vaddr);
 	  continue;
 	}
@@ -786,7 +786,7 @@ sh_relax_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: %#Lx: warning: R_SH_USES points to unrecognized insn %#x"),
+	    (_("%pB: %#Lx: warning: R_SH_USES points to unrecognized insn %#x"),
 	     abfd, irel->r_vaddr, insn);
 	  continue;
 	}
@@ -804,7 +804,7 @@ sh_relax_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: %#Lx: warning: bad R_SH_USES load offset"),
+	    (_("%pB: %#Lx: warning: bad R_SH_USES load offset"),
 	     abfd, irel->r_vaddr);
 	  continue;
 	}
@@ -829,7 +829,7 @@ sh_relax_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: %#Lx: warning: could not find expected reloc"),
+	    (_("%pB: %#Lx: warning: could not find expected reloc"),
 	     abfd, paddr);
 	  continue;
 	}
@@ -846,7 +846,7 @@ sh_relax_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: %#Lx: warning: symbol in unexpected section"),
+	    (_("%pB: %#Lx: warning: symbol in unexpected section"),
 	     abfd, paddr);
 	  continue;
 	}
@@ -972,7 +972,7 @@ sh_relax_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: %#Lx: warning: could not find expected COUNT reloc"),
+	    (_("%pB: %#Lx: warning: could not find expected COUNT reloc"),
 	     abfd, paddr);
 	  continue;
 	}
@@ -982,7 +982,7 @@ sh_relax_section (bfd *abfd,
       if (irelcount->r_offset == 0)
 	{
 	  /* xgettext: c-format */
-	  _bfd_error_handler (_("%B: %#Lx: warning: bad count"),
+	  _bfd_error_handler (_("%pB: %#Lx: warning: bad count"),
 			      abfd, paddr);
 	  continue;
 	}
@@ -1354,7 +1354,7 @@ sh_relax_delete_bytes (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: %#Lx: fatal: reloc overflow while relaxing"),
+		(_("%pB: %#Lx: fatal: reloc overflow while relaxing"),
 		 abfd, irel->r_vaddr);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -1449,7 +1449,7 @@ sh_relax_delete_bytes (bfd *abfd,
       || obj_raw_syments (abfd) != NULL)
     {
       _bfd_error_handler
-	(_("%B: fatal: generic symbols retrieved before relaxing"), abfd);
+	(_("%pB: fatal: generic symbols retrieved before relaxing"), abfd);
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
     }
@@ -2642,7 +2642,7 @@ sh_swap_insns (bfd *      abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: %#Lx: fatal: reloc overflow while relaxing"),
+		(_("%pB: %#Lx: fatal: reloc overflow while relaxing"),
 		 abfd, irel->r_vaddr);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -2780,7 +2780,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: illegal symbol index %ld in relocs"),
+		(_("%pB: illegal symbol index %ld in relocs"),
 		 input_bfd, symndx);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/coff-tic4x.c b/sdcc/support/sdbinutils/bfd/coff-tic4x.c
index 660b51974..0be90de44 100644
--- a/sdcc/support/sdbinutils/bfd/coff-tic4x.c
+++ b/sdcc/support/sdbinutils/bfd/coff-tic4x.c
@@ -224,7 +224,7 @@ tic4x_reloc_processing (arelent *relent,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: warning: illegal symbol index %ld in relocs"),
+	    (_("%pB: warning: illegal symbol index %ld in relocs"),
 	     abfd, reloc->r_symndx);
 	  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	  ptr = NULL;
diff --git a/sdcc/support/sdbinutils/bfd/coff-tic54x.c b/sdcc/support/sdbinutils/bfd/coff-tic54x.c
index 0b6848fd3..9a1757909 100644
--- a/sdcc/support/sdbinutils/bfd/coff-tic54x.c
+++ b/sdcc/support/sdbinutils/bfd/coff-tic54x.c
@@ -362,7 +362,7 @@ tic54x_reloc_processing (arelent *relent,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: warning: illegal symbol index %ld in relocs"),
+	    (_("%pB: warning: illegal symbol index %ld in relocs"),
 	     abfd, reloc->r_symndx);
 	  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	  ptr = NULL;
diff --git a/sdcc/support/sdbinutils/bfd/coff-tic80.c b/sdcc/support/sdbinutils/bfd/coff-tic80.c
index 3496a05b0..292053178 100644
--- a/sdcc/support/sdbinutils/bfd/coff-tic80.c
+++ b/sdcc/support/sdbinutils/bfd/coff-tic80.c
@@ -669,7 +669,7 @@ coff_tic80_relocate_section (bfd *output_bfd,
 	case bfd_reloc_outofrange:
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: bad reloc address %#Lx in section `%A'"),
+	    (_("%pB: bad reloc address %#Lx in section `%pA'"),
 	     input_bfd, rel->r_vaddr, input_section);
 	  return FALSE;
 	case bfd_reloc_overflow:
diff --git a/sdcc/support/sdbinutils/bfd/coff64-rs6000.c b/sdcc/support/sdbinutils/bfd/coff64-rs6000.c
index 884d82a12..6f342c0f3 100644
--- a/sdcc/support/sdbinutils/bfd/coff64-rs6000.c
+++ b/sdcc/support/sdbinutils/bfd/coff64-rs6000.c
@@ -2147,7 +2147,7 @@ xcoff64_create_csect_from_smclas (bfd *abfd, union internal_auxent *aux,
     {
       _bfd_error_handler
 	/* xgettext: c-format */
-	(_("%B: symbol `%s' has unrecognized smclas %d"),
+	(_("%pB: symbol `%s' has unrecognized smclas %d"),
 	 abfd, symbol_name, aux->x_csect.x_smclas);
       bfd_set_error (bfd_error_bad_value);
     }
diff --git a/sdcc/support/sdbinutils/bfd/coffcode.h b/sdcc/support/sdbinutils/bfd/coffcode.h
index ec0103e8f..9017c0d9e 100644
--- a/sdcc/support/sdbinutils/bfd/coffcode.h
+++ b/sdcc/support/sdbinutils/bfd/coffcode.h
@@ -965,7 +965,7 @@ handle_COMDAT (bfd * abfd,
 	  /* PR 17512 file: 078-11867-0.004  */
 	  if (symname == NULL)
 	    {
-	      _bfd_error_handler (_("%B: unable to load COMDAT section name"),
+	      _bfd_error_handler (_("%pB: unable to load COMDAT section name"),
 				  abfd);
 	      break;
 	    }
@@ -1000,7 +1000,7 @@ handle_COMDAT (bfd * abfd,
 		  {
 		    /* Malformed input files can trigger this test.
 		       cf PR 21781.  */
-		    _bfd_error_handler (_("%B: error: unexpected symbol '%s' in COMDAT section"),
+		    _bfd_error_handler (_("%pB: error: unexpected symbol '%s' in COMDAT section"),
 					abfd, symname);
 		    goto breakloop;
 		  }
@@ -1012,7 +1012,7 @@ handle_COMDAT (bfd * abfd,
 
 		if (isym.n_sclass == C_STAT && strcmp (name, symname) != 0)
 		  /* xgettext:c-format */
-		  _bfd_error_handler (_("%B: warning: COMDAT symbol '%s'"
+		  _bfd_error_handler (_("%pB: warning: COMDAT symbol '%s'"
 					" does not match section name '%s'"),
 				      abfd, symname, name);
 
@@ -1022,7 +1022,7 @@ handle_COMDAT (bfd * abfd,
 		if (esym + bfd_coff_symesz (abfd) >= esymend)
 		  {
 		    /* xgettext:c-format */
-		    _bfd_error_handler (_("%B: warning: No symbol for"
+		    _bfd_error_handler (_("%pB: warning: No symbol for"
 					  " section '%s' found"),
 					abfd, symname);
 		    break;
@@ -1248,7 +1248,7 @@ styp_to_sec_flags (bfd *abfd,
 	     variable as this will allow some .sys files generate by
 	     other toolchains to be processed.  See bugzilla issue 196.  */
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: Warning: Ignoring section flag"
+	  _bfd_error_handler (_("%pB: Warning: Ignoring section flag"
 				" IMAGE_SCN_MEM_NOT_PAGED in section %s"),
 			      abfd, name);
 	  break;
@@ -1317,7 +1317,7 @@ styp_to_sec_flags (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B (%s): Section flag %s (%#lx) ignored"),
+	    (_("%pB (%s): Section flag %s (%#lx) ignored"),
 	     abfd, name, unhandled, flag);
 	  result = FALSE;
 	}
@@ -1947,7 +1947,7 @@ coff_set_alignment_hook (bfd * abfd ATTRIBUTE_UNUSED,
     }
   else if (hdr->s_nreloc == 0xffff)
     _bfd_error_handler
-      (_("%B: warning: claims to have 0xffff relocs, without overflow"),
+      (_("%pB: warning: claims to have 0xffff relocs, without overflow"),
        abfd);
 }
 #undef ALIGN_SET
@@ -2781,7 +2781,7 @@ coff_write_relocs (bfd * abfd, int first_undef)
 		      {
 			bfd_set_error (bfd_error_bad_value);
 			/* xgettext:c-format */
-			_bfd_error_handler (_("%B: reloc against a non-existent"
+			_bfd_error_handler (_("%pB: reloc against a non-existent"
 					      " symbol index: %ld"),
 					    abfd, n.r_symndx);
 			return FALSE;
@@ -3184,7 +3184,7 @@ coff_compute_section_file_positions (bfd * abfd)
 	  bfd_set_error (bfd_error_file_too_big);
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: page size is too large (0x%x)"), abfd, page_size);
+	    (_("%pB: page size is too large (0x%x)"), abfd, page_size);
 	  return FALSE;
 	}
     }
@@ -3344,7 +3344,7 @@ coff_compute_section_file_positions (bfd * abfd)
       bfd_set_error (bfd_error_file_too_big);
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: too many sections (%d)"), abfd, target_index);
+	(_("%pB: too many sections (%d)"), abfd, target_index);
       return FALSE;
     }
 
@@ -3765,7 +3765,7 @@ coff_write_object_contents (bfd * abfd)
 		  bfd_set_error (bfd_error_file_too_big);
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: section %A: string table overflow at offset %ld"),
+		    (_("%pB: section %pA: string table overflow at offset %ld"),
 		    abfd, current, (unsigned long) string_size);
 		  return FALSE;
 		}
@@ -3870,7 +3870,7 @@ coff_write_object_contents (bfd * abfd)
 
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B:%s section %s: alignment 2**%u not representable"),
+	    (_("%pB:%s section %s: alignment 2**%u not representable"),
 	    abfd, warn ? " warning:" : "", current->name,
 	    current->alignment_power);
 	  if (!warn)
@@ -4589,7 +4589,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
   if (asect->lineno_count > asect->size)
     {
       _bfd_error_handler
-	(_("%B: warning: line number count (%#lx) exceeds section size (%#lx)"),
+	(_("%pB: warning: line number count (%#lx) exceeds section size (%#lx)"),
 	 abfd, (unsigned long) asect->lineno_count, (unsigned long) asect->size);
       return FALSE;
     }
@@ -4604,7 +4604,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
   if (native_lineno == NULL)
     {
       _bfd_error_handler
-	(_("%B: warning: line number table read failed"), abfd);
+	(_("%pB: warning: line number table read failed"), abfd);
       bfd_release (abfd, lineno_cache);
       return FALSE;
     }
@@ -4638,7 +4638,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: warning: illegal symbol index 0x%lx in line number entry %d"),
+		(_("%pB: warning: illegal symbol index 0x%lx in line number entry %d"),
 		 abfd, symndx, counter);
 	      cache_ptr->line_number = -1;
 	      ret = FALSE;
@@ -4652,7 +4652,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: warning: illegal symbol index 0x%lx in line number entry %d"),
+		(_("%pB: warning: illegal symbol index 0x%lx in line number entry %d"),
 		 abfd, symndx, counter);
 	      cache_ptr->line_number = -1;
 	      ret = FALSE;
@@ -4666,7 +4666,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: warning: illegal symbol in line number entry %d"),
+		(_("%pB: warning: illegal symbol in line number entry %d"),
 		 abfd, counter);
 	      cache_ptr->line_number = -1;
 	      ret = FALSE;
@@ -4679,7 +4679,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 	  if (sym->lineno != NULL)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: warning: duplicate line number information for `%s'"),
+	      (_("%pB: warning: duplicate line number information for `%s'"),
 	       abfd, bfd_asymbol_name (&sym->symbol));
 
 	  sym->lineno = cache_ptr;
@@ -5100,7 +5100,7 @@ coff_slurp_symbol_table (bfd * abfd)
 	    default:
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: Unrecognized storage class %d for %s symbol `%s'"),
+		(_("%pB: Unrecognized storage class %d for %s symbol `%s'"),
 		 abfd, src->u.syment.n_sclass,
 		 dst->symbol.section->name, dst->symbol.name);
 	      ret = FALSE;
@@ -5233,7 +5233,7 @@ coff_classify_symbol (bfd *abfd,
 
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("warning: %B: local symbol `%s' has no section"),
+	(_("warning: %pB: local symbol `%s' has no section"),
 	 abfd, _bfd_coff_internal_syment_name (abfd, syment, buf));
     }
 
@@ -5340,7 +5340,7 @@ coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: warning: illegal symbol index %ld in relocs"),
+		(_("%pB: warning: illegal symbol index %ld in relocs"),
 		 abfd, dst.r_symndx);
 	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	      ptr = NULL;
@@ -5380,7 +5380,7 @@ coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: illegal relocation type %d at address %#Lx"),
+	    (_("%pB: illegal relocation type %d at address %#Lx"),
 	     abfd, dst.r_type, dst.r_vaddr);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/coffgen.c b/sdcc/support/sdbinutils/bfd/coffgen.c
index b2410873d..33aff5c2e 100644
--- a/sdcc/support/sdbinutils/bfd/coffgen.c
+++ b/sdcc/support/sdbinutils/bfd/coffgen.c
@@ -175,7 +175,7 @@ make_a_section_from_file (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: unable to initialize compress status for section %s"),
+		(_("%pB: unable to initialize compress status for section %s"),
 		 abfd, name);
 	      return FALSE;
 	    }
@@ -199,7 +199,7 @@ make_a_section_from_file (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: unable to initialize decompress status for section %s"),
+		(_("%pB: unable to initialize decompress status for section %s"),
 		 abfd, name);
 	      return FALSE;
 	    }
@@ -1646,7 +1646,7 @@ _bfd_coff_get_external_symbols (bfd *abfd)
 	  && size > bfd_get_file_size (abfd)))
 
     {
-      _bfd_error_handler (_("%B: corrupt symbol count: %#Lx"),
+      _bfd_error_handler (_("%pB: corrupt symbol count: %#Lx"),
 			  abfd, obj_raw_syment_count (abfd));
       return FALSE;
     }
@@ -1655,7 +1655,7 @@ _bfd_coff_get_external_symbols (bfd *abfd)
   if (syms == NULL)
     {
       /* PR 21013: Provide an error message when the alloc fails.  */
-      _bfd_error_handler (_("%B: not enough memory to allocate space for %#Lx symbols of size %#Lx"),
+      _bfd_error_handler (_("%pB: not enough memory to allocate space for %#Lx symbols of size %#Lx"),
 			  abfd, obj_raw_syment_count (abfd), symesz);
       return FALSE;
     }
@@ -1722,7 +1722,7 @@ _bfd_coff_read_string_table (bfd *abfd)
     {
       _bfd_error_handler
 	/* xgettext: c-format */
-	(_("%B: bad string table size %Lu"), abfd, strsize);
+	(_("%pB: bad string table size %Lu"), abfd, strsize);
       bfd_set_error (bfd_error_bad_value);
       return NULL;
     }
@@ -3021,7 +3021,7 @@ coff_gc_sweep (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
 
 	  if (info->print_gc_sections && o->size != 0)
 	    /* xgettext: c-format */
-	    _bfd_error_handler (_("Removing unused section '%A' in file '%B'"),
+	    _bfd_error_handler (_("Removing unused section '%pA' in file '%pB'"),
 				o, sub);
 
 #if 0
diff --git a/sdcc/support/sdbinutils/bfd/cofflink.c b/sdcc/support/sdbinutils/bfd/cofflink.c
index beff5cd3c..2b2a8d6f3 100644
--- a/sdcc/support/sdbinutils/bfd/cofflink.c
+++ b/sdcc/support/sdbinutils/bfd/cofflink.c
@@ -452,7 +452,7 @@ coff_link_add_symbols (bfd *abfd,
 			_bfd_error_handler
 			  /* xgettext: c-format */
 			  (_("Warning: type of symbol `%s' changed"
-			     " from %d to %d in %B"),
+			     " from %d to %d in %pB"),
 			   name, (*sym_hash)->type, sym.n_type, abfd);
 
 		      /* We don't want to change from a meaningful
@@ -2370,7 +2370,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("%B: relocs in section `%A', but it has no contents"),
+		(_("%pB: relocs in section `%pA', but it has no contents"),
 		 input_bfd, o);
 	      bfd_set_error (bfd_error_no_contents);
 	      return FALSE;
@@ -2433,8 +2433,8 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	      if (ps->flags & SEC_EXCLUDE)
 		(*flaginfo->info->callbacks->einfo)
 		  /* xgettext: c-format */
-		  (_("%X`%s' referenced in section `%A' of %B: "
-		     "defined in discarded section `%A' of %B\n"),
+		  (_("%X`%s' referenced in section `%pA' of %pB: "
+		     "defined in discarded section `%pA' of %pB\n"),
 		   h->root.root.string, o, input_bfd, ps, ps->owner);
 	    }
 
@@ -2731,7 +2731,7 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)
 		      || bfd_link_relocatable (flaginfo->info)))
 		_bfd_error_handler
 		  /* xgettext: c-format */
-		  (_("%B: %A: reloc overflow: %#x > 0xffff"),
+		  (_("%pB: %pA: reloc overflow: %#x > 0xffff"),
 		   output_bfd, sec, sec->reloc_count);
 
 	      if (sec->lineno_count > 0xffff
@@ -2739,7 +2739,7 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)
 		      || bfd_link_relocatable (flaginfo->info)))
 		_bfd_error_handler
 		  /* xgettext: c-format */
-		  (_("%B: warning: %A: line number overflow: %#x > 0xffff"),
+		  (_("%pB: warning: %pA: line number overflow: %#x > 0xffff"),
 		   output_bfd, sec, sec->lineno_count);
 
 	      auxp->x_scn.x_nreloc = sec->reloc_count;
@@ -2962,7 +2962,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: illegal symbol index %ld in relocs"), input_bfd, symndx);
+	    (_("%pB: illegal symbol index %ld in relocs"), input_bfd, symndx);
 	  return FALSE;
 	}
       else
@@ -3124,7 +3124,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,
 	case bfd_reloc_outofrange:
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("%B: bad reloc address %#Lx in section `%A'"),
+	    (_("%pB: bad reloc address %#Lx in section `%pA'"),
 	     input_bfd, rel->r_vaddr, input_section);
 	  return FALSE;
 	case bfd_reloc_overflow:
diff --git a/sdcc/support/sdbinutils/bfd/coffswap.h b/sdcc/support/sdbinutils/bfd/coffswap.h
index 8375af5c4..7b000e006 100644
--- a/sdcc/support/sdbinutils/bfd/coffswap.h
+++ b/sdcc/support/sdbinutils/bfd/coffswap.h
@@ -808,7 +808,7 @@ coff_swap_scnhdr_out (bfd * abfd, void * in, void * out)
       buf[sizeof (scnhdr_int->s_name)] = '\0';
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: warning: %s: line number overflow: 0x%lx > 0xffff"),
+	(_("%pB: warning: %s: line number overflow: 0x%lx > 0xffff"),
 	 abfd, buf, scnhdr_int->s_nlnno);
       PUT_SCNHDR_NLNNO (abfd, 0xffff, scnhdr_ext->s_nlnno);
     }
@@ -822,7 +822,7 @@ coff_swap_scnhdr_out (bfd * abfd, void * in, void * out)
       memcpy (buf, scnhdr_int->s_name, sizeof (scnhdr_int->s_name));
       buf[sizeof (scnhdr_int->s_name)] = '\0';
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: %s: reloc overflow: 0x%lx > 0xffff"),
+      _bfd_error_handler (_("%pB: %s: reloc overflow: 0x%lx > 0xffff"),
 			  abfd, buf, scnhdr_int->s_nreloc);
       bfd_set_error (bfd_error_file_truncated);
       PUT_SCNHDR_NRELOC (abfd, 0xffff, scnhdr_ext->s_nreloc);
diff --git a/sdcc/support/sdbinutils/bfd/compress.c b/sdcc/support/sdbinutils/bfd/compress.c
index 1a531ead0..6a3aabb6b 100644
--- a/sdcc/support/sdbinutils/bfd/compress.c
+++ b/sdcc/support/sdbinutils/bfd/compress.c
@@ -252,7 +252,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
 	      if (bfd_get_error () == bfd_error_no_memory)
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("error: %B(%A) is too large (%#Lx bytes)"),
+		  (_("error: %pB(%pA) is too large (%#Lx bytes)"),
 		  abfd, sec, sz);
 	      return FALSE;
 	    }
diff --git a/sdcc/support/sdbinutils/bfd/cpu-arm.c b/sdcc/support/sdbinutils/bfd/cpu-arm.c
index 151f27367..c6682d459 100644
--- a/sdcc/support/sdbinutils/bfd/cpu-arm.c
+++ b/sdcc/support/sdbinutils/bfd/cpu-arm.c
@@ -190,7 +190,7 @@ bfd_arm_merge_machines (bfd *ibfd, bfd *obfd)
     {
       /* xgettext: c-format */
       _bfd_error_handler (_("\
-error: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
+error: %pB is compiled for the EP9312, whereas %pB is compiled for XScale"),
 			  ibfd, obfd);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
@@ -202,7 +202,7 @@ error: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
     {
       /* xgettext: c-format */
       _bfd_error_handler (_("\
-error: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
+error: %pB is compiled for the EP9312, whereas %pB is compiled for XScale"),
 			  obfd, ibfd);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
@@ -335,7 +335,7 @@ bfd_arm_update_notes (bfd *abfd, const char *note_section)
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
-	    (_("warning: unable to update contents of %s section in %B"),
+	    (_("warning: unable to update contents of %s section in %pB"),
 	     note_section, abfd);
 	  goto FAIL;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/ecoff.c b/sdcc/support/sdbinutils/bfd/ecoff.c
index e9d1eaeb8..2380c4736 100644
--- a/sdcc/support/sdbinutils/bfd/ecoff.c
+++ b/sdcc/support/sdbinutils/bfd/ecoff.c
@@ -961,7 +961,7 @@ _bfd_ecoff_slurp_symbol_table (bfd *abfd)
       bfd_get_symcount (abfd) = internal_ptr - internal;
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: warning: isymMax (%ld) is greater than ifdMax (%ld)"),
+	(_("%pB: warning: isymMax (%ld) is greater than ifdMax (%ld)"),
 	 abfd, ecoff_data (abfd)->debug_info.symbolic_header.isymMax,
 	 ecoff_data (abfd)->debug_info.symbolic_header.ifdMax);
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf-attrs.c b/sdcc/support/sdbinutils/bfd/elf-attrs.c
index 1783f636b..330c621db 100644
--- a/sdcc/support/sdbinutils/bfd/elf-attrs.c
+++ b/sdcc/support/sdbinutils/bfd/elf-attrs.c
@@ -472,7 +472,7 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
 	  len -= section_len;
 	  if (section_len <= 4)
 	    {
-	      _bfd_error_handler (_("%B: error: attribute section length too small: %ld"),
+	      _bfd_error_handler (_("%pB: error: attribute section length too small: %ld"),
 				  abfd, section_len);
 	      break;
 	    }
@@ -600,7 +600,7 @@ _bfd_elf_merge_object_attributes (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-		(_("error: %B: Object has vendor-specific contents that "
+		(_("error: %pB: Object has vendor-specific contents that "
 		   "must be processed by the '%s' toolchain"),
 		 ibfd, in_attr->s);
 	  return FALSE;
@@ -610,7 +610,7 @@ _bfd_elf_merge_object_attributes (bfd *ibfd, struct bfd_link_info *info)
 	  || (in_attr->i != 0 && strcmp (in_attr->s, out_attr->s) != 0))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("error: %B: Object tag '%d, %s' is "
+	  _bfd_error_handler (_("error: %pB: Object tag '%d, %s' is "
 				"incompatible with tag '%d, %s'"),
 			      ibfd,
 			      in_attr->i, in_attr->s ? in_attr->s : "",
diff --git a/sdcc/support/sdbinutils/bfd/elf-eh-frame.c b/sdcc/support/sdbinutils/bfd/elf-eh-frame.c
index 95697c4c8..d61c915dd 100644
--- a/sdcc/support/sdbinutils/bfd/elf-eh-frame.c
+++ b/sdcc/support/sdbinutils/bfd/elf-eh-frame.c
@@ -939,7 +939,7 @@ _bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
 	    {
 	      (*info->callbacks->minfo)
 		/* xgettext:c-format */
-		(_("discarding zero address range FDE in %B(%A).\n"),
+		(_("discarding zero address range FDE in %pB(%pA).\n"),
 		 abfd, sec);
 	      this_inf->u.fde.cie_inf = NULL;
 	    }
@@ -1044,7 +1044,7 @@ _bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
  free_no_table:
   (*info->callbacks->einfo)
     /* xgettext:c-format */
-    (_("%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"),
+    (_("%P: error in %pB(%pA); no .eh_frame_hdr table will be created.\n"),
      abfd, sec);
   hdr_info->u.dwarf.table = FALSE;
   if (sec_info)
@@ -1534,7 +1534,7 @@ _bfd_elf_discard_section_eh_frame
 		  {
 		    (*info->callbacks->einfo)
 		      /* xgettext:c-format */
-		      (_("%P: FDE encoding in %B(%A) prevents .eh_frame_hdr"
+		      (_("%P: FDE encoding in %pB(%pA) prevents .eh_frame_hdr"
 			 " table being created.\n"), abfd, sec);
 		    num_warnings_issued ++;
 		  }
@@ -1863,7 +1863,7 @@ _bfd_elf_write_section_eh_frame_entry (bfd *abfd, struct bfd_link_info *info,
       if (addr <= last_addr)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: %A not in order"), sec->owner, sec);
+	  _bfd_error_handler (_("%pB: %pA not in order"), sec->owner, sec);
 	  return FALSE;
 	}
 
@@ -1877,7 +1877,7 @@ _bfd_elf_write_section_eh_frame_entry (bfd *abfd, struct bfd_link_info *info,
   if (addr & 1)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: %A invalid input section size"),
+      _bfd_error_handler (_("%pB: %pA invalid input section size"),
 			  sec->owner, sec);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -1885,7 +1885,7 @@ _bfd_elf_write_section_eh_frame_entry (bfd *abfd, struct bfd_link_info *info,
   if (last_addr >= addr + sec->rawsize)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: %A points past end of text section"),
+      _bfd_error_handler (_("%pB: %pA points past end of text section"),
 			  sec->owner, sec);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -2304,7 +2304,7 @@ _bfd_elf_fixup_eh_frame_hdr (struct bfd_link_info *info)
       if (sec->output_section != osec)
 	{
 	  _bfd_error_handler
-	    (_("Invalid output section for .eh_frame_entry: %A"),
+	    (_("Invalid output section for .eh_frame_entry: %pA"),
 	     sec->output_section);
 	  return FALSE;
 	}
@@ -2327,7 +2327,7 @@ _bfd_elf_fixup_eh_frame_hdr (struct bfd_link_info *info)
   if (i != 0)
     {
       _bfd_error_handler
-	(_("Invalid contents in %A section"), osec);
+	(_("Invalid contents in %pA section"), osec);
       return FALSE;
     }
 
diff --git a/sdcc/support/sdbinutils/bfd/elf-ifunc.c b/sdcc/support/sdbinutils/bfd/elf-ifunc.c
index 1fab44013..5716ab36f 100644
--- a/sdcc/support/sdbinutils/bfd/elf-ifunc.c
+++ b/sdcc/support/sdbinutils/bfd/elf-ifunc.c
@@ -140,7 +140,7 @@ _bfd_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,
       info->callbacks->einfo
 	/* xgettext:c-format */
 	(_("%F%P: dynamic STT_GNU_IFUNC symbol `%s' with pointer "
-	   "equality in `%B' can not be used when making an "
+	   "equality in `%pB' can not be used when making an "
 	   "executable; recompile with -fPIE and relink with -pie\n"),
 	 h->root.root.string,
 	 h->root.u.def.section->owner);
diff --git a/sdcc/support/sdbinutils/bfd/elf-m10300.c b/sdcc/support/sdbinutils/bfd/elf-m10300.c
index a91257edf..11edf7fc1 100644
--- a/sdcc/support/sdbinutils/bfd/elf-m10300.c
+++ b/sdcc/support/sdbinutils/bfd/elf-m10300.c
@@ -809,7 +809,7 @@ mn10300_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= R_MN10300_MAX)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised MN10300 reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised MN10300 reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_MN10300_NONE;
@@ -1025,7 +1025,7 @@ mn10300_do_tls_transition (bfd *	 input_bfd,
     default:
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: Unsupported transition from %s to %s"),
+	(_("%pB: Unsupported transition from %s to %s"),
 	 input_bfd,
 	 elf_mn10300_howto_table[r_type].name,
 	 elf_mn10300_howto_table[tls_r_type].name);
@@ -1194,7 +1194,7 @@ mn10300_elf_check_relocs (bfd *abfd,
 		  else
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: %s' accessed both as normal and thread local symbol"),
+		      (_("%pB: %s' accessed both as normal and thread local symbol"),
 		       abfd, h ? h->root.root.string : "<local>");
 		}
 
@@ -2090,7 +2090,7 @@ mn10300_elf_relocate_section (bfd *output_bfd,
 
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	      (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	       input_bfd,
 	       input_section,
 	       rel->r_offset,
@@ -2155,7 +2155,7 @@ mn10300_elf_relocate_section (bfd *output_bfd,
 			" library (did you forget -fpic?)");
 	      else if (r_type == R_MN10300_GOT32)
 		/* xgettext:c-format */
-		msg = _("%B: taking the address of protected function"
+		msg = _("%pB: taking the address of protected function"
 			" '%s' cannot be done when making a shared library");
 	      else
 		msg = _("internal error: suspicious relocation type used"
diff --git a/sdcc/support/sdbinutils/bfd/elf-properties.c b/sdcc/support/sdbinutils/bfd/elf-properties.c
index 2549dd0e7..50c0e9d70 100644
--- a/sdcc/support/sdbinutils/bfd/elf-properties.c
+++ b/sdcc/support/sdbinutils/bfd/elf-properties.c
@@ -62,7 +62,7 @@ _bfd_elf_get_property (bfd *abfd, unsigned int type, unsigned int datasz)
   p = (elf_property_list *) bfd_alloc (abfd, sizeof (*p));
   if (p == NULL)
     {
-      _bfd_error_handler (_("%B: out of memory in _bfd_elf_get_property"),
+      _bfd_error_handler (_("%pB: out of memory in _bfd_elf_get_property"),
 			  abfd);
       _exit (EXIT_FAILURE);
     }
@@ -88,7 +88,7 @@ _bfd_elf_parse_gnu_properties (bfd *abfd, Elf_Internal_Note *note)
     {
 bad_size:
       _bfd_error_handler
-	(_("warning: %B: corrupt GNU_PROPERTY_TYPE (%ld) size: %#lx"),
+	(_("warning: %pB: corrupt GNU_PROPERTY_TYPE (%ld) size: %#lx"),
 	 abfd, note->type, note->descsz);
       return FALSE;
     }
@@ -109,7 +109,7 @@ bad_size:
       if (datasz > (size_t) (ptr_end - ptr))
 	{
 	  _bfd_error_handler
-	    (_("warning: %B: corrupt GNU_PROPERTY_TYPE (%ld) type (0x%x) datasz: 0x%x"),
+	    (_("warning: %pB: corrupt GNU_PROPERTY_TYPE (%ld) type (0x%x) datasz: 0x%x"),
 	     abfd, note->type, type, datasz);
 	  /* Clear all properties.  */
 	  elf_properties (abfd) = NULL;
@@ -148,7 +148,7 @@ bad_size:
 	      if (datasz != align_size)
 		{
 		  _bfd_error_handler
-		    (_("warning: %B: corrupt stack size: 0x%x"),
+		    (_("warning: %pB: corrupt stack size: 0x%x"),
 		     abfd, datasz);
 		  /* Clear all properties.  */
 		  elf_properties (abfd) = NULL;
@@ -166,7 +166,7 @@ bad_size:
 	      if (datasz != 0)
 		{
 		  _bfd_error_handler
-		    (_("warning: %B: corrupt no copy on protected size: 0x%x"),
+		    (_("warning: %pB: corrupt no copy on protected size: 0x%x"),
 		     abfd, datasz);
 		  /* Clear all properties.  */
 		  elf_properties (abfd) = NULL;
@@ -183,7 +183,7 @@ bad_size:
 	}
 
       _bfd_error_handler
-	(_("warning: %B: unsupported GNU_PROPERTY_TYPE (%ld) type: 0x%x"),
+	(_("warning: %pB: unsupported GNU_PROPERTY_TYPE (%ld) type: 0x%x"),
 	 abfd, note->type, type);
 
 next:
diff --git a/sdcc/support/sdbinutils/bfd/elf-s390-common.c b/sdcc/support/sdbinutils/bfd/elf-s390-common.c
index 4aa666622..30695beee 100644
--- a/sdcc/support/sdbinutils/bfd/elf-s390-common.c
+++ b/sdcc/support/sdbinutils/bfd/elf-s390-common.c
@@ -286,12 +286,12 @@ elf_s390_merge_obj_attributes (bfd *ibfd, struct bfd_link_info *info)
   if (in_attr->i > 2)
     _bfd_error_handler
       /* xgettext:c-format */
-      (_("Warning: %B uses unknown vector ABI %d"), ibfd,
+      (_("Warning: %pB uses unknown vector ABI %d"), ibfd,
        in_attr->i);
   else if (out_attr->i > 2)
     _bfd_error_handler
       /* xgettext:c-format */
-      (_("Warning: %B uses unknown vector ABI %d"), obfd,
+      (_("Warning: %pB uses unknown vector ABI %d"), obfd,
        out_attr->i);
   else if (in_attr->i != out_attr->i)
     {
@@ -303,7 +303,7 @@ elf_s390_merge_obj_attributes (bfd *ibfd, struct bfd_link_info *info)
 
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("Warning: %B uses vector %s ABI, %B uses %s ABI"),
+	    (_("Warning: %pB uses vector %s ABI, %pB uses %s ABI"),
 	     ibfd, abi_str[in_attr->i], obfd, abi_str[out_attr->i]);
 	}
       if (in_attr->i > out_attr->i)
diff --git a/sdcc/support/sdbinutils/bfd/elf.c b/sdcc/support/sdbinutils/bfd/elf.c
index 90aef0913..417b9a109 100644
--- a/sdcc/support/sdbinutils/bfd/elf.c
+++ b/sdcc/support/sdbinutils/bfd/elf.c
@@ -340,7 +340,7 @@ bfd_elf_string_from_elf_section (bfd *abfd,
 	{
 	  /* PR 17512: file: f057ec89.  */
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: attempt to load strings from"
+	  _bfd_error_handler (_("%pB: attempt to load strings from"
 				" a non-string section (number %d)"),
 			      abfd, shindex);
 	  return NULL;
@@ -355,7 +355,7 @@ bfd_elf_string_from_elf_section (bfd *abfd,
       unsigned int shstrndx = elf_elfheader(abfd)->e_shstrndx;
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: invalid string offset %u >= %Lu for section `%s'"),
+	(_("%pB: invalid string offset %u >= %Lu for section `%s'"),
 	 abfd, strindex, hdr->sh_size,
 	 (shindex == shstrndx && strindex == hdr->sh_name
 	  ? ".shstrtab"
@@ -494,7 +494,7 @@ bfd_elf_get_elf_syms (bfd *ibfd,
       {
 	symoffset += (esym - (bfd_byte *) extsym_buf) / extsym_size;
 	/* xgettext:c-format */
-	_bfd_error_handler (_("%B symbol number %lu references"
+	_bfd_error_handler (_("%pB symbol number %lu references"
 			      " nonexistent SHT_SYMTAB_SHNDX section"),
 			    ibfd, (unsigned long) symoffset);
 	if (alloc_intsym != NULL)
@@ -658,7 +658,7 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: corrupt size field in group section"
+			(_("%pB: corrupt size field in group section"
 			   " header: %#Lx"), abfd, shdr->sh_size);
 		      bfd_set_error (bfd_error_bad_value);
 		      -- num_group;
@@ -673,7 +673,7 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: invalid size field in group section"
+			(_("%pB: invalid size field in group section"
 			   " header: %#Lx"), abfd, shdr->sh_size);
 		      bfd_set_error (bfd_error_bad_value);
 		      -- num_group;
@@ -709,7 +709,7 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 		      if (idx >= shnum)
 			{
 			  _bfd_error_handler
-			    (_("%B: invalid SHT_GROUP entry"), abfd);
+			    (_("%pB: invalid SHT_GROUP entry"), abfd);
 			  idx = 0;
 			}
 		      dest->shdr = elf_elfsections (abfd)[idx];
@@ -728,7 +728,7 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 		  elf_tdata (abfd)->group_sect_ptr = NULL;
 		  elf_tdata (abfd)->num_group = num_group = -1;
 		  _bfd_error_handler
-		    (_("%B: no valid group sections found"), abfd);
+		    (_("%pB: no valid group sections found"), abfd);
 		  bfd_set_error (bfd_error_bad_value);
 		}
 	    }
@@ -757,7 +757,7 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 	    {
 	      /* See PR 21957 for a reproducer.  */
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B: group section '%A' has no contents"),
+	      _bfd_error_handler (_("%pB: group section '%pA' has no contents"),
 				  abfd, shdr->bfd_section);
 	      elf_tdata (abfd)->group_sect_ptr[i] = NULL;
 	      bfd_set_error (bfd_error_bad_value);
@@ -817,7 +817,7 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
   if (elf_group_name (newsect) == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: no group info for section '%A'"),
+      _bfd_error_handler (_("%pB: no group info for section '%pA'"),
 			  abfd, newsect);
       return FALSE;
     }
@@ -848,7 +848,7 @@ _bfd_elf_setup_sections (bfd *abfd)
 	      if (bed->link_order_error_handler)
 		bed->link_order_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: warning: sh_link not set for section `%A'"),
+		  (_("%pB: warning: sh_link not set for section `%pA'"),
 		   abfd, s);
 	    }
 	  else
@@ -868,7 +868,7 @@ _bfd_elf_setup_sections (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: sh_link [%d] in section `%A' is incorrect"),
+		    (_("%pB: sh_link [%d] in section `%pA' is incorrect"),
 		     s->owner, elfsec, s);
 		  result = FALSE;
 		}
@@ -881,7 +881,7 @@ _bfd_elf_setup_sections (bfd *abfd)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: SHT_GROUP section [index %d] has no SHF_GROUP sections"),
+	    (_("%pB: SHT_GROUP section [index %d] has no SHF_GROUP sections"),
 	     abfd, elf_section_data (s)->this_idx);
 	  result = FALSE;
 	}
@@ -902,7 +902,7 @@ _bfd_elf_setup_sections (bfd *abfd)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: section group entry number %u is corrupt"),
+	    (_("%pB: section group entry number %u is corrupt"),
 	     abfd, i);
 	  result = FALSE;
 	  continue;
@@ -925,7 +925,7 @@ _bfd_elf_setup_sections (bfd *abfd)
 	      /* There are some unknown sections in the group.  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: unknown type [%#x] section `%s' in group [%A]"),
+		(_("%pB: unknown type [%#x] section `%s' in group [%pA]"),
 		 abfd,
 		 idx->shdr->sh_type,
 		 bfd_elf_string_from_elf_section (abfd,
@@ -1195,7 +1195,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: unable to initialize compress status for section %s"),
+		(_("%pB: unable to initialize compress status for section %s"),
 		 abfd, name);
 	      return FALSE;
 	    }
@@ -1206,7 +1206,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: unable to initialize decompress status for section %s"),
+		(_("%pB: unable to initialize decompress status for section %s"),
 		 abfd, name);
 	      return FALSE;
 	    }
@@ -1387,7 +1387,7 @@ copy_special_section_fields (const bfd *ibfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: Invalid sh_link field (%d) in section number %d"),
+	    (_("%pB: Invalid sh_link field (%d) in section number %d"),
 	     ibfd, iheader->sh_link, secnum);
 	  return FALSE;
 	}
@@ -1403,7 +1403,7 @@ copy_special_section_fields (const bfd *ibfd,
 	   if we could not find a match ?  */
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: Failed to find link section for section %d"), obfd, secnum);
+	  (_("%pB: Failed to find link section for section %d"), obfd, secnum);
     }
 
   if (iheader->sh_info)
@@ -1430,7 +1430,7 @@ copy_special_section_fields (const bfd *ibfd,
       else
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: Failed to find info section for section %d"), obfd, secnum);
+	  (_("%pB: Failed to find info section for section %d"), obfd, secnum);
     }
 
   return changed;
@@ -2013,7 +2013,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
       if (sections_being_created [shindex])
 	{
 	  _bfd_error_handler
-	    (_("%B: warning: loop in section dependencies detected"), abfd);
+	    (_("%pB: warning: loop in section dependencies detected"), abfd);
 	  return FALSE;
 	}
       sections_being_created [shindex] = TRUE;
@@ -2121,7 +2121,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: warning: multiple symbol tables detected"
+	    (_("%pB: warning: multiple symbol tables detected"
 	       " - ignoring the table in section %u"),
 	     abfd, shindex);
 	  goto success;
@@ -2205,7 +2205,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: warning: multiple dynamic symbol tables detected"
+	    (_("%pB: warning: multiple dynamic symbol tables detected"
 	       " - ignoring the table in section %u"),
 	     abfd, shindex);
 	  goto success;
@@ -2318,7 +2318,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: invalid link %u for reloc section %s (index %u)"),
+	      (_("%pB: invalid link %u for reloc section %s (index %u)"),
 	       abfd, hdr->sh_link, name, shindex);
 	    ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
 						   shindex);
@@ -2477,7 +2477,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	       for applications?  */
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: unknown type [%#x] section `%s'"),
+	      (_("%pB: unknown type [%#x] section `%s'"),
 	       abfd, hdr->sh_type, name);
 	  else
 	    {
@@ -2492,7 +2492,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	/* FIXME: We should handle this section.  */
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: unknown type [%#x] section `%s'"),
+	  (_("%pB: unknown type [%#x] section `%s'"),
 	   abfd, hdr->sh_type, name);
       else if (hdr->sh_type >= SHT_LOOS && hdr->sh_type <= SHT_HIOS)
 	{
@@ -2503,7 +2503,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	       be rejected with an error message.  */
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: unknown type [%#x] section `%s'"),
+	      (_("%pB: unknown type [%#x] section `%s'"),
 	       abfd, hdr->sh_type, name);
 	  else
 	    {
@@ -2516,7 +2516,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	/* FIXME: We should handle this section.  */
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: unknown type [%#x] section `%s'"),
+	  (_("%pB: unknown type [%#x] section `%s'"),
 	   abfd, hdr->sh_type, name);
 
       goto fail;
@@ -3221,7 +3221,7 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: error: Alignment power %d of section `%A' is too big"),
+	(_("%pB: error: Alignment power %d of section `%pA' is too big"),
 	 abfd, asect->alignment_power, asect);
       arg->failed = TRUE;
       return;
@@ -3251,7 +3251,7 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
 	 non-bss input sections to bss output sections, or emit data
 	 to a bss output section via a linker script.  */
       _bfd_error_handler
-	(_("warning: section `%A' type changed to PROGBITS"), asect);
+	(_("warning: section `%pA' type changed to PROGBITS"), asect);
       this_hdr->sh_type = sh_type;
     }
 
@@ -3727,7 +3727,7 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
   if (section_number >= SHN_LORESERVE)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: too many sections: %u"),
+      _bfd_error_handler (_("%pB: too many sections: %u"),
 			  abfd, section_number);
       return FALSE;
     }
@@ -3812,8 +3812,8 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
 		      asection *kept;
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: sh_link of section `%A' points to"
-			   " discarded section `%A' of `%B'"),
+			(_("%pB: sh_link of section `%pA' points to"
+			   " discarded section `%pA' of `%pB'"),
 			 abfd, d->this_hdr.bfd_section,
 			 s, s->owner);
 		      /* Point to the kept section if it has the same
@@ -3837,8 +3837,8 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: sh_link of section `%A' points to"
-			   " removed section `%A' of `%B'"),
+			(_("%pB: sh_link of section `%pA' points to"
+			   " removed section `%pA' of `%pB'"),
 			 abfd, d->this_hdr.bfd_section, s, s->owner);
 		      bfd_set_error (bfd_error_bad_value);
 		      return FALSE;
@@ -3859,7 +3859,7 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
 	      if (bed->link_order_error_handler)
 		bed->link_order_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: warning: sh_link not set for section `%A'"),
+		  (_("%pB: warning: sh_link not set for section `%pA'"),
 		   abfd, sec);
 	    }
 	}
@@ -4389,7 +4389,7 @@ get_program_header_size (bfd *abfd, struct bfd_link_info *info)
 	     {
 	       _bfd_error_handler
 		 /* xgettext:c-format */
-		 (_("%B: GNU_MBIN section `%A' has invalid sh_info field: %d"),
+		 (_("%pB: GNU_MBIN section `%pA' has invalid sh_info field: %d"),
 		     abfd, s, elf_section_data (s)->this_hdr.sh_info);
 	       continue;
 	     }
@@ -4948,18 +4948,18 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
 	      if ((s->flags & SEC_THREAD_LOCAL) == 0)
 		{
 		  _bfd_error_handler
-		    (_("%B: TLS sections are not adjacent:"), abfd);
+		    (_("%pB: TLS sections are not adjacent:"), abfd);
 		  s = first_tls;
 		  i = 0;
 		  while (i < (unsigned int) tls_count)
 		    {
 		      if ((s->flags & SEC_THREAD_LOCAL) != 0)
 			{
-			  _bfd_error_handler (_("	    TLS: %A"), s);
+			  _bfd_error_handler (_("	    TLS: %pA"), s);
 			  i++;
 			}
 		      else
-			_bfd_error_handler (_("	non-TLS: %A"), s);
+			_bfd_error_handler (_("	non-TLS: %pA"), s);
 		      s = s->next;
 		    }
 		  bfd_set_error (bfd_error_bad_value);
@@ -5455,7 +5455,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	       && strcmp (m->sections[0]->name, ".dynamic") != 0)
 	{
 	  _bfd_error_handler
-	    (_("%B: The first section in the PT_DYNAMIC segment"
+	    (_("%pB: The first section in the PT_DYNAMIC segment"
 	       " is not the .dynamic section"),
 	     abfd);
 	  bfd_set_error (bfd_error_bad_value);
@@ -5483,7 +5483,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		      && p->p_paddr < (bfd_vma) off))
 		{
 		  _bfd_error_handler
-		    (_("%B: Not enough room for program headers,"
+		    (_("%pB: Not enough room for program headers,"
 		       " try linking with -N"),
 		     abfd);
 		  bfd_set_error (bfd_error_bad_value);
@@ -5571,7 +5571,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: section %A lma %#Lx adjusted to %#Lx"),
+		    (_("%pB: section %pA lma %#Lx adjusted to %#Lx"),
 		     abfd, sec, s_start, p_end);
 		  adjust = 0;
 		  sec->lma = p_end;
@@ -5708,7 +5708,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: section `%A' can't be allocated in segment %d"),
+		    (_("%pB: section `%pA' can't be allocated in segment %d"),
 		     abfd, sec, j);
 		  print_segment_map (m);
 		}
@@ -5756,7 +5756,7 @@ assign_file_positions_for_non_load_sections (bfd *abfd,
 	  if (hdr->sh_size != 0)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: warning: allocated section `%s' not in segment"),
+	      (_("%pB: warning: allocated section `%s' not in segment"),
 	       abfd,
 	       (hdr->bfd_section == NULL
 		? "*unknown*"
@@ -5954,7 +5954,7 @@ assign_file_positions_for_non_load_sections (bfd *abfd,
 		{
 		  /* PR 17512: file: 2195325e.  */
 		  _bfd_error_handler
-		    (_("%B: error: non-load segment %d includes file header "
+		    (_("%pB: error: non-load segment %d includes file header "
 		       "and/or program header"),
 		     abfd, (int) (p - phdrs));
 		  return FALSE;
@@ -6132,7 +6132,7 @@ assign_file_positions_except_relocs (bfd *abfd,
 	     used and set up the program headers manually.  Either that or
 	     leave room for the headers at the start of the SECTIONS.  */
 	  _bfd_error_handler (_("\
-%B: error: PHDR segment not covered by LOAD segment"),
+%pB: error: PHDR segment not covered by LOAD segment"),
 			      abfd);
 	  return FALSE;
 	}
@@ -6475,7 +6475,7 @@ _bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
 	 which is used in a relocation entry.  */
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: symbol `%s' required but not present"),
+	(_("%pB: symbol `%s' required but not present"),
 	 abfd, bfd_asymbol_name (asym_ptr));
       bfd_set_error (bfd_error_no_symbols);
       return -1;
@@ -6818,7 +6818,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)
 	  if (segment->p_type == PT_LOAD
 	      && (segment->p_filesz > 0 || segment->p_memsz == 0))
 	    /* xgettext:c-format */
-	    _bfd_error_handler (_("%B: warning: Empty loadable segment detected"
+	    _bfd_error_handler (_("%pB: warning: Empty loadable segment detected"
 				  " at vaddr=%#Lx, is this intentional?"),
 				ibfd, segment->p_vaddr);
 
@@ -7432,7 +7432,7 @@ rewrite:
 	    /* PR 17512: file: f17299af.  */
 	    if (segment->p_align > (bfd_vma) 1 << ((sizeof (bfd_vma) * 8) - 2))
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B: warning: segment alignment of %#Lx"
+	      _bfd_error_handler (_("%pB: warning: segment alignment of %#Lx"
 				    " is too large"),
 				  ibfd, segment->p_align);
 	    else
@@ -8246,7 +8246,7 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)
 	{
 error_return_bad_verref:
 	  _bfd_error_handler
-	    (_("%B: .gnu.version_r invalid entry"), abfd);
+	    (_("%pB: .gnu.version_r invalid entry"), abfd);
 	  bfd_set_error (bfd_error_bad_value);
 error_return_verref:
 	  elf_tdata (abfd)->verref = NULL;
@@ -8373,7 +8373,7 @@ error_return_verref:
 	{
 	error_return_bad_verdef:
 	  _bfd_error_handler
-	    (_("%B: .gnu.version_d invalid entry"), abfd);
+	    (_("%pB: .gnu.version_d invalid entry"), abfd);
 	  bfd_set_error (bfd_error_bad_value);
 	error_return_verdef:
 	  elf_tdata (abfd)->verdef = NULL;
@@ -8925,7 +8925,7 @@ _bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
  fail:
   _bfd_error_handler
     /* xgettext:c-format */
-    (_("%B: unsupported relocation type %s"),
+    (_("%pB: unsupported relocation type %s"),
      abfd, areloc->howto->name);
   bfd_set_error (bfd_error_bad_value);
   return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-arc.c b/sdcc/support/sdbinutils/bfd/elf32-arc.c
index 5921cc252..6d7c2339d 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-arc.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-arc.c
@@ -608,7 +608,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      /* It's sometimes ok to mix different configs, so this is only
 		 a warning.  */
 	      _bfd_error_handler
-		(_("Warning: %B: Conflicting platform configuration "
+		(_("Warning: %pB: Conflicting platform configuration "
 		   "%s with %s.\n"), ibfd,
 		 tagval[in_attr[i].i],
 		 tagval[out_attr[i].i]);
@@ -627,7 +627,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      BFD_ASSERT (out_attr[i].i < 5);
 	      /* We cannot mix code for different CPUs.  */
 	      _bfd_error_handler
-		(_("error: %B: unable to merge CPU base attributes "
+		(_("error: %pB: unable to merge CPU base attributes "
 		   "%s with %s.\n"),
 		 obfd,
 		 tagval[in_attr[i].i],
@@ -664,7 +664,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 		    && (!(cpu_out & bfd_feature_list[j].cpus)))
 		  {
 		    _bfd_error_handler
-		      (_("error: %B: unable to merge ISA extension attributes "
+		      (_("error: %pB: unable to merge ISA extension attributes "
 			 "%s.\n"),
 		       obfd, bfd_feature_list[j].name);
 		    result = FALSE;
@@ -688,7 +688,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 			  p2 = (char *) bfd_feature_list[k].name;
 		      }
 		    _bfd_error_handler
-		      (_("error: %B: conflicting ISA extension attributes "
+		      (_("error: %pB: conflicting ISA extension attributes "
 			 "%s with %s.\n"),
 		       obfd, p1, p2);
 		    result = FALSE;
@@ -723,7 +723,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 	    {
 	      /* We cannot mix code with rf16 and without.  */
 	      _bfd_error_handler
-		(_("error: %B: cannot mix rf16 with full register set %B.\n"),
+		(_("error: %pB: cannot mix rf16 with full register set %pB.\n"),
 		 obfd, ibfd);
 	      result = FALSE;
 	    }
@@ -749,7 +749,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 		&& out_attr[i].i != in_attr[i].i)
 	      {
 		_bfd_error_handler
-		  (_("error: %B: conflicting attributes %s: %s with %s.\n"),
+		  (_("error: %pB: conflicting attributes %s: %s with %s.\n"),
 		   obfd, tagname,
 		   tagval[in_attr[i].i],
 		   tagval[out_attr[i].i]);
@@ -774,7 +774,7 @@ arc_elf_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      && out_attr[i].i != in_attr[i].i)
 	    {
 	      _bfd_error_handler
-		(_("error: %B: conflicting attributes %s.\n"),
+		(_("error: %pB: conflicting attributes %s.\n"),
 		 obfd, tagname);
 	      result = FALSE;
 	    }
@@ -874,8 +874,8 @@ arc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       if (mach_ibfd != mach_obfd)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("ERROR: Attempting to link %B "
-				"with a binary %B of different architecture"),
+	  _bfd_error_handler (_("ERROR: Attempting to link %pB "
+				"with a binary %pB of different architecture"),
 			      ibfd, obfd);
 	  return FALSE;
 	}
@@ -888,7 +888,7 @@ arc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  /* Warn if different flags.  */
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: uses different e_flags (%#x) fields than "
+	    (_("%pB: uses different e_flags (%#x) fields than "
 	       "previous modules (%#x)"),
 	     ibfd, in_flags, out_flags);
 	  if (in_flags && out_flags)
@@ -1116,7 +1116,7 @@ arc_special_overflow_checks (const struct arc_relocation_data reloc_data,
 	  if (reloc_data.reloc_addend == 0)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): CMEM relocation to `%s' is invalid, "
+	      (_("%pB(%pA+%#Lx): CMEM relocation to `%s' is invalid, "
 		 "16 MSB should be %#x (value is %#Lx)"),
 	       reloc_data.input_section->owner,
 	       reloc_data.input_section,
@@ -1127,7 +1127,7 @@ arc_special_overflow_checks (const struct arc_relocation_data reloc_data,
 	  else
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): CMEM relocation to `%s+%#Lx' is invalid, "
+	      (_("%pB(%pA+%#Lx): CMEM relocation to `%s+%#Lx' is invalid, "
 		 "16 MSB should be %#x (value is %#Lx)"),
 	       reloc_data.input_section->owner,
 	       reloc_data.input_section,
@@ -1857,27 +1857,27 @@ elf_arc_relocate_section (bfd *			  output_bfd,
 
 	case bfd_reloc_other:
 	  /* xgettext:c-format */
-	  msg = _("%B(%A): warning: unaligned access to symbol '%s' in the small data area");
+	  msg = _("%pB(%pA): warning: unaligned access to symbol '%s' in the small data area");
 	  break;
 
 	case bfd_reloc_outofrange:
 	  /* xgettext:c-format */
-	  msg = _("%B(%A): internal error: out of range error");
+	  msg = _("%pB(%pA): internal error: out of range error");
 	  break;
 
 	case bfd_reloc_notsupported:
 	  /* xgettext:c-format */
-	  msg = _("%B(%A): internal error: unsupported relocation error");
+	  msg = _("%pB(%pA): internal error: unsupported relocation error");
 	  break;
 
 	case bfd_reloc_dangerous:
 	  /* xgettext:c-format */
-	  msg = _("%B(%A): internal error: dangerous relocation");
+	  msg = _("%pB(%pA): internal error: dangerous relocation");
 	  break;
 
 	default:
 	  /* xgettext:c-format */
-	  msg = _("%B(%A): internal error: unknown error");
+	  msg = _("%pB(%pA): internal error: unknown error");
 	  break;
 	}
 
@@ -1966,7 +1966,7 @@ elf_arc_check_relocs (bfd *			 abfd,
 		_bfd_error_handler
 		  /* xgettext:c-format */
 		  (_("\
-%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
+%pB: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
 		    abfd,
 		    arc_elf_howto (r_type)->name,
 		    name);
@@ -2857,7 +2857,7 @@ elf32_arc_obj_attrs_handle_unknown (bfd *abfd, int tag)
   if ((tag & 127) < (Tag_ARC_ISA_mpy_option + 1))
     {
       _bfd_error_handler
-	(_("%B: Unknown mandatory ARC object attribute %d."),
+	(_("%pB: Unknown mandatory ARC object attribute %d."),
 	 abfd, tag);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -2865,7 +2865,7 @@ elf32_arc_obj_attrs_handle_unknown (bfd *abfd, int tag)
   else
     {
       _bfd_error_handler
-	(_("Warning: %B: Unknown ARC object attribute %d."),
+	(_("Warning: %pB: Unknown ARC object attribute %d."),
 	 abfd, tag);
       return TRUE;
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-arm.c b/sdcc/support/sdbinutils/bfd/elf32-arm.c
index 0b250cea2..badf82e7a 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-arm.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-arm.c
@@ -4019,7 +4019,7 @@ arm_type_of_stub (struct bfd_link_info *info,
 		{
 		  if (input_sec->flags & SEC_ELF_PURECODE)
 		    _bfd_error_handler
-		      (_("%B(%A): warning: long branch veneers used in"
+		      (_("%pB(%pA): warning: long branch veneers used in"
 			 " section with SHF_ARM_PURECODE section"
 			 " attribute is only supported for M-profile"
 			 " targets that implement the movw instruction."),
@@ -4053,7 +4053,7 @@ arm_type_of_stub (struct bfd_link_info *info,
 		    {
 		      if (input_sec->flags & SEC_ELF_PURECODE)
 			_bfd_error_handler
-			  (_("%B(%A): warning: long branch veneers used in"
+			  (_("%pB(%pA): warning: long branch veneers used in"
 			     " section with SHF_ARM_PURECODE section"
 			     " attribute is only supported for M-profile"
 			     " targets that implement the movw instruction."),
@@ -4072,7 +4072,7 @@ arm_type_of_stub (struct bfd_link_info *info,
 	    {
 	      if (input_sec->flags & SEC_ELF_PURECODE)
 		_bfd_error_handler
-		  (_("%B(%A): warning: long branch veneers used in"
+		  (_("%pB(%pA): warning: long branch veneers used in"
 		     " section with SHF_ARM_PURECODE section"
 		     " attribute is only supported" " for M-profile"
 		     " targets that implement the movw instruction."),
@@ -4084,8 +4084,8 @@ arm_type_of_stub (struct bfd_link_info *info,
 		  && !INTERWORK_FLAG (sym_sec->owner))
 		{
 		  _bfd_error_handler
-		    (_("%B(%s): warning: interworking not enabled.\n"
-		       "  first occurrence: %B: Thumb call to ARM"),
+		    (_("%pB(%s): warning: interworking not enabled.\n"
+		       "  first occurrence: %pB: Thumb call to ARM"),
 		     sym_sec->owner, name, input_bfd);
 		}
 
@@ -4124,7 +4124,7 @@ arm_type_of_stub (struct bfd_link_info *info,
     {
       if (input_sec->flags & SEC_ELF_PURECODE)
 	_bfd_error_handler
-	  (_("%B(%A): warning: long branch veneers used in"
+	  (_("%pB(%pA): warning: long branch veneers used in"
 	     " section with SHF_ARM_PURECODE section"
 	     " attribute is only supported for M-profile"
 	     " targets that implement the movw instruction."),
@@ -4138,8 +4138,8 @@ arm_type_of_stub (struct bfd_link_info *info,
 	      && !INTERWORK_FLAG (sym_sec->owner))
 	    {
 	      _bfd_error_handler
-		(_("%B(%s): warning: interworking not enabled.\n"
-		   "  first occurrence: %B: ARM call to Thumb"),
+		(_("%pB(%s): warning: interworking not enabled.\n"
+		   "  first occurrence: %pB: ARM call to Thumb"),
 		 sym_sec->owner, name, input_bfd);
 	    }
 
@@ -4487,7 +4487,7 @@ elf32_arm_add_stub (const char *stub_name, asection *section,
     {
       if (section == NULL)
 	section = stub_sec;
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 			  section->owner, stub_name);
       return NULL;
     }
@@ -5672,7 +5672,7 @@ cmse_scan (bfd *input_bfd, struct elf32_arm_link_hash_table *htab,
 
       if (!is_v8m)
 	{
-	  _bfd_error_handler (_("%B: Special symbol `%s' only allowed for "
+	  _bfd_error_handler (_("%pB: Special symbol `%s' only allowed for "
 				"ARMv8-M architecture or later."),
 			      input_bfd, sym_name);
 	  is_v8m = TRUE; /* Avoid multiple warning.  */
@@ -5681,7 +5681,7 @@ cmse_scan (bfd *input_bfd, struct elf32_arm_link_hash_table *htab,
 
       if (cmse_invalid)
 	{
-	  _bfd_error_handler (_("%B: invalid special symbol `%s'."),
+	  _bfd_error_handler (_("%pB: invalid special symbol `%s'."),
 			      input_bfd, sym_name);
 	  _bfd_error_handler (_("It must be a global or weak function "
 				"symbol."));
@@ -5721,13 +5721,13 @@ cmse_scan (bfd *input_bfd, struct elf32_arm_link_hash_table *htab,
 	  if (hash || j < ext_start)
 	    {
 	      _bfd_error_handler
-		(_("%B: invalid standard symbol `%s'."), input_bfd, sym_name);
+		(_("%pB: invalid standard symbol `%s'."), input_bfd, sym_name);
 	      _bfd_error_handler
 		(_("It must be a global or weak function symbol."));
 	    }
 	  else
 	    _bfd_error_handler
-	      (_("%B: absent standard symbol `%s'."), input_bfd, sym_name);
+	      (_("%pB: absent standard symbol `%s'."), input_bfd, sym_name);
 	  ret = FALSE;
 	  if (!hash)
 	    continue;
@@ -5739,7 +5739,7 @@ cmse_scan (bfd *input_bfd, struct elf32_arm_link_hash_table *htab,
       if (cmse_hash->root.root.u.def.section != section)
 	{
 	  _bfd_error_handler
-	    (_("%B: `%s' and its special symbol are in different sections."),
+	    (_("%pB: `%s' and its special symbol are in different sections."),
 	     input_bfd, sym_name);
 	  ret = FALSE;
 	}
@@ -5751,14 +5751,14 @@ cmse_scan (bfd *input_bfd, struct elf32_arm_link_hash_table *htab,
       if (section->output_section == NULL)
 	{
 	  _bfd_error_handler
-	    (_("%B: entry function `%s' not output."), input_bfd, sym_name);
+	    (_("%pB: entry function `%s' not output."), input_bfd, sym_name);
 	  continue;
 	}
 
       if (hash->root.size == 0)
 	{
 	  _bfd_error_handler
-	    (_("%B: entry function `%s' is empty."), input_bfd, sym_name);
+	    (_("%pB: entry function `%s' is empty."), input_bfd, sym_name);
 	  ret = FALSE;
 	}
 
@@ -5887,7 +5887,7 @@ set_cmse_veneer_addr_from_implib (struct bfd_link_info *info,
   in_implib_bfd = htab->in_implib_bfd;
   if (!htab->cmse_implib)
     {
-      _bfd_error_handler (_("%B: --in-implib only supported for Secure "
+      _bfd_error_handler (_("%pB: --in-implib only supported for Secure "
 			    "Gateway import libraries."), in_implib_bfd);
       return FALSE;
     }
@@ -5933,7 +5933,7 @@ set_cmse_veneer_addr_from_implib (struct bfd_link_info *info,
 	  || (ARM_GET_SYM_BRANCH_TYPE (intsym->st_target_internal)
 	      != ST_BRANCH_TO_THUMB))
 	{
-	  _bfd_error_handler (_("%B: invalid import library entry: `%s'."),
+	  _bfd_error_handler (_("%pB: invalid import library entry: `%s'."),
 			      in_implib_bfd, sym_name);
 	  _bfd_error_handler (_("Symbol should be absolute, global and "
 				"refer to Thumb functions."));
@@ -5994,7 +5994,7 @@ set_cmse_veneer_addr_from_implib (struct bfd_link_info *info,
 	  if (!!(flags & BSF_GLOBAL)
 	      != (hash->root.root.type == bfd_link_hash_defined))
 	    _bfd_error_handler
-	      (_("%B: visibility of symbol `%s' has changed."), in_implib_bfd,
+	      (_("%pB: visibility of symbol `%s' has changed."), in_implib_bfd,
 	       sym_name);
 
 	  stub_entry->stub_offset = stub_offset;
@@ -6003,7 +6003,7 @@ set_cmse_veneer_addr_from_implib (struct bfd_link_info *info,
       /* Size should match that of a SG veneer.  */
       if (intsym->st_size != cmse_stub_size)
 	{
-	  _bfd_error_handler (_("%B: incorrect size for symbol `%s'."),
+	  _bfd_error_handler (_("%pB: incorrect size for symbol `%s'."),
 			      in_implib_bfd, sym_name);
 	  ret = FALSE;
 	}
@@ -6624,7 +6624,7 @@ elf32_arm_size_stubs (bfd *output_bfd,
 					     TRUE, FALSE);
 	  if (stub_entry == NULL)
 	    {
-	      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+	      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 				  section->owner, stub_name);
 	      return FALSE;
 	    }
@@ -7508,7 +7508,7 @@ bfd_elf32_arm_process_before_allocation (bfd *abfd,
 
   if (globals->byteswap_code && !bfd_big_endian (abfd))
     {
-      _bfd_error_handler (_("%B: BE8 images only valid in big-endian mode."),
+      _bfd_error_handler (_("%pB: BE8 images only valid in big-endian mode."),
 			  abfd);
       return FALSE;
     }
@@ -7739,7 +7739,7 @@ bfd_elf32_arm_set_vfp11_fix (bfd *obfd, struct bfd_link_info *link_info)
 
 	default:
 	  /* Give a warning, but do as the user requests anyway.  */
-	  _bfd_error_handler (_("%B: warning: selected VFP11 erratum "
+	  _bfd_error_handler (_("%pB: warning: selected VFP11 erratum "
 	    "workaround is not necessary for target architecture"), obfd);
 	}
     }
@@ -7766,7 +7766,7 @@ bfd_elf32_arm_set_stm32l4xx_fix (bfd *obfd, struct bfd_link_info *link_info)
       if (globals->stm32l4xx_fix != BFD_ARM_STM32L4XX_FIX_NONE)
 	/* Give a warning, but do as the user requests anyway.  */
 	_bfd_error_handler
-	  (_("%B: warning: selected STM32L4XX erratum "
+	  (_("%pB: warning: selected STM32L4XX erratum "
 	     "workaround is not necessary for target architecture"), obfd);
     }
 }
@@ -8303,7 +8303,7 @@ bfd_elf32_arm_vfp11_fix_veneer_locations (bfd *abfd,
 		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
 
 	      if (myh == NULL)
-		_bfd_error_handler (_("%B: unable to find VFP11 veneer "
+		_bfd_error_handler (_("%pB: unable to find VFP11 veneer "
 				      "`%s'"), abfd, tmp_name);
 
 	      vma = myh->root.u.def.section->output_section->vma
@@ -8323,7 +8323,7 @@ bfd_elf32_arm_vfp11_fix_veneer_locations (bfd *abfd,
 		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
 
 	      if (myh == NULL)
-		_bfd_error_handler (_("%B: unable to find VFP11 veneer "
+		_bfd_error_handler (_("%pB: unable to find VFP11 veneer "
 				      "`%s'"), abfd, tmp_name);
 
 	      vma = myh->root.u.def.section->output_section->vma
@@ -8389,7 +8389,7 @@ bfd_elf32_arm_stm32l4xx_fix_veneer_locations (bfd *abfd,
 		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
 
 	      if (myh == NULL)
-		_bfd_error_handler (_("%B: unable to find STM32L4XX veneer "
+		_bfd_error_handler (_("%pB: unable to find STM32L4XX veneer "
 				      "`%s'"), abfd, tmp_name);
 
 	      vma = myh->root.u.def.section->output_section->vma
@@ -8408,7 +8408,7 @@ bfd_elf32_arm_stm32l4xx_fix_veneer_locations (bfd *abfd,
 		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
 
 	      if (myh == NULL)
-		_bfd_error_handler (_("%B: unable to find STM32L4XX veneer "
+		_bfd_error_handler (_("%pB: unable to find STM32L4XX veneer "
 				      "`%s'"), abfd, tmp_name);
 
 	      vma = myh->root.u.def.section->output_section->vma
@@ -8615,7 +8615,7 @@ bfd_elf32_arm_stm32l4xx_erratum_scan (bfd *abfd,
 			  {
 			    _bfd_error_handler
 			      /* xgettext:c-format */
-			      (_("%B(%A+%#x): error: multiple load detected"
+			      (_("%pB(%pA+%#x): error: multiple load detected"
 				 " in non-last IT block instruction :"
 				 " STM32L4XX veneer cannot be generated.\n"
 				 "Use gcc option -mrestrict-it to generate"
@@ -8803,8 +8803,8 @@ elf32_thumb_to_arm_stub (struct bfd_link_info * info,
 	  && !INTERWORK_FLAG (sym_sec->owner))
 	{
 	  _bfd_error_handler
-	    (_("%B(%s): warning: interworking not enabled.\n"
-	       "  first occurrence: %B: Thumb call to ARM"),
+	    (_("%pB(%s): warning: interworking not enabled.\n"
+	       "  first occurrence: %pB: Thumb call to ARM"),
 	     sym_sec->owner, name, input_bfd);
 
 	  return FALSE;
@@ -8893,8 +8893,8 @@ elf32_arm_create_thumb_stub (struct bfd_link_info * info,
 	  && !INTERWORK_FLAG (sym_sec->owner))
 	{
 	  _bfd_error_handler
-	    (_("%B(%s): warning: interworking not enabled.\n"
-	       "  first occurrence: %B: arm call to thumb"),
+	    (_("%pB(%s): warning: interworking not enabled.\n"
+	       "  first occurrence: %pB: arm call to thumb"),
 	     sym_sec->owner, name, input_bfd);
 	}
 
@@ -9455,7 +9455,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      /* FIXME: We ought to be able to generate thumb-1 PLT
 		 instructions...  */
-	      _bfd_error_handler (_("%B: Warning: thumb-1 mode PLT generation not currently supported"),
+	      _bfd_error_handler (_("%pB: Warning: thumb-1 mode PLT generation not currently supported"),
 				  output_bfd);
 	      return FALSE;
 	    }
@@ -9720,7 +9720,7 @@ elf32_arm_tls_relax (struct elf32_arm_link_hash_table *globals,
 	      | bfd_get_16 (input_bfd, contents + rel->r_offset + 2);
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unexpected Thumb instruction '%#lx' in TLS trampoline"),
+	    (_("%pB(%pA+%#Lx): unexpected Thumb instruction '%#lx' in TLS trampoline"),
 	     input_bfd, input_sec, rel->r_offset, insn);
 	  return bfd_reloc_notsupported;
 	}
@@ -9760,7 +9760,7 @@ elf32_arm_tls_relax (struct elf32_arm_link_hash_table *globals,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unexpected ARM instruction '%#lx' in TLS trampoline"),
+	    (_("%pB(%pA+%#Lx): unexpected ARM instruction '%#lx' in TLS trampoline"),
 	     input_bfd, input_sec, rel->r_offset, insn);
 	  return bfd_reloc_notsupported;
 	}
@@ -10106,7 +10106,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 		v = _("PIE executable");
 
 	      _bfd_error_handler
-		(_("%B: relocation %s against external or undefined symbol `%s'"
+		(_("%pB: relocation %s against external or undefined symbol `%s'"
 		   " can not be used when making a %s; recompile with -fPIC"), input_bfd,
 		 elf32_arm_howto_table_1[r_type].name, h->root.root.string, v);
 	      return bfd_reloc_notsupported;
@@ -10237,7 +10237,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 		 instruction instead ?  */
 	      if (branch_type != ST_BRANCH_TO_THUMB)
 		_bfd_error_handler
-		  (_("\%B: Warning: Arm BLX instruction targets Arm function '%s'."),
+		  (_("\%pB: Warning: Arm BLX instruction targets Arm function '%s'."),
 		   input_bfd,
 		   h ? h->root.root.string : "(local)");
 	    }
@@ -10663,7 +10663,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	       instruction instead ?  */
 	    if (branch_type == ST_BRANCH_TO_THUMB)
 	      _bfd_error_handler
-		(_("%B: Warning: Thumb BLX instruction targets thumb function '%s'."),
+		(_("%pB: Warning: Thumb BLX instruction targets thumb function '%s'."),
 		 input_bfd,
 		 h ? h->root.root.string : "(local)");
 	  }
@@ -11531,7 +11531,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B(%A+%#Lx): unexpected Thumb instruction '%#lx' referenced by TLS_GOTDESC"),
+		      (_("%pB(%pA+%#Lx): unexpected Thumb instruction '%#lx' referenced by TLS_GOTDESC"),
 		       input_bfd, input_section, rel->r_offset, insn);
 		    return bfd_reloc_notsupported;
 		  }
@@ -11554,7 +11554,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 		  default:
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B(%A+%#Lx): unexpected ARM instruction '%#lx' referenced by TLS_GOTDESC"),
+		      (_("%pB(%pA+%#Lx): unexpected ARM instruction '%#lx' referenced by TLS_GOTDESC"),
 		       input_bfd, input_section, rel->r_offset, insn);
 		    return bfd_reloc_notsupported;
 		  }
@@ -11583,7 +11583,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): %s relocation not permitted in shared object"),
+	    (_("%pB(%pA+%#Lx): %s relocation not permitted in shared object"),
 	     input_bfd, input_section, rel->r_offset, howto->name);
 	  return bfd_reloc_notsupported;
 	}
@@ -11796,7 +11796,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	      {
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B(%A+%#Lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
+		  (_("%pB(%pA+%#Lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
 		  input_bfd, input_section, rel->r_offset);
 		return bfd_reloc_overflow;
 	      }
@@ -11836,7 +11836,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
+	      (_("%pB(%pA+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
 	       input_bfd, input_section, rel->r_offset,
 	       signed_value < 0 ? -signed_value : signed_value, howto->name);
 	    return bfd_reloc_overflow;
@@ -11926,7 +11926,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
+	      (_("%pB(%pA+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
 	       input_bfd, input_section, rel->r_offset,
 	       signed_value < 0 ? -signed_value : signed_value, howto->name);
 	    return bfd_reloc_overflow;
@@ -12012,7 +12012,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
+	      (_("%pB(%pA+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
 	       input_bfd, input_section, rel->r_offset,
 	       signed_value < 0 ? -signed_value : signed_value, howto->name);
 	    return bfd_reloc_overflow;
@@ -12100,7 +12100,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
+	      (_("%pB(%pA+%#Lx): Overflow whilst splitting %#Lx for group relocation %s"),
 	       input_bfd, input_section, rel->r_offset,
 	       signed_value < 0 ? -signed_value : signed_value, howto->name);
 	    return bfd_reloc_overflow;
@@ -12366,7 +12366,7 @@ elf32_arm_relocate_section (bfd *		   output_bfd,
 			{
 			  _bfd_error_handler
 			    /* xgettext:c-format */
-			    (_("%B(%A+%#Lx): %s relocation against SEC_MERGE section"),
+			    (_("%pB(%pA+%#Lx): %s relocation against SEC_MERGE section"),
 			     input_bfd, input_section,
 			     rel->r_offset, howto->name);
 			  return FALSE;
@@ -12478,9 +12478,9 @@ elf32_arm_relocate_section (bfd *		   output_bfd,
 	  _bfd_error_handler
 	    ((sym_type == STT_TLS
 	      /* xgettext:c-format */
-	      ? _("%B(%A+%#Lx): %s used with TLS symbol %s")
+	      ? _("%pB(%pA+%#Lx): %s used with TLS symbol %s")
 	      /* xgettext:c-format */
-	      : _("%B(%A+%#Lx): %s used with non-TLS symbol %s")),
+	      : _("%pB(%pA+%#Lx): %s used with non-TLS symbol %s")),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -12533,7 +12533,7 @@ elf32_arm_relocate_section (bfd *		   output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -13018,11 +13018,11 @@ elf32_arm_set_private_flags (bfd *abfd, flagword flags)
 	{
 	  if (flags & EF_ARM_INTERWORK)
 	    _bfd_error_handler
-	      (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
+	      (_("Warning: Not setting interworking flag of %pB since it has already been specified as non-interworking"),
 	       abfd);
 	  else
 	    _bfd_error_handler
-	      (_("Warning: Clearing the interworking flag of %B due to outside request"),
+	      (_("Warning: Clearing the interworking flag of %pB due to outside request"),
 	       abfd);
 	}
     }
@@ -13067,7 +13067,7 @@ elf32_arm_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
 	{
 	  if (out_flags & EF_ARM_INTERWORK)
 	    _bfd_error_handler
-	      (_("Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
+	      (_("Warning: Clearing the interworking flag of %pB because non-interworking code in %pB has been linked with it"),
 	       obfd, ibfd);
 
 	  in_flags &= ~EF_ARM_INTERWORK;
@@ -13154,7 +13154,7 @@ elf32_arm_obj_attrs_handle_unknown (bfd *abfd, int tag)
   if ((tag & 127) < 64)
     {
       _bfd_error_handler
-	(_("%B: Unknown mandatory EABI object attribute %d"),
+	(_("%pB: Unknown mandatory EABI object attribute %d"),
 	 abfd, tag);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -13162,7 +13162,7 @@ elf32_arm_obj_attrs_handle_unknown (bfd *abfd, int tag)
   else
     {
       _bfd_error_handler
-	(_("Warning: %B: Unknown EABI object attribute %d"),
+	(_("Warning: %pB: Unknown EABI object attribute %d"),
 	 abfd, tag);
       return TRUE;
     }
@@ -13429,7 +13429,7 @@ tag_cpu_arch_combine (bfd *ibfd, int oldtag, int *secondary_compat_out,
 
   if (oldtag > MAX_TAG_CPU_ARCH || newtag > MAX_TAG_CPU_ARCH)
     {
-      _bfd_error_handler (_("error: %B: Unknown CPU architecture"), ibfd);
+      _bfd_error_handler (_("error: %pB: Unknown CPU architecture"), ibfd);
       return -1;
     }
 
@@ -13467,7 +13467,7 @@ tag_cpu_arch_combine (bfd *ibfd, int oldtag, int *secondary_compat_out,
 
   if (result == -1)
     {
-      _bfd_error_handler (_("error: %B: Conflicting CPU architectures %d/%d"),
+      _bfd_error_handler (_("error: %pB: Conflicting CPU architectures %d/%d"),
 			  ibfd, oldtag, newtag);
       return -1;
     }
@@ -13564,7 +13564,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 		!= out_attr[Tag_MPextension_use].i)
 	    {
 	      _bfd_error_handler
-		(_("Error: %B has both the current and legacy "
+		(_("Error: %pB has both the current and legacy "
 		   "Tag_MPextension_use attributes"), ibfd);
 	      result = FALSE;
 	    }
@@ -13593,7 +13593,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	       && in_attr[Tag_ABI_VFP_args].i != AEABI_VFP_args_compatible)
 	{
 	  _bfd_error_handler
-	    (_("error: %B uses VFP register arguments, %B does not"),
+	    (_("error: %pB uses VFP register arguments, %pB does not"),
 	     in_attr[Tag_ABI_VFP_args].i ? ibfd : obfd,
 	     in_attr[Tag_ABI_VFP_args].i ? obfd : ibfd);
 	  result = FALSE;
@@ -13722,7 +13722,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 		 binaries in the toolchain have had the attributes set
 		 properly.
 	      _bfd_error_handler
-		(_("error: %B: 8-byte data alignment conflicts with %B"),
+		(_("error: %pB: 8-byte data alignment conflicts with %pB"),
 		 obfd, ibfd);
 	      result = FALSE; */
 	    }
@@ -13751,8 +13751,8 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      else
 		{
 		  _bfd_error_handler
-		    (_("error: %B: unable to merge virtualization attributes "
-		       "with %B"),
+		    (_("error: %pB: unable to merge virtualization attributes "
+		       "with %pB"),
 		     obfd, ibfd);
 		  result = FALSE;
 		}
@@ -13777,7 +13777,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      else
 		{
 		  _bfd_error_handler
-		    (_("error: %B: Conflicting architecture profiles %c/%c"),
+		    (_("error: %pB: Conflicting architecture profiles %c/%c"),
 		     ibfd,
 		     in_attr[i].i ? in_attr[i].i : '0',
 		     out_attr[i].i ? out_attr[i].i : '0');
@@ -13916,7 +13916,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      /* It's sometimes ok to mix different configs, so this is only
 		 a warning.  */
 	      _bfd_error_handler
-		(_("Warning: %B: Conflicting platform configuration"), ibfd);
+		(_("Warning: %pB: Conflicting platform configuration"), ibfd);
 	    }
 	  break;
 	case Tag_ABI_PCS_R9_use:
@@ -13925,7 +13925,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      && in_attr[i].i != AEABI_R9_unused)
 	    {
 	      _bfd_error_handler
-		(_("error: %B: Conflicting use of R9"), ibfd);
+		(_("error: %pB: Conflicting use of R9"), ibfd);
 	      result = FALSE;
 	    }
 	  if (out_attr[i].i == AEABI_R9_unused)
@@ -13937,7 +13937,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      && out_attr[Tag_ABI_PCS_R9_use].i != AEABI_R9_unused)
 	    {
 	      _bfd_error_handler
-		(_("error: %B: SB relative addressing conflicts with use of R9"),
+		(_("error: %pB: SB relative addressing conflicts with use of R9"),
 		 ibfd);
 	      result = FALSE;
 	    }
@@ -13950,7 +13950,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      && !elf_arm_tdata (obfd)->no_wchar_size_warning)
 	    {
 	      _bfd_error_handler
-		(_("warning: %B uses %u-byte wchar_t yet the output is to use %u-byte wchar_t; use of wchar_t values across objects may fail"),
+		(_("warning: %pB uses %u-byte wchar_t yet the output is to use %u-byte wchar_t; use of wchar_t values across objects may fail"),
 		 ibfd, in_attr[i].i, out_attr[i].i);
 	    }
 	  else if (in_attr[i].i && !out_attr[i].i)
@@ -13981,7 +13981,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 		    ? aeabi_enum_names[out_attr[i].i]
 		    : "<unknown>";
 		  _bfd_error_handler
-		    (_("warning: %B uses %s enums yet the output is to use %s enums; use of enum values across objects may fail"),
+		    (_("warning: %pB uses %s enums yet the output is to use %s enums; use of enum values across objects may fail"),
 		     ibfd, in_name, out_name);
 		}
 	    }
@@ -13993,7 +13993,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	  if (in_attr[i].i != out_attr[i].i)
 	    {
 	      _bfd_error_handler
-		(_("error: %B uses iWMMXt register arguments, %B does not"),
+		(_("error: %pB uses iWMMXt register arguments, %pB does not"),
 		 ibfd, obfd);
 	      result = FALSE;
 	    }
@@ -14010,7 +14010,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      if (in_attr[i].i != out_attr[i].i)
 		{
 		  _bfd_error_handler
-		    (_("error: fp16 format mismatch between %B and %B"),
+		    (_("error: fp16 format mismatch between %pB and %pB"),
 		     ibfd, obfd);
 		  result = FALSE;
 		}
@@ -14046,7 +14046,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)
 	      if (in_attr[Tag_MPextension_use].i != in_attr[i].i)
 		{
 		  _bfd_error_handler
-		    (_("%B has both the current and legacy "
+		    (_("%pB has both the current and legacy "
 		       "Tag_MPextension_use attributes"),
 		     ibfd);
 		  result = FALSE;
@@ -14365,7 +14365,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	     object file containing relocations but no symbol table.  */
 	  && (r_symndx > STN_UNDEF || nsyms > 0))
 	{
-	  _bfd_error_handler (_("%B: bad symbol index: %d"), abfd,
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"), abfd,
 			      r_symndx);
 	  return FALSE;
 	}
@@ -14518,7 +14518,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	    if (bfd_link_pic (info))
 	      {
 		_bfd_error_handler
-		  (_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
+		  (_("%pB: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
 		   abfd, elf32_arm_howto_table_1[r_type].name,
 		   (h) ? h->root.root.string : "a local symbol");
 		bfd_set_error (bfd_error_bad_value);
@@ -15633,7 +15633,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -15878,7 +15878,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
       if (!bfd_elf32_arm_process_before_allocation (ibfd, info)
 	  || !bfd_elf32_arm_vfp11_erratum_scan (ibfd, info)
 	  || !bfd_elf32_arm_stm32l4xx_erratum_scan (ibfd, info))
-	_bfd_error_handler (_("Errors encountered processing file %B"), ibfd);
+	_bfd_error_handler (_("Errors encountered processing file %pB"), ibfd);
     }
 
   /* Allocate space for the glue sections now that we've sized them.  */
@@ -17491,7 +17491,7 @@ make_branch_to_a8_stub (struct bfd_hash_entry *gen_entry,
      This check is just to be on the safe side...  */
   if ((veneered_insn_loc & ~0xfff) == (veneer_entry_loc & ~0xfff))
     {
-      _bfd_error_handler (_("%B: error: Cortex-A8 erratum stub is "
+      _bfd_error_handler (_("%pB: error: Cortex-A8 erratum stub is "
 			    "allocated in unsafe location"), abfd);
       return FALSE;
     }
@@ -17518,7 +17518,7 @@ make_branch_to_a8_stub (struct bfd_hash_entry *gen_entry,
 	  {
 	    /* There's not much we can do apart from complain if this
 	       happens.  */
-	    _bfd_error_handler (_("%B: error: Cortex-A8 erratum stub out "
+	    _bfd_error_handler (_("%pB: error: Cortex-A8 erratum stub out "
 				  "of range (input file too large)"), abfd);
 	    return FALSE;
 	  }
@@ -18345,7 +18345,7 @@ elf32_arm_write_section (bfd *output_bfd,
 
 		if ((signed) branch_to_veneer < -(1 << 25)
 		    || (signed) branch_to_veneer >= (1 << 25))
-		  _bfd_error_handler (_("%B: error: VFP11 veneer out of "
+		  _bfd_error_handler (_("%pB: error: VFP11 veneer out of "
 					"range"), output_bfd);
 
 		insn |= (branch_to_veneer >> 2) & 0xffffff;
@@ -18367,7 +18367,7 @@ elf32_arm_write_section (bfd *output_bfd,
 
 		if ((signed) branch_from_veneer < -(1 << 25)
 		    || (signed) branch_from_veneer >= (1 << 25))
-		  _bfd_error_handler (_("%B: error: VFP11 veneer out of "
+		  _bfd_error_handler (_("%pB: error: VFP11 veneer out of "
 					"range"), output_bfd);
 
 		/* Original instruction.  */
@@ -18418,7 +18418,7 @@ elf32_arm_write_section (bfd *output_bfd,
 		      branch_to_veneer - (1 << 24) : 0;
 
 		    _bfd_error_handler
-		      (_("%B(%#Lx): error: Cannot create STM32L4XX veneer. "
+		      (_("%pB(%#Lx): error: Cannot create STM32L4XX veneer. "
 			 "Jump out of range by %Ld bytes. "
 			 "Cannot encode branch instruction. "),
 		       output_bfd,
@@ -18456,7 +18456,7 @@ elf32_arm_write_section (bfd *output_bfd,
 			      STM32L4XX_ERRATUM_LDM_VENEER_SIZE) < -(1 << 24)
 		    || (signed) (veneer_r - veneer) >= (1 << 24))
 		  {
-		    _bfd_error_handler (_("%B: error: Cannot create STM32L4XX "
+		    _bfd_error_handler (_("%pB: error: Cannot create STM32L4XX "
 					  "veneer."), output_bfd);
 		     continue;
 		  }
@@ -19478,7 +19478,7 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       && !(ibfd->flags & DYNAMIC)
       && (in_flags & EF_ARM_BE8))
     {
-      _bfd_error_handler (_("error: %B is already in final BE8 format"),
+      _bfd_error_handler (_("error: %pB is already in final BE8 format"),
 			  ibfd);
       return FALSE;
     }
@@ -19554,7 +19554,7 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 				      EF_ARM_EABI_VERSION (out_flags)))
     {
       _bfd_error_handler
-	(_("error: Source object %B has EABI version %d, but target %B has EABI version %d"),
+	(_("error: Source object %pB has EABI version %d, but target %pB has EABI version %d"),
 	 ibfd, (in_flags & EF_ARM_EABIMASK) >> 24,
 	 obfd, (out_flags & EF_ARM_EABIMASK) >> 24);
       return FALSE;
@@ -19569,7 +19569,7 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
 	{
 	  _bfd_error_handler
-	    (_("error: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
+	    (_("error: %pB is compiled for APCS-%d, whereas target %pB uses APCS-%d"),
 	     ibfd, in_flags & EF_ARM_APCS_26 ? 26 : 32,
 	     obfd, out_flags & EF_ARM_APCS_26 ? 26 : 32);
 	  flags_compatible = FALSE;
@@ -19579,11 +19579,11 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  if (in_flags & EF_ARM_APCS_FLOAT)
 	    _bfd_error_handler
-	      (_("error: %B passes floats in float registers, whereas %B passes them in integer registers"),
+	      (_("error: %pB passes floats in float registers, whereas %pB passes them in integer registers"),
 	       ibfd, obfd);
 	  else
 	    _bfd_error_handler
-	      (_("error: %B passes floats in integer registers, whereas %B passes them in float registers"),
+	      (_("error: %pB passes floats in integer registers, whereas %pB passes them in float registers"),
 	       ibfd, obfd);
 
 	  flags_compatible = FALSE;
@@ -19593,11 +19593,11 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  if (in_flags & EF_ARM_VFP_FLOAT)
 	    _bfd_error_handler
-	      (_("error: %B uses VFP instructions, whereas %B does not"),
+	      (_("error: %pB uses VFP instructions, whereas %pB does not"),
 	       ibfd, obfd);
 	  else
 	    _bfd_error_handler
-	      (_("error: %B uses FPA instructions, whereas %B does not"),
+	      (_("error: %pB uses FPA instructions, whereas %pB does not"),
 	       ibfd, obfd);
 
 	  flags_compatible = FALSE;
@@ -19607,11 +19607,11 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
 	    _bfd_error_handler
-	      (_("error: %B uses Maverick instructions, whereas %B does not"),
+	      (_("error: %pB uses Maverick instructions, whereas %pB does not"),
 	       ibfd, obfd);
 	  else
 	    _bfd_error_handler
-	      (_("error: %B does not use Maverick instructions, whereas %B does"),
+	      (_("error: %pB does not use Maverick instructions, whereas %pB does"),
 	       ibfd, obfd);
 
 	  flags_compatible = FALSE;
@@ -19630,11 +19630,11 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	    {
 	      if (in_flags & EF_ARM_SOFT_FLOAT)
 		_bfd_error_handler
-		  (_("error: %B uses software FP, whereas %B uses hardware FP"),
+		  (_("error: %pB uses software FP, whereas %pB uses hardware FP"),
 		   ibfd, obfd);
 	      else
 		_bfd_error_handler
-		  (_("error: %B uses hardware FP, whereas %B uses software FP"),
+		  (_("error: %pB uses hardware FP, whereas %pB uses software FP"),
 		   ibfd, obfd);
 
 	      flags_compatible = FALSE;
@@ -19648,13 +19648,13 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  if (in_flags & EF_ARM_INTERWORK)
 	    {
 	      _bfd_error_handler
-		(_("Warning: %B supports interworking, whereas %B does not"),
+		(_("Warning: %pB supports interworking, whereas %pB does not"),
 		 ibfd, obfd);
 	    }
 	  else
 	    {
 	      _bfd_error_handler
-		(_("Warning: %B does not support interworking, whereas %B does"),
+		(_("Warning: %pB does not support interworking, whereas %pB does"),
 		 ibfd, obfd);
 	    }
 	}
diff --git a/sdcc/support/sdbinutils/bfd/elf32-avr.c b/sdcc/support/sdbinutils/bfd/elf32-avr.c
index 46e15ec4d..0849a8d76 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-avr.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-avr.c
@@ -956,7 +956,7 @@ avr_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_AVR_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid AVR reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid AVR reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_avr_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-bfin.c b/sdcc/support/sdbinutils/bfd/elf32-bfin.c
index 478b8d473..afd316b98 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-bfin.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-bfin.c
@@ -1574,7 +1574,7 @@ bfin_relocate_section (bfd * output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable relocation against symbol `%s'"),
 	     input_bfd,
 	     input_section, rel->r_offset, h->root.root.string);
 	  return FALSE;
@@ -1605,7 +1605,7 @@ bfin_relocate_section (bfd * output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): reloc against `%s': error %d"),
+		(_("%pB(%pA+%#Lx): reloc against `%s': error %d"),
 		 input_bfd, input_section, rel->r_offset, name, (int) r);
 	      return FALSE;
 	    }
@@ -2625,7 +2625,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation at `%A+%#Lx' references symbol `%s' with nonzero addend"),
+		(_("%pB: relocation at `%pA+%#Lx' references symbol `%s' with nonzero addend"),
 		 input_bfd, input_section, rel->r_offset, name);
 	      return FALSE;
 
@@ -4684,7 +4684,7 @@ bfinfdpic_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	bad_reloc:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: unsupported relocation type %d"),
+	    (_("%pB: unsupported relocation type %d"),
 	     abfd, (int) ELF32_R_TYPE (rel->r_info));
 	  return FALSE;
 	}
@@ -4759,7 +4759,7 @@ elf32_bfin_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if (0)
 #endif
   _bfd_error_handler
-    ("old_flags = 0x%.8x, new_flags = 0x%.8x, init = %s, filename = %B",
+    ("old_flags = 0x%.8x, new_flags = 0x%.8x, init = %s, filename = %pB",
      old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no", ibfd);
 
   if (!elf_flags_init (obfd))			/* First call, no flags set.  */
@@ -4773,11 +4773,11 @@ elf32_bfin_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       error = TRUE;
       if (IS_FDPIC (obfd))
 	_bfd_error_handler
-	  (_("%B: cannot link non-fdpic object file into fdpic executable"),
+	  (_("%pB: cannot link non-fdpic object file into fdpic executable"),
 	   ibfd);
       else
 	_bfd_error_handler
-	  (_("%B: cannot link fdpic object file into non-fdpic executable"),
+	  (_("%pB: cannot link fdpic object file into non-fdpic executable"),
 	   ibfd);
     }
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-cr16.c b/sdcc/support/sdbinutils/bfd/elf32-cr16.c
index 7bb67a72e..7842e8969 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-cr16.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-cr16.c
@@ -679,7 +679,7 @@ elf_cr16_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
   if (r_type >= R_CR16_MAX)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised CR16 reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised CR16 reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_CR16_NONE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-cr16c.c b/sdcc/support/sdbinutils/bfd/elf32-cr16c.c
index ec2948de7..79aed1381 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-cr16c.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-cr16c.c
@@ -183,7 +183,7 @@ elf_cr16c_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= RINDEX_16C_MAX)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid CR16C reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid CR16C reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-cris.c b/sdcc/support/sdbinutils/bfd/elf32-cris.c
index 4cbe4c59c..1408d804b 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-cris.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-cris.c
@@ -464,7 +464,7 @@ cris_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= R_CRIS_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid CRIS reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid CRIS reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & cris_elf_howto_table [r_type];
@@ -1113,7 +1113,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B, section %A: unresolvable relocation %s against symbol `%s'"),
+		    (_("%pB, section %pA: unresolvable relocation %s against symbol `%s'"),
 		     input_bfd,
 		     input_section,
 		     cris_elf_howto_table[r_type].name,
@@ -1178,10 +1178,10 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	      _bfd_error_handler
 		((h->got.offset == (bfd_vma) -1)
 		 /* xgettext:c-format */
-		 ? _("%B, section %A: No PLT nor GOT for relocation %s"
+		 ? _("%pB, section %pA: No PLT nor GOT for relocation %s"
 		     " against symbol `%s'")
 		 /* xgettext:c-format */
-		 : _("%B, section %A: No PLT for relocation %s"
+		 : _("%pB, section %pA: No PLT for relocation %s"
 		     " against symbol `%s'"),
 		 input_bfd,
 		 input_section,
@@ -1305,7 +1305,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		if (h == NULL)
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B, section %A: relocation %s with non-zero addend %Ld"
+		    (_("%pB, section %pA: relocation %s with non-zero addend %Ld"
 		       " against local symbol"),
 		     input_bfd,
 		     input_section,
@@ -1314,7 +1314,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		else
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B, section %A: relocation %s with non-zero addend %Ld"
+		    (_("%pB, section %pA: relocation %s with non-zero addend %Ld"
 		       " against symbol `%s'"),
 		     input_bfd,
 		     input_section,
@@ -1341,7 +1341,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A: relocation %s is"
+		(_("%pB, section %pA: relocation %s is"
 		   " not allowed for global symbol: `%s'"),
 		 input_bfd,
 		 input_section,
@@ -1358,7 +1358,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A: relocation %s with no GOT created"),
+		(_("%pB, section %pA: relocation %s with no GOT created"),
 		 input_bfd,
 		 input_section,
 		 cris_elf_howto_table[r_type].name);
@@ -1575,10 +1575,10 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		((h->root.type == bfd_link_hash_undefined)
 		 /* We shouldn't get here for GCC-emitted code.  */
 		 /* xgettext:c-format */
-		 ? _("%B, section %A: relocation %s has an undefined"
+		 ? _("%pB, section %pA: relocation %s has an undefined"
 		     " reference to `%s', perhaps a declaration mixup?")
 		 /* xgettext:c-format */
-		 : _("%B, section %A: relocation %s is"
+		 : _("%pB, section %pA: relocation %s is"
 		     " not allowed for `%s', a global symbol with default"
 		     " visibility, perhaps a declaration mixup?"),
 		 input_bfd,
@@ -1662,7 +1662,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		 to pass us these kinds of things.  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A: relocation %s with non-zero addend %Ld"
+		(_("%pB, section %pA: relocation %s with non-zero addend %Ld"
 		   " against symbol `%s'"),
 		 input_bfd,
 		 input_section,
@@ -1815,7 +1815,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		 things.  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A: relocation %s with non-zero addend %Ld"
+		(_("%pB, section %pA: relocation %s with non-zero addend %Ld"
 		   " against symbol `%s'"),
 		 input_bfd,
 		 input_section,
@@ -1949,7 +1949,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A: relocation %s is"
+		(_("%pB, section %pA: relocation %s is"
 		   " not allowed for symbol: `%s'"
 		   " which is defined outside the program,"
 		   " perhaps a declaration mixup?"),
@@ -3044,7 +3044,7 @@ cris_elf_check_relocs (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B, section %A:\n  v10/v32 compatible object"
+		    (_("%pB, section %pA:\n  v10/v32 compatible object"
 		       " must not contain a PIC relocation"),
 		     abfd, sec);
 		  return FALSE;
@@ -3098,7 +3098,7 @@ cris_elf_check_relocs (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A:\n  relocation %s not valid"
+		(_("%pB, section %pA:\n  relocation %s not valid"
 		   " in a shared object;"
 		   " typically an option mixup, recompile with -fPIC"),
 		 abfd,
@@ -3316,7 +3316,7 @@ cris_elf_check_relocs (bfd *abfd,
 	      /* FIXME: How do we make this optionally a warning only?  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B, section %A:\n  relocation %s should not"
+		(_("%pB, section %pA:\n  relocation %s should not"
 		   " be used in a shared object; recompile with -fPIC"),
 		 abfd,
 		 sec,
@@ -3741,7 +3741,7 @@ elf_cris_discard_excess_dso_dynamics (struct elf_cris_link_hash_entry *h,
 	/* FIXME: How do we make this optionally a warning only?  */
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B, section `%A', to symbol `%s':\n"
+	  (_("%pB, section `%pA', to symbol `%s':\n"
 	     "  relocation %s should not be used"
 	     " in a shared object; recompile with -fPIC"),
 	   s->section->owner,
@@ -3955,8 +3955,8 @@ cris_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	(bfd_get_symbol_leading_char (ibfd) == '_'
-	 ? _("%B: uses _-prefixed symbols, but writing file with non-prefixed symbols")
-	 : _("%B: uses non-prefixed symbols, but writing file with _-prefixed symbols"),
+	 ? _("%pB: uses _-prefixed symbols, but writing file with non-prefixed symbols")
+	 : _("%pB: uses non-prefixed symbols, but writing file with _-prefixed symbols"),
 	 ibfd);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -3975,9 +3975,9 @@ cris_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  _bfd_error_handler
 	    ((imach == bfd_mach_cris_v32)
-	     ? _("%B contains CRIS v32 code, incompatible"
+	     ? _("%pB contains CRIS v32 code, incompatible"
 		 " with previous objects")
-	     : _("%B contains non-CRIS-v32 code, incompatible"
+	     : _("%pB contains non-CRIS-v32 code, incompatible"
 		 " with previous objects"),
 	     ibfd);
 	  bfd_set_error (bfd_error_bad_value);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-crx.c b/sdcc/support/sdbinutils/bfd/elf32-crx.c
index d8a3862e2..109e22718 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-crx.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-crx.c
@@ -426,7 +426,7 @@ elf_crx_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
   if (r_type >= R_CRX_MAX)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised CRX reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised CRX reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_CRX_NONE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-d10v.c b/sdcc/support/sdbinutils/bfd/elf32-d10v.c
index 0d1453cbc..344a1afac 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-d10v.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-d10v.c
@@ -231,7 +231,7 @@ d10v_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_D10V_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid D10V reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid D10V reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_d10v_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-d30v.c b/sdcc/support/sdbinutils/bfd/elf32-d30v.c
index 51d9b88c6..505560fb9 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-d30v.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-d30v.c
@@ -519,7 +519,7 @@ d30v_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_D30V_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid D30V reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid D30V reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_d30v_howto_table[r_type];
@@ -538,7 +538,7 @@ d30v_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_D30V_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid D30V reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid D30V reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_d30v_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-epiphany.c b/sdcc/support/sdbinutils/bfd/elf32-epiphany.c
index 1ad1184cc..a6b70388d 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-epiphany.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-epiphany.c
@@ -373,7 +373,7 @@ epiphany_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_EPIPHANY_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid Epiphany reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid Epiphany reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & epiphany_elf_howto_table [r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-fr30.c b/sdcc/support/sdbinutils/bfd/elf32-fr30.c
index 679322a6e..1ef9dedc6 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-fr30.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-fr30.c
@@ -378,7 +378,7 @@ fr30_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_FR30_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid FR30 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid FR30 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & fr30_elf_howto_table [r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-frv.c b/sdcc/support/sdbinutils/bfd/elf32-frv.c
index b8d033879..b06ab36d1 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-frv.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-frv.c
@@ -2554,7 +2554,7 @@ frv_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
       if (r_type >= (unsigned int) R_FRV_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid FRV reloc number: %d"), abfd, r_type);
+	  _bfd_error_handler (_("%pB: invalid FRV reloc number: %d"), abfd, r_type);
 	  r_type = 0;
 	}
       cache_ptr->howto = & elf32_frv_howto_table [r_type];
@@ -6252,7 +6252,7 @@ elf32_frv_check_relocs (bfd *abfd,
 	bad_reloc:
 	  info->callbacks->einfo
 	    /* xgettext:c-format */
-	    (_("%B: unsupported relocation type %i\n"),
+	    (_("%pB: unsupported relocation type %i\n"),
 	     abfd, ELF32_R_TYPE (rel->r_info));
 	  return FALSE;
 	}
@@ -6504,7 +6504,7 @@ frv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	      error = TRUE;
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: compiled with %s and linked with modules"
+		(_("%pB: compiled with %s and linked with modules"
 		   " that use non-pic relocations"),
 		 ibfd, (new_flags & EF_FRV_BIGPIC) ? "-fPIC" : "-fpic");
 #endif
@@ -6558,7 +6558,7 @@ frv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: compiled with %s and linked with modules compiled with %s"),
+	    (_("%pB: compiled with %s and linked with modules compiled with %s"),
 	     ibfd, new_opt, old_opt);
 	}
 
@@ -6571,7 +6571,7 @@ frv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: uses different unknown e_flags (%#x) fields"
+	    (_("%pB: uses different unknown e_flags (%#x) fields"
 	       " than previous modules (%#x)"),
 	     ibfd, new_partial, old_partial);
 	}
@@ -6593,11 +6593,11 @@ frv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       error = TRUE;
       if (IS_FDPIC (obfd))
 	_bfd_error_handler
-	  (_("%B: cannot link non-fdpic object file into fdpic executable"),
+	  (_("%pB: cannot link non-fdpic object file into fdpic executable"),
 	   ibfd);
       else
 	_bfd_error_handler
-	  (_("%B: cannot link fdpic object file into non-fdpic executable"),
+	  (_("%pB: cannot link fdpic object file into non-fdpic executable"),
 	   ibfd);
     }
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-gen.c b/sdcc/support/sdbinutils/bfd/elf32-gen.c
index 9ffaf59a9..a521c848c 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-gen.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-gen.c
@@ -66,7 +66,7 @@ check_for_relocs (bfd * abfd, asection * o, void * failed)
 
       ehdrp = elf_elfheader (abfd);
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Relocations in generic ELF (EM: %d)"),
+      _bfd_error_handler (_("%pB: Relocations in generic ELF (EM: %d)"),
 			  abfd, ehdrp->e_machine);
 
       bfd_set_error (bfd_error_wrong_format);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-hppa.c b/sdcc/support/sdbinutils/bfd/elf32-hppa.c
index 7454f48ad..84394e57f 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-hppa.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-hppa.c
@@ -574,7 +574,7 @@ hppa_add_stub (const char *stub_name,
   if (hsh == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 			  section->owner, stub_name);
       return NULL;
     }
@@ -826,7 +826,7 @@ hppa_build_one_stub (struct bfd_hash_entry *bh, void *in_arg)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): cannot reach %s, recompile with -ffunction-sections"),
+	    (_("%pB(%pA+%#Lx): cannot reach %s, recompile with -ffunction-sections"),
 	     hsh->target_section->owner,
 	     stub_sec,
 	     hsh->stub_offset,
@@ -1239,7 +1239,7 @@ elf32_hppa_check_relocs (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s can not be used when making a shared object; recompile with -fPIC"),
+		(_("%pB: relocation %s can not be used when making a shared object; recompile with -fPIC"),
 		 abfd,
 		 elf_hppa_howto_table[r_type].name);
 	      bfd_set_error (bfd_error_bad_value);
@@ -2079,7 +2079,7 @@ maybe_set_textrel (struct elf_link_hash_entry *eh, void *inf)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, eh->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2677,7 +2677,7 @@ get_local_syms (bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *info)
 		  else
 		    {
 		      /* xgettext:c-format */
-		      _bfd_error_handler (_("%B: duplicate export stub %s"),
+		      _bfd_error_handler (_("%pB: duplicate export stub %s"),
 					  input_bfd, stub_name);
 		    }
 		}
@@ -3330,7 +3330,7 @@ final_link_relocate (asection *input_section,
 		   error.  */
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B(%A+%#Lx): %s fixup for insn %#x is not supported in a non-shared link"),
+		  (_("%pB(%pA+%#Lx): %s fixup for insn %#x is not supported in a non-shared link"),
 		   input_bfd,
 		   input_section,
 		   offset,
@@ -3496,7 +3496,7 @@ final_link_relocate (asection *input_section,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B(%A+%#Lx): cannot reach %s, recompile with -ffunction-sections"),
+	(_("%pB(%pA+%#Lx): cannot reach %s, recompile with -ffunction-sections"),
 	 input_bfd,
 	 input_section,
 	 offset,
@@ -4139,7 +4139,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,
 		    if (*sym_name == '\0')
 		      sym_name = bfd_section_name (input_bfd, sym_sec);
 		    _bfd_error_handler
-		      (_("%B:%s has both normal and TLS relocs"),
+		      (_("%pB:%s has both normal and TLS relocs"),
 		       input_bfd, sym_name);
 		  }
 		bfd_set_error (bfd_error_bad_value);
@@ -4198,7 +4198,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): cannot handle %s for %s"),
+		(_("%pB(%pA+%#Lx): cannot handle %s for %s"),
 		 input_bfd,
 		 input_section,
 		 rela->r_offset,
diff --git a/sdcc/support/sdbinutils/bfd/elf32-i370.c b/sdcc/support/sdbinutils/bfd/elf32-i370.c
index 88be84b57..879596485 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-i370.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-i370.c
@@ -304,7 +304,7 @@ i370_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= R_I370_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised I370 reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised I370 reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_I370_NONE;
@@ -356,7 +356,7 @@ i370_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: uses different e_flags (%#x) fields than previous modules (%#x)"),
+	(_("%pB: uses different e_flags (%#x) fields than previous modules (%#x)"),
 	 ibfd, new_flags, old_flags);
 
       bfd_set_error (bfd_error_bad_value);
@@ -811,7 +811,7 @@ i370_elf_check_relocs (bfd *abfd,
     return TRUE;
 
 #ifdef DEBUG
-  _bfd_error_handler ("i370_elf_check_relocs called for section %A in %B",
+  _bfd_error_handler ("i370_elf_check_relocs called for section %pA in %pB",
 		      sec, abfd);
 #endif
 
@@ -1049,7 +1049,7 @@ i370_elf_relocate_section (bfd *output_bfd,
   bfd_boolean ret = TRUE;
 
 #ifdef DEBUG
-  _bfd_error_handler ("i370_elf_relocate_section called for %B section %A, %u relocations%s",
+  _bfd_error_handler ("i370_elf_relocate_section called for %pB section %pA, %u relocations%s",
 		      input_bfd, input_section,
 		      input_section->reloc_count,
 		      (bfd_link_relocatable (info)) ? " (relocatable)" : "");
@@ -1078,7 +1078,7 @@ i370_elf_relocate_section (bfd *output_bfd,
 	  || !i370_elf_howto_table[(int)r_type])
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: unknown relocation type %d"),
+	  _bfd_error_handler (_("%pB: unknown relocation type %d"),
 			      input_bfd, (int) r_type);
 
 	  bfd_set_error (bfd_error_bad_value);
@@ -1161,7 +1161,7 @@ i370_elf_relocate_section (bfd *output_bfd,
 	{
 	default:
 	  _bfd_error_handler
-	    (_("%B: unknown relocation type %d for symbol %s"),
+	    (_("%pB: unknown relocation type %d for symbol %s"),
 	     input_bfd, (int) r_type, sym_name);
 
 	  bfd_set_error (bfd_error_bad_value);
@@ -1303,7 +1303,7 @@ i370_elf_relocate_section (bfd *output_bfd,
 	case (int) R_I370_RELATIVE:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: Relocation %s is not yet supported for symbol %s."),
+	    (_("%pB: Relocation %s is not yet supported for symbol %s."),
 	     input_bfd,
 	     i370_elf_howto_table[(int) r_type]->name,
 	     sym_name);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-i386.c b/sdcc/support/sdbinutils/bfd/elf32-i386.c
index 1f380dbdc..6b273574a 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-i386.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-i386.c
@@ -381,7 +381,7 @@ elf_i386_rtype_to_howto (bfd *abfd, unsigned r_type)
 	  >= R_386_vt - R_386_ext2))
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid relocation type %d"),
+      _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			  abfd, (int) r_type);
       indx = R_386_NONE;
     }
@@ -1156,8 +1156,8 @@ elf_i386_tls_transition (struct bfd_link_info *info, bfd *abfd,
 
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: TLS transition from %s to %s against `%s' at %#Lx "
-	   "in section `%A' failed"),
+	(_("%pB: TLS transition from %s to %s against `%s' at %#Lx "
+	   "in section `%pA' failed"),
 	 abfd, from->name, to->name, name,
 	 rel->r_offset, sec);
       bfd_set_error (bfd_error_bad_value);
@@ -1247,7 +1247,7 @@ elf_i386_convert_load_reloc (bfd *abfd, Elf_Internal_Shdr *symtab_hdr,
 
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: direct GOT relocation R_386_GOT32X against `%s' without base"
+	(_("%pB: direct GOT relocation R_386_GOT32X against `%s' without base"
 	   " register can not be used when making a shared object"),
 	 abfd, name);
       return FALSE;
@@ -1507,7 +1507,7 @@ elf_i386_check_relocs (bfd *abfd,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  goto error_return;
 	}
@@ -1700,7 +1700,7 @@ elf_i386_check_relocs (bfd *abfd,
 					     NULL);
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and "
+		      (_("%pB: `%s' accessed both as normal and "
 			 "thread local symbol"),
 		       abfd, name);
 		    bfd_set_error (bfd_error_bad_value);
@@ -1764,7 +1764,7 @@ do_relocation:
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: unsupported non-PIC call to IFUNC `%s'"),
+			(_("%pB: unsupported non-PIC call to IFUNC `%s'"),
 			 abfd, h->root.root.string);
 		      bfd_set_error (bfd_error_bad_value);
 		      goto error_return;
@@ -2342,7 +2342,7 @@ bad_ifunc_reloc:
 					 NULL);
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against STT_GNU_IFUNC "
+		(_("%pB: relocation %s against STT_GNU_IFUNC "
 		   "symbol `%s' isn't supported"), input_bfd,
 		 howto->name, name);
 	      bfd_set_error (bfd_error_bad_value);
@@ -2375,7 +2375,7 @@ do_ifunc_pointer:
 
 		  if (POINTER_LOCAL_IFUNC_P (info, h))
 		    {
-		      info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
+		      info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
 					      h->root.root.string,
 					      h->root.u.def.section->owner);
 
@@ -2590,7 +2590,7 @@ disallow_got32:
 
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: direct GOT relocation %s against `%s'"
+		    (_("%pB: direct GOT relocation %s against `%s'"
 		       " without base register can not be used"
 		       " when making a shared object"),
 		     input_bfd, howto->name, name);
@@ -2640,7 +2640,7 @@ disallow_got32:
 
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: relocation R_386_GOTOFF against undefined %s"
+		    (_("%pB: relocation R_386_GOTOFF against undefined %s"
 		       " `%s' can not be used when making a shared object"),
 		     input_bfd, v, h->root.root.string);
 		  bfd_set_error (bfd_error_bad_value);
@@ -2653,7 +2653,7 @@ disallow_got32:
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: relocation R_386_GOTOFF against protected %s"
+		    (_("%pB: relocation R_386_GOTOFF against protected %s"
 		       " `%s' can not be used when making a shared object"),
 		     input_bfd,
 		     h->type == STT_FUNC ? "function" : "data",
@@ -3430,7 +3430,7 @@ disallow_got32:
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -3470,7 +3470,7 @@ check_relocation_error:
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): reloc against `%s': error %d"),
+		(_("%pB(%pA+%#Lx): reloc against `%s': error %d"),
 		 input_bfd, input_section,
 		 rel->r_offset, name, (int) r);
 	      return FALSE;
@@ -3681,7 +3681,7 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
 			  + got_offset);
 	  if (PLT_LOCAL_IFUNC_P (info, h))
 	    {
-	      info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
+	      info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
 				      h->root.root.string,
 				      h->root.u.def.section->owner);
 
@@ -3820,7 +3820,7 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
 		}
 	      if (SYMBOL_REFERENCES_LOCAL_P (info, h))
 		{
-		  info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
+		  info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
 					  h->root.root.string,
 					  h->root.u.def.section->owner);
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-i960.c b/sdcc/support/sdbinutils/bfd/elf32-i960.c
index 61a7f9d9e..0f85efafc 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-i960.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-i960.c
@@ -137,7 +137,7 @@ elf32_i960_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (type >= R_960_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid i960 reloc number: %d"), abfd, type);
+      _bfd_error_handler (_("%pB: invalid i960 reloc number: %d"), abfd, type);
       type = 0;
     }
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-ip2k.c b/sdcc/support/sdbinutils/bfd/elf32-ip2k.c
index 3733ebb2f..66b1351a1 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-ip2k.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-ip2k.c
@@ -1242,7 +1242,7 @@ ip2k_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_IP2K_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid IP2K reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid IP2K reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & ip2k_elf_howto_table [r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-iq2000.c b/sdcc/support/sdbinutils/bfd/elf32-iq2000.c
index b29b9cbb2..4a026de67 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-iq2000.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-iq2000.c
@@ -438,7 +438,7 @@ iq2000_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
       if (r_type >= (unsigned int) R_IQ2000_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid IQ2000 reloc number: %d"), abfd, r_type);
+	  _bfd_error_handler (_("%pB: invalid IQ2000 reloc number: %d"), abfd, r_type);
 	  r_type = 0;
 	}
       cache_ptr->howto = & iq2000_elf_howto_table [r_type];
@@ -825,7 +825,7 @@ iq2000_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: compiled with %s and linked with modules compiled with %s"),
+	    (_("%pB: compiled with %s and linked with modules compiled with %s"),
 	     ibfd, new_opt, old_opt);
 	}
 
@@ -839,7 +839,7 @@ iq2000_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: uses different e_flags (%#x) fields than previous modules (%#x)"),
+	    (_("%pB: uses different e_flags (%#x) fields than previous modules (%#x)"),
 	     ibfd, new_flags, old_flags);
 	}
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-lm32.c b/sdcc/support/sdbinutils/bfd/elf32-lm32.c
index 089ec84a3..b87ed72bd 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-lm32.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-lm32.c
@@ -536,7 +536,7 @@ lm32_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_LM32_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid LM32 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid LM32 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &lm32_elf_howto_table[r_type];
@@ -1986,7 +1986,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
diff --git a/sdcc/support/sdbinutils/bfd/elf32-m32c.c b/sdcc/support/sdbinutils/bfd/elf32-m32c.c
index dfb8a1ed3..db88506c6 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-m32c.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-m32c.c
@@ -303,7 +303,7 @@ m32c_info_to_howto_rela
   if (r_type >= (unsigned int) R_M32C_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid M32C reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid M32C reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & m32c_elf_howto_table [r_type];
@@ -871,7 +871,7 @@ m32c_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: compiled with %s and linked with modules compiled with %s"),
+	    (_("%pB: compiled with %s and linked with modules compiled with %s"),
 	     ibfd, new_opt, old_opt);
 	}
 
@@ -884,7 +884,7 @@ m32c_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: uses different e_flags (%#x) fields"
+	    (_("%pB: uses different e_flags (%#x) fields"
 	       " than previous modules (%#x)"),
 	     ibfd, new_flags, old_flags);
 	}
diff --git a/sdcc/support/sdbinutils/bfd/elf32-m32r.c b/sdcc/support/sdbinutils/bfd/elf32-m32r.c
index 78d5e3966..628f82a5d 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-m32r.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-m32r.c
@@ -1283,7 +1283,7 @@ m32r_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type > (unsigned int) R_M32R_GNU_VTENTRY)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid M32R reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid M32R reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &m32r_elf_howto_table[r_type];
@@ -2094,7 +2094,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2401,7 +2401,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
       if (r_type < 0 || r_type >= (int) R_M32R_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: unknown relocation type %d"),
+	  _bfd_error_handler (_("%pB: unknown relocation type %d"),
 			      input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret = FALSE;
@@ -2523,7 +2523,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A+%#Lx): unresolvable %s relocation "
+		    (_("%pB(%pA+%#Lx): unresolvable %s relocation "
 		       "against symbol `%s'"),
 		     input_bfd,
 		     input_section,
@@ -2968,7 +2968,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: The target (%s) of an %s relocation is in the wrong section (%A)"),
+		      (_("%pB: The target (%s) of an %s relocation is in the wrong section (%pA)"),
 		       input_bfd,
 		       sym_name,
 		       m32r_elf_howto_table[(int) r_type].name,
@@ -3470,7 +3470,7 @@ m32r_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  || ((in_flags  & EF_M32R_ARCH) == E_M32R2_ARCH))
 	{
 	  _bfd_error_handler
-	    (_("%B: Instruction set mismatch with previous modules"), ibfd);
+	    (_("%pB: Instruction set mismatch with previous modules"), ibfd);
 
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-m68hc11.c b/sdcc/support/sdbinutils/bfd/elf32-m68hc11.c
index 0283e93ec..794a2af94 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-m68hc11.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-m68hc11.c
@@ -387,7 +387,7 @@ m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_M68HC11_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid M68HC11 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid M68HC11 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_m68hc11_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-m68hc12.c b/sdcc/support/sdbinutils/bfd/elf32-m68hc12.c
index 3fec99354..bde75a1fe 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-m68hc12.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-m68hc12.c
@@ -507,7 +507,7 @@ m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_M68HC11_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid M68HC12 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid M68HC12 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_m68hc11_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-m68hc1x.c b/sdcc/support/sdbinutils/bfd/elf32-m68hc1x.c
index dcdc357b2..dcb13d646 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-m68hc1x.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-m68hc1x.c
@@ -162,7 +162,7 @@ m68hc12_add_stub (const char *stub_name, asection *section,
   if (stub_entry == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 			  section->owner, stub_name);
       return NULL;
     }
@@ -1348,14 +1348,14 @@ _bfd_m68hc11_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((new_flags & E_M68HC11_I32) != (old_flags & E_M68HC11_I32))
     {
       _bfd_error_handler
-	(_("%B: linking files compiled for 16-bit integers (-mshort) "
+	(_("%pB: linking files compiled for 16-bit integers (-mshort) "
 	   "and others for 32-bit integers"), ibfd);
       ok = FALSE;
     }
   if ((new_flags & E_M68HC11_F64) != (old_flags & E_M68HC11_F64))
     {
       _bfd_error_handler
-	(_("%B: linking files compiled for 32-bit double (-fshort-double) "
+	(_("%pB: linking files compiled for 32-bit double (-fshort-double) "
 	   "and others for 64-bit double"), ibfd);
       ok = FALSE;
     }
@@ -1364,7 +1364,7 @@ _bfd_m68hc11_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if (!EF_M68HC11_CAN_MERGE_MACH (new_flags, old_flags))
     {
       _bfd_error_handler
-	(_("%B: linking files compiled for HCS12 with "
+	(_("%pB: linking files compiled for HCS12 with "
 	   "others compiled for HC12"), ibfd);
       ok = FALSE;
     }
@@ -1381,7 +1381,7 @@ _bfd_m68hc11_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: uses different e_flags (%#x) fields than previous modules (%#x)"),
+	(_("%pB: uses different e_flags (%#x) fields than previous modules (%#x)"),
 	 ibfd, new_flags, old_flags);
       ok = FALSE;
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-m68k.c b/sdcc/support/sdbinutils/bfd/elf32-m68k.c
index 112067bbe..d7f5d5f3a 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-m68k.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-m68k.c
@@ -349,7 +349,7 @@ rtype_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
   if (indx >= (unsigned int) R_68K_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid relocation type %d"),
+      _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			  abfd, (int) indx);
       indx = R_68K_NONE;
     }
@@ -1655,14 +1655,14 @@ elf_m68k_add_entry_to_got (struct elf_m68k_got *got,
     {
       if (got->n_slots[R_8] > ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info))
 	/* xgettext:c-format */
-	_bfd_error_handler (_("%B: GOT overflow: "
+	_bfd_error_handler (_("%pB: GOT overflow: "
 			      "Number of relocations with 8-bit "
 			      "offset > %d"),
 			    abfd,
 			    ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info));
       else
 	/* xgettext:c-format */
-	_bfd_error_handler (_("%B: GOT overflow: "
+	_bfd_error_handler (_("%pB: GOT overflow: "
 			      "Number of relocations with 8- or 16-bit "
 			      "offset > %d"),
 			    abfd,
@@ -3698,7 +3698,7 @@ elf_m68k_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): %s relocation not permitted in shared object"),
+		(_("%pB(%pA+%#Lx): %s relocation not permitted in shared object"),
 		 input_bfd, input_section, rel->r_offset, howto->name);
 
 	      return FALSE;
@@ -3892,7 +3892,7 @@ elf_m68k_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -3928,9 +3928,9 @@ elf_m68k_relocate_section (bfd *output_bfd,
 	      _bfd_error_handler
 		((sym_type == STT_TLS
 		  /* xgettext:c-format */
-		  ? _("%B(%A+%#Lx): %s used with TLS symbol %s")
+		  ? _("%pB(%pA+%#Lx): %s used with TLS symbol %s")
 		  /* xgettext:c-format */
-		  : _("%B(%A+%#Lx): %s used with non-TLS symbol %s")),
+		  : _("%pB(%pA+%#Lx): %s used with non-TLS symbol %s")),
 		 input_bfd,
 		 input_section,
 		 rel->r_offset,
@@ -3968,7 +3968,7 @@ elf_m68k_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): reloc against `%s': error %d"),
+		(_("%pB(%pA+%#Lx): reloc against `%s': error %d"),
 		 input_bfd, input_section,
 		 rel->r_offset, name, (int) r);
 	      return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-mcore.c b/sdcc/support/sdbinutils/bfd/elf32-mcore.c
index 9334b1d75..397ca8783 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-mcore.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-mcore.c
@@ -97,7 +97,7 @@ mcore_elf_unsupported_reloc (bfd * abfd,
   BFD_ASSERT (reloc_entry->howto != (reloc_howto_type *)0);
 
   /* xgettext:c-format */
-  _bfd_error_handler (_("%B: Relocation %s (%d) is not currently supported.\n"),
+  _bfd_error_handler (_("%pB: Relocation %s (%d) is not currently supported.\n"),
 		      abfd,
 		      reloc_entry->howto->name,
 		      reloc_entry->howto->type);
@@ -352,7 +352,7 @@ mcore_elf_info_to_howto (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= R_MCORE_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised MCore reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised MCore reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_MCORE_NONE;
@@ -408,7 +408,7 @@ mcore_elf_relocate_section (bfd * output_bfd,
 
 #ifdef DEBUG
   _bfd_error_handler
-    ("mcore_elf_relocate_section called for %B section %A, %u relocations%s",
+    ("mcore_elf_relocate_section called for %pB section %pA, %u relocations%s",
      input_bfd,
      input_section,
      input_section->reloc_count,
@@ -437,7 +437,7 @@ mcore_elf_relocate_section (bfd * output_bfd,
 	  || ! mcore_elf_howto_table [(int)r_type])
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: Unknown relocation type %d\n"),
+	  _bfd_error_handler (_("%pB: Unknown relocation type %d\n"),
 			      input_bfd, (int) r_type);
 
 	  bfd_set_error (bfd_error_bad_value);
@@ -452,7 +452,7 @@ mcore_elf_relocate_section (bfd * output_bfd,
       if (howto->special_function == mcore_elf_unsupported_reloc)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: Relocation %s (%d) is not currently supported.\n"),
+	  _bfd_error_handler (_("%pB: Relocation %s (%d) is not currently supported.\n"),
 			      input_bfd,
 			      howto->name,
 			      (int)r_type);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-mep.c b/sdcc/support/sdbinutils/bfd/elf32-mep.c
index d9d457b3f..2d6ebb694 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-mep.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-mep.c
@@ -387,7 +387,7 @@ mep_info_to_howto_rela
   if (r_type >= R_MEP_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid MEP reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid MEP reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & mep_elf_howto_table [r_type];
@@ -585,7 +585,7 @@ mep_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   old_flags = elf_elfheader (obfd)->e_flags;
 
 #ifdef DEBUG
-  _bfd_error_handler ("%B: old_flags = 0x%.8x, new_flags = 0x%.8x, init = %s",
+  _bfd_error_handler ("%pB: old_flags = 0x%.8x, new_flags = 0x%.8x, init = %s",
 		      ibfd, old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no");
 #endif
 
@@ -617,7 +617,7 @@ mep_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       else
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B and %B are for different cores"),
+	  _bfd_error_handler (_("%pB and %pB are for different cores"),
 			      last_ibfd, ibfd);
 	  bfd_set_error (bfd_error_invalid_target);
 	  return FALSE;
@@ -636,7 +636,7 @@ mep_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       else
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B and %B are for different configurations"),
+	  _bfd_error_handler (_("%pB and %pB are for different configurations"),
 			      last_ibfd, ibfd);
 	  bfd_set_error (bfd_error_invalid_target);
 	  return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-metag.c b/sdcc/support/sdbinutils/bfd/elf32-metag.c
index b985fc0b0..24e002515 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-metag.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-metag.c
@@ -875,7 +875,7 @@ metag_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_METAG_MAX)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid METAG reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid METAG reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & elf_metag_howto_table [r_type];
@@ -1180,7 +1180,7 @@ metag_add_stub (const char *stub_name,
   if (hsh == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 			  section->owner, stub_name);
       return NULL;
     }
@@ -1857,10 +1857,10 @@ elf_metag_relocate_section (bfd *output_bfd,
 			/* We don't support changing the TLS model.  */
 			/* PR 20675 */
 			if (bfd_link_pic (info))
-			  _bfd_error_handler (_("%B(%A): multiple TLS models are not supported"),
+			  _bfd_error_handler (_("%pB(%pA): multiple TLS models are not supported"),
 					      input_bfd, input_section);
 			else
-			  _bfd_error_handler (_("%B(%A): shared library symbol %s encountered whilst performing a static link"),
+			  _bfd_error_handler (_("%pB(%pA): shared library symbol %s encountered whilst performing a static link"),
 					      input_bfd, input_section, name);
 			return FALSE;
 		      }
@@ -1913,7 +1913,7 @@ elf_metag_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): %s relocation not permitted in shared object"),
+		(_("%pB(%pA+%#Lx): %s relocation not permitted in shared object"),
 		 input_bfd, input_section, rel->r_offset, howto->name);
 	      return FALSE;
 	    }
@@ -2249,7 +2249,7 @@ elf_metag_check_relocs (bfd *abfd,
 		name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
+		(_("%pB: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
 		 abfd, elf_metag_howto_table[r_type].name, name);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -2789,7 +2789,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
diff --git a/sdcc/support/sdbinutils/bfd/elf32-microblaze.c b/sdcc/support/sdbinutils/bfd/elf32-microblaze.c
index f1808bc44..a7e547665 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-microblaze.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-microblaze.c
@@ -653,7 +653,7 @@ microblaze_elf_info_to_howto (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= R_MICROBLAZE_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised MicroBlaze reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised MicroBlaze reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_MICROBLAZE_NONE;
@@ -929,7 +929,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,
       if (r_type < 0 || r_type >= (int) R_MICROBLAZE_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: unknown relocation type %d"),
+	  _bfd_error_handler (_("%pB: unknown relocation type %d"),
 			      input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret = FALSE;
@@ -1061,8 +1061,8 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 		      {
 			_bfd_error_handler
 			  /* xgettext:c-format */
-			  (_("%B: The target (%s) of an %s relocation"
-			     " is in the wrong section (%A)"),
+			  (_("%pB: The target (%s) of an %s relocation"
+			     " is in the wrong section (%pA)"),
 			   input_bfd,
 			   sym_name,
 			   microblaze_elf_howto_table[(int) r_type]->name,
@@ -1109,8 +1109,8 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 		      {
 			_bfd_error_handler
 			  /* xgettext:c-format */
-			  (_("%B: The target (%s) of an %s relocation"
-			     " is in the wrong section (%A)"),
+			  (_("%pB: The target (%s) of an %s relocation"
+			     " is in the wrong section (%pA)"),
 			   input_bfd,
 			   sym_name,
 			   microblaze_elf_howto_table[(int) r_type]->name,
@@ -1479,7 +1479,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 			  {
 			    BFD_FAIL ();
 			    _bfd_error_handler
-			      (_("%B: probably compiled without -fPIC?"),
+			      (_("%pB: probably compiled without -fPIC?"),
 			       input_bfd);
 			    bfd_set_error (bfd_error_bad_value);
 			    return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-moxie.c b/sdcc/support/sdbinutils/bfd/elf32-moxie.c
index 8c7a378f4..579aae26e 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-moxie.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-moxie.c
@@ -134,7 +134,7 @@ moxie_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_MOXIE_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid Moxie reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid Moxie reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & moxie_elf_howto_table [r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-msp430.c b/sdcc/support/sdbinutils/bfd/elf32-msp430.c
index 5ee32c488..dd7802ca9 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-msp430.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-msp430.c
@@ -645,7 +645,7 @@ msp430_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
       if (r_type >= (unsigned int) R_MSP430x_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid MSP430X reloc number: %d"), abfd, r_type);
+	  _bfd_error_handler (_("%pB: invalid MSP430X reloc number: %d"), abfd, r_type);
 	  r_type = 0;
 	}
       cache_ptr->howto = elf_msp430x_howto_table + r_type;
@@ -655,7 +655,7 @@ msp430_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_MSP430_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid MSP430 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid MSP430 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_msp430_howto_table[r_type];
@@ -2349,7 +2349,7 @@ elf32_msp430_obj_attrs_handle_unknown (bfd *abfd, int tag)
 {
   _bfd_error_handler
     /* xgettext:c-format */
-    (_("Warning: %B: Unknown MSPABI object attribute %d"),
+    (_("Warning: %pB: Unknown MSPABI object attribute %d"),
      abfd, tag);
   return TRUE;
 }
@@ -2442,7 +2442,7 @@ elf32_msp430_merge_mspabi_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B uses %s instructions but %B uses %s"),
+	(_("error: %pB uses %s instructions but %pB uses %s"),
 	 ibfd, isa_type (in_attr[OFBA_MSPABI_Tag_ISA].i),
 	 first_input_bfd, isa_type (out_attr[OFBA_MSPABI_Tag_ISA].i));
       result = FALSE;
@@ -2454,7 +2454,7 @@ elf32_msp430_merge_mspabi_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B uses the %s code model whereas %B uses the %s code model"),
+	(_("error: %pB uses the %s code model whereas %pB uses the %s code model"),
 	 ibfd, code_model (in_attr[OFBA_MSPABI_Tag_Code_Model].i),
 	 first_input_bfd, code_model (out_attr[OFBA_MSPABI_Tag_Code_Model].i));
       result = FALSE;
@@ -2466,7 +2466,7 @@ elf32_msp430_merge_mspabi_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B uses the large code model but %B uses MSP430 instructions"),
+	(_("error: %pB uses the large code model but %pB uses MSP430 instructions"),
 	 ibfd, first_input_bfd);
       result = FALSE;
     }
@@ -2477,7 +2477,7 @@ elf32_msp430_merge_mspabi_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B uses the %s data model whereas %B uses the %s data model"),
+	(_("error: %pB uses the %s data model whereas %pB uses the %s data model"),
 	 ibfd, data_model (in_attr[OFBA_MSPABI_Tag_Data_Model].i),
 	 first_input_bfd, data_model (out_attr[OFBA_MSPABI_Tag_Data_Model].i));
       result = FALSE;
@@ -2489,7 +2489,7 @@ elf32_msp430_merge_mspabi_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B uses the small code model but %B uses the %s data model"),
+	(_("error: %pB uses the small code model but %pB uses the %s data model"),
 	 ibfd, first_input_bfd,
 	 data_model (out_attr[OFBA_MSPABI_Tag_Data_Model].i));
       result = FALSE;
@@ -2501,7 +2501,7 @@ elf32_msp430_merge_mspabi_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B uses the %s data model but %B only uses MSP430 instructions"),
+	(_("error: %pB uses the %s data model but %pB only uses MSP430 instructions"),
 	 ibfd, data_model (in_attr[OFBA_MSPABI_Tag_Data_Model].i),
 	 first_input_bfd);
       result = FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-mt.c b/sdcc/support/sdbinutils/bfd/elf32-mt.c
index b58394f50..8ac873ca4 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-mt.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-mt.c
@@ -239,7 +239,7 @@ mt_info_to_howto_rela
   if (r_type >= (unsigned int) R_MT_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid MT reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid MT reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & mt_elf_howto_table [r_type];
@@ -520,7 +520,7 @@ mt_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   old_flags = elf_elfheader (obfd)->e_flags;
 
 #ifdef DEBUG
-  _bfd_error_handler ("%B: old_flags = 0x%.8x, new_flags = 0x%.8x, init = %s",
+  _bfd_error_handler ("%pB: old_flags = 0x%.8x, new_flags = 0x%.8x, init = %s",
 		      ibfd, old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no");
 #endif
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-nds32.c b/sdcc/support/sdbinutils/bfd/elf32-nds32.c
index 5ceb0a0b2..5cb2d49c5 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-nds32.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-nds32.c
@@ -2894,7 +2894,7 @@ nds32_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
   if (r_type > R_NDS32_GNU_VTENTRY)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid NDS32 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid NDS32 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = bfd_elf32_bfd_reloc_type_table_lookup (r_type);
@@ -3841,7 +3841,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -4407,7 +4407,7 @@ nds32_elf_relocate_section (bfd *		   output_bfd ATTRIBUTE_UNUSED,
       /* Set the _ITB_BASE_.  */
       if (!nds32_elf_ex9_itb_base (info))
 	{
-	  _bfd_error_handler (_("%B: error: Cannot set _ITB_BASE_"),
+	  _bfd_error_handler (_("%pB: error: Cannot set _ITB_BASE_"),
 			      output_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	}
@@ -4449,7 +4449,7 @@ nds32_elf_relocate_section (bfd *		   output_bfd ATTRIBUTE_UNUSED,
       if (r_type >= R_NDS32_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: error: unknown relocation type %d."),
+	  _bfd_error_handler (_("%pB: error: unknown relocation type %d."),
 			      input_bfd, r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret = FALSE;
@@ -4895,7 +4895,7 @@ nds32_elf_relocate_section (bfd *		   output_bfd ATTRIBUTE_UNUSED,
 	  if (bfd_link_pic (info))
 	    {
 	      _bfd_error_handler
-		(_("%B: warning: cannot deal R_NDS32_25_ABS_RELA in shared "
+		(_("%pB: warning: cannot deal R_NDS32_25_ABS_RELA in shared "
 		   "mode."), input_bfd);
 	      return FALSE;
 	    }
@@ -5029,7 +5029,7 @@ nds32_elf_relocate_section (bfd *		   output_bfd ATTRIBUTE_UNUSED,
 	    {
 	      /* Incorrect alignment.  */
 	      _bfd_error_handler
-		(_("%B: warning: unaligned access to GOT entry."), input_bfd);
+		(_("%pB: warning: unaligned access to GOT entry."), input_bfd);
 	      ret = FALSE;
 	      r = bfd_reloc_dangerous;
 	      goto check_reloc;
@@ -5071,7 +5071,7 @@ handle_sda:
 	      if (r != bfd_reloc_ok)
 		{
 		  _bfd_error_handler
-		    (_("%B: warning: relocate SDA_BASE failed."), input_bfd);
+		    (_("%pB: warning: relocate SDA_BASE failed."), input_bfd);
 		  ret = FALSE;
 		  goto check_reloc;
 		}
@@ -5093,7 +5093,7 @@ handle_sda:
 		  /* Incorrect alignment.  */
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A): warning: unaligned small data access of type %d."),
+		    (_("%pB(%pA): warning: unaligned small data access of type %d."),
 		     input_bfd, input_section, r_type);
 		  ret = FALSE;
 		  goto check_reloc;
@@ -5841,7 +5841,7 @@ nds32_check_vec_size (bfd *ibfd)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: ISR vector size mismatch"
+	    (_("%pB: ISR vector size mismatch"
 	       " with previous modules, previous %u-byte, current %u-byte"),
 	     ibfd,
 	     nds32_vec_size == 1 ? 4 : nds32_vec_size == 2 ? 16 : 0xffffffff,
@@ -5885,7 +5885,7 @@ nds32_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if (bfd_little_endian (ibfd) != bfd_little_endian (obfd))
     {
       _bfd_error_handler
-	(_("%B: warning: Endian mismatch with previous modules."), ibfd);
+	(_("%pB: warning: Endian mismatch with previous modules."), ibfd);
 
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -5895,7 +5895,7 @@ nds32_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if (in_version == E_NDS32_ELF_VER_1_2)
     {
       _bfd_error_handler
-	(_("%B: warning: Older version of object file encountered, "
+	(_("%pB: warning: Older version of object file encountered, "
 	   "Please recompile with current tool chain."), ibfd);
     }
 
@@ -5973,7 +5973,7 @@ nds32_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_NDS_ABI) != (out_flags & EF_NDS_ABI))
     {
       _bfd_error_handler
-	(_("%B: error: ABI mismatch with previous modules."), ibfd);
+	(_("%pB: error: ABI mismatch with previous modules."), ibfd);
 
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -5984,7 +5984,7 @@ nds32_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       if (((in_flags & EF_NDS_ARCH) != E_N1_ARCH))
 	{
 	  _bfd_error_handler
-	    (_("%B: error: Instruction set mismatch with previous modules."), ibfd);
+	    (_("%pB: error: Instruction set mismatch with previous modules."), ibfd);
 
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -6010,7 +6010,7 @@ nds32_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       if (in_version != out_version)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: warning: Incompatible elf-versions %s and  %s."),
+	  (_("%pB: warning: Incompatible elf-versions %s and  %s."),
 	   ibfd, nds32_elfver_strtab[out_version],
 	   nds32_elfver_strtab[in_version]);
 
@@ -8532,7 +8532,7 @@ done_adjust_diff:
 		  && (blank_t2->offset > raddr
 		      || blank_t2->next->offset <= raddr))
 		_bfd_error_handler
-		  (_("%B: Error: search_nds32_elf_blank reports wrong node\n"), abfd);
+		  (_("%pB: Error: search_nds32_elf_blank reports wrong node\n"), abfd);
 
 	      /* Mark reloc in deleted portion as NONE.
 		 For some relocs like R_NDS32_LABEL that doesn't modify the
@@ -8791,7 +8791,7 @@ relax_range_measurement (bfd *abfd)
 
 static const char * unrecognized_reloc_msg =
   /* xgettext:c-format */
-  N_("%B: warning: %s points to unrecognized reloc at %#Lx");
+  N_("%pB: warning: %s points to unrecognized reloc at %#Lx");
 
 /* Relax LONGCALL1 relocation for nds32_elf_relax_section.  */
 
@@ -11780,7 +11780,7 @@ nds32_elf_relax_section (bfd *abfd, asection *sec,
       /* Set the _ITB_BASE_.  */
       if (!nds32_elf_ex9_itb_base (link_info))
 	{
-	  _bfd_error_handler (_("%B: error: Cannot set _ITB_BASE_"), abfd);
+	  _bfd_error_handler (_("%pB: error: Cannot set _ITB_BASE_"), abfd);
 	  bfd_set_error (bfd_error_bad_value);
 	}
     }
@@ -12526,7 +12526,7 @@ nds32_relax_fp_as_gp (struct bfd_link_info *link_info,
 	  /* Begin of the region.  */
 	  if (begin_rel)
 	    /* xgettext:c-format */
-	    _bfd_error_handler (_("%B: Nested OMIT_FP in %A."), abfd, sec);
+	    _bfd_error_handler (_("%pB: Nested OMIT_FP in %pA."), abfd, sec);
 
 	  begin_rel = irel;
 	  nds32_fag_init (&fag_head);
@@ -12545,7 +12545,7 @@ nds32_relax_fp_as_gp (struct bfd_link_info *link_info,
 	  if (begin_rel == NULL)
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B: Unmatched OMIT_FP in %A."), abfd, sec);
+	      _bfd_error_handler (_("%pB: Unmatched OMIT_FP in %pA."), abfd, sec);
 	      continue;
 	    }
 
@@ -12828,7 +12828,7 @@ nds32_elf_get_relocated_section_contents (bfd *abfd,
 		     message instead.  */
 		  link_info->callbacks->einfo
 		    /* xgettext:c-format */
-		    (_("%X%P: %B(%A): relocation \"%R\" goes out of range\n"),
+		    (_("%X%P: %pB(%pA): relocation \"%R\" goes out of range\n"),
 		     abfd, input_section, * parent);
 		  goto error_return;
 
@@ -15238,7 +15238,7 @@ nds32_elf_ex9_build_hash_table (bfd *abfd, asection *sec,
 			  /* Incorrect alignment.  */
 			  _bfd_error_handler
 			    /* xgettext:c-format */
-			    (_("%B: warning: unaligned small data access "
+			    (_("%pB: warning: unaligned small data access "
 			       "for entry: {%Ld, %Ld, %Ld}, addr = %#Lx, align = %#x"),
 			     abfd, irel->r_offset,
 			     irel->r_info, irel->r_addend, relocation, align);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-nios2.c b/sdcc/support/sdbinutils/bfd/elf32-nios2.c
index aad4bd0f5..b4849dbff 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-nios2.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-nios2.c
@@ -2204,7 +2204,7 @@ nios2_add_stub (const char *stub_name,
   if (hsh == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 			  section->owner,
 			  stub_name);
       return NULL;
@@ -2926,7 +2926,7 @@ nios2_elf32_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  if (bfd_big_endian (ibfd))
 	    {
 	      _bfd_error_handler
-		(_("error: %B: Big-endian R2 is not supported."), ibfd);
+		(_("error: %pB: Big-endian R2 is not supported."), ibfd);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
 	    }
@@ -2942,7 +2942,7 @@ nios2_elf32_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	 architectures.  */
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B: Conflicting CPU architectures %d/%d"),
+	(_("error: %pB: Conflicting CPU architectures %d/%d"),
 	 ibfd, new_flags, old_flags);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -4355,7 +4355,7 @@ nios2_elf32_relocate_section (bfd *output_bfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A+%#Lx): %s relocation not "
+		    (_("%pB(%pA+%#Lx): %s relocation not "
 		       "permitted in shared object"),
 		     input_bfd, input_section,
 		     rel->r_offset, howto->name);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-or1k.c b/sdcc/support/sdbinutils/bfd/elf32-or1k.c
index c3a2a8fe0..67e5769e5 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-or1k.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-or1k.c
@@ -712,7 +712,7 @@ or1k_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_OR1K_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid OR1K reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid OR1K reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = & or1k_elf_howto_table[r_type];
@@ -1049,7 +1049,7 @@ or1k_elf_relocate_section (bfd *output_bfd,
 		      {
 			BFD_FAIL ();
 			_bfd_error_handler
-			  (_("%B: probably compiled without -fPIC?"),
+			  (_("%pB: probably compiled without -fPIC?"),
 			   input_bfd);
 			bfd_set_error (bfd_error_bad_value);
 			return FALSE;
@@ -1071,7 +1071,7 @@ or1k_elf_relocate_section (bfd *output_bfd,
 	  /* TODO: implement support for local dynamic.  */
 	  BFD_FAIL ();
 	  _bfd_error_handler
-	    (_("%B: support for local dynamic not implemented"),
+	    (_("%pB: support for local dynamic not implemented"),
 	     input_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -1206,7 +1206,7 @@ or1k_elf_relocate_section (bfd *output_bfd,
 	     be used as linker input.  */
 	  BFD_FAIL ();
 	  _bfd_error_handler
-	    (_("%B: will not resolve runtime TLS relocation"),
+	    (_("%pB: will not resolve runtime TLS relocation"),
 	     input_bfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -1526,7 +1526,7 @@ or1k_elf_check_relocs (bfd *abfd,
 		      {
 			_bfd_error_handler
 			  /* xgettext:c-format */
-			  (_("%B: bad relocation section name `%s\'"),
+			  (_("%pB: bad relocation section name `%s\'"),
 			   abfd, name);
 		      }
 
@@ -2278,7 +2278,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2638,7 +2638,7 @@ elf32_or1k_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_OR1K_NODELAY) != (out_flags & EF_OR1K_NODELAY))
     {
       _bfd_error_handler
-	(_("%B: EF_OR1K_NODELAY flag mismatch with previous modules"), ibfd);
+	(_("%pB: EF_OR1K_NODELAY flag mismatch with previous modules"), ibfd);
 
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-pj.c b/sdcc/support/sdbinutils/bfd/elf32-pj.c
index 3487524de..3350f2084 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-pj.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-pj.c
@@ -322,7 +322,7 @@ pj_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
   if (r >= R_PJ_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised PicoJava reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised PicoJava reloc number: %d"),
 			  abfd, r);
       bfd_set_error (bfd_error_bad_value);
       r = R_PJ_NONE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-ppc.c b/sdcc/support/sdbinutils/bfd/elf32-ppc.c
index 32104a12f..92ef19e2c 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-ppc.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-ppc.c
@@ -2031,7 +2031,7 @@ ppc_elf_info_to_howto (bfd *abfd,
   if (r_type >= R_PPC_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised PPC reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised PPC reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_PPC_NONE;
@@ -2043,7 +2043,7 @@ ppc_elf_info_to_howto (bfd *abfd,
   if (!cache_ptr->howto)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid relocation type %d"),
+      _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
 
@@ -2736,7 +2736,7 @@ ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
 	continue;
 
       /* xgettext:c-format */
-      error_message = _("corrupt %s section in %B");
+      error_message = _("corrupt %s section in %pB");
       length = asec->size;
       if (length < 20)
 	goto fail;
@@ -2756,7 +2756,7 @@ ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
 	  || (bfd_bread (buffer, length, ibfd) != length))
 	{
 	  /* xgettext:c-format */
-	  error_message = _("unable to read in %s section from %B");
+	  error_message = _("unable to read in %s section from %pB");
 	  goto fail;
 	}
 
@@ -2798,7 +2798,7 @@ ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
 	{
 	  ibfd = abfd;
 	  /* xgettext:c-format */
-	  error_message = _("warning: unable to set size of %s section in %B");
+	  error_message = _("warning: unable to set size of %s section in %pB");
 	}
     }
 
@@ -3926,7 +3926,7 @@ bad_shared_reloc (bfd *abfd, enum elf_ppc_reloc_type r_type)
 {
   _bfd_error_handler
     /* xgettext:c-format */
-    (_("%B: relocation %s cannot be used when making a shared object"),
+    (_("%pB: relocation %s cannot be used when making a shared object"),
      abfd,
      ppc_elf_howto_table[r_type]->name);
   bfd_set_error (bfd_error_bad_value);
@@ -3963,7 +3963,7 @@ ppc_elf_check_relocs (bfd *abfd,
     return TRUE;
 
 #ifdef DEBUG
-  _bfd_error_handler ("ppc_elf_check_relocs called for section %A in %B",
+  _bfd_error_handler ("ppc_elf_check_relocs called for section %pA in %pB",
 		      sec, abfd);
 #endif
 
@@ -4639,21 +4639,21 @@ _bfd_elf_ppc_merge_fp_attributes (bfd *ibfd, struct bfd_link_info *info)
       else if (out_fp != 2 && in_fp == 2)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses hard float, %B uses soft float"), obfd, ibfd);
+	  (_("Warning: %pB uses hard float, %pB uses soft float"), obfd, ibfd);
       else if (out_fp == 2 && in_fp != 2)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses hard float, %B uses soft float"), ibfd, obfd);
+	  (_("Warning: %pB uses hard float, %pB uses soft float"), ibfd, obfd);
       else if (out_fp == 1 && in_fp == 3)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses double-precision hard float, "
-	     "%B uses single-precision hard float"), obfd, ibfd);
+	  (_("Warning: %pB uses double-precision hard float, "
+	     "%pB uses single-precision hard float"), obfd, ibfd);
       else if (out_fp == 3 && in_fp == 1)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses double-precision hard float, "
-	     "%B uses single-precision hard float"), ibfd, obfd);
+	  (_("Warning: %pB uses double-precision hard float, "
+	     "%pB uses single-precision hard float"), ibfd, obfd);
 
       in_fp = in_attr->i & 0xc;
       out_fp = out_attr->i & 0xc;
@@ -4667,23 +4667,23 @@ _bfd_elf_ppc_merge_fp_attributes (bfd *ibfd, struct bfd_link_info *info)
       else if (out_fp != 2 * 4 && in_fp == 2 * 4)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses 64-bit long double, "
-	     "%B uses 128-bit long double"), ibfd, obfd);
+	  (_("Warning: %pB uses 64-bit long double, "
+	     "%pB uses 128-bit long double"), ibfd, obfd);
       else if (in_fp != 2 * 4 && out_fp == 2 * 4)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses 64-bit long double, "
-	     "%B uses 128-bit long double"), obfd, ibfd);
+	  (_("Warning: %pB uses 64-bit long double, "
+	     "%pB uses 128-bit long double"), obfd, ibfd);
       else if (out_fp == 1 * 4 && in_fp == 3 * 4)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses IBM long double, "
-	     "%B uses IEEE long double"), ibfd, obfd);
+	  (_("Warning: %pB uses IBM long double, "
+	     "%pB uses IEEE long double"), ibfd, obfd);
       else if (out_fp == 3 * 4 && in_fp == 1 * 4)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses IBM long double, "
-	     "%B uses IEEE long double"), obfd, ibfd);
+	  (_("Warning: %pB uses IBM long double, "
+	     "%pB uses IEEE long double"), obfd, ibfd);
     }
 }
 
@@ -4733,12 +4733,12 @@ ppc_elf_merge_obj_attributes (bfd *ibfd, struct bfd_link_info *info)
       else if (out_vec < in_vec)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses AltiVec vector ABI, %B uses SPE vector ABI"),
+	  (_("Warning: %pB uses AltiVec vector ABI, %pB uses SPE vector ABI"),
 	   obfd, ibfd);
       else if (out_vec > in_vec)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses AltiVec vector ABI, %B uses SPE vector ABI"),
+	  (_("Warning: %pB uses AltiVec vector ABI, %pB uses SPE vector ABI"),
 	   ibfd, obfd);
     }
 
@@ -4761,13 +4761,13 @@ ppc_elf_merge_obj_attributes (bfd *ibfd, struct bfd_link_info *info)
       else if (out_struct < in_struct)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses r3/r4 for small structure returns, "
-	     "%B uses memory"), obfd, ibfd);
+	  (_("Warning: %pB uses r3/r4 for small structure returns, "
+	     "%pB uses memory"), obfd, ibfd);
       else if (out_struct > in_struct)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("Warning: %B uses r3/r4 for small structure returns, "
-	     "%B uses memory"), ibfd, obfd);
+	  (_("Warning: %pB uses r3/r4 for small structure returns, "
+	     "%pB uses memory"), ibfd, obfd);
     }
 
   /* Merge Tag_compatibility attributes and any common GNU ones.  */
@@ -4821,7 +4821,7 @@ ppc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  error = TRUE;
 	  _bfd_error_handler
-	    (_("%B: compiled with -mrelocatable and linked with "
+	    (_("%pB: compiled with -mrelocatable and linked with "
 	       "modules compiled normally"), ibfd);
 	}
       else if ((new_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0
@@ -4829,7 +4829,7 @@ ppc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	{
 	  error = TRUE;
 	  _bfd_error_handler
-	    (_("%B: compiled normally and linked with "
+	    (_("%pB: compiled normally and linked with "
 	       "modules compiled with -mrelocatable"), ibfd);
 	}
 
@@ -4857,7 +4857,7 @@ ppc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: uses different e_flags (%#x) fields "
+	    (_("%pB: uses different e_flags (%#x) fields "
 	       "than previous modules (%#x)"),
 	     ibfd, new_flags, old_flags);
 	}
@@ -4898,7 +4898,7 @@ ppc_elf_vle_split16 (bfd *input_bfd,
 	  else
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+0x%lx): expected 16A style relocation on 0x%08x insn"),
+	      (_("%pB(%pA+0x%lx): expected 16A style relocation on 0x%08x insn"),
 	       input_bfd, input_section, offset, opcode);
 	}
     }
@@ -4917,7 +4917,7 @@ ppc_elf_vle_split16 (bfd *input_bfd,
 	  else
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+0x%lx): expected 16D style relocation on 0x%08x insn"),
+	      (_("%pB(%pA+0x%lx): expected 16D style relocation on 0x%08x insn"),
 	       input_bfd, input_section, offset, opcode);
 	}
     }
@@ -5008,7 +5008,7 @@ ppc_elf_select_plt_layout (bfd *output_bfd ATTRIBUTE_UNUSED,
   if (htab->plt_type == PLT_OLD && htab->params->plt_style == PLT_NEW)
     {
       if (htab->old_bfd != NULL)
-	info->callbacks->einfo (_("%P: bss-plt forced due to %B\n"),
+	info->callbacks->einfo (_("%P: bss-plt forced due to %pB\n"),
 				htab->old_bfd);
       else
 	info->callbacks->einfo (_("%P: bss-plt forced by profiling\n"));
@@ -6164,7 +6164,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -6272,7 +6272,7 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,
 		      == (SEC_READONLY | SEC_ALLOC))
 		    {
 		      info->flags |= DF_TEXTREL;
-		      info->callbacks->minfo (_("%B: dynamic relocation in read-only section `%A'\n"),
+		      info->callbacks->minfo (_("%pB: dynamic relocation in read-only section `%pA'\n"),
 					      p->sec->owner, p->sec);
 		    }
 		}
@@ -7717,7 +7717,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
   struct ppc_elf_relax_info *relax_info = NULL;
 
 #ifdef DEBUG
-  _bfd_error_handler ("ppc_elf_relocate_section called for %B section %A, "
+  _bfd_error_handler ("ppc_elf_relocate_section called for %pB section %pA, "
 		      "%ld relocations%s",
 		      input_bfd, input_section,
 		      (long) input_section->reloc_count,
@@ -8183,7 +8183,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      else
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B(%A+%#Lx): error: %s with unexpected instruction %#x"),
+		  (_("%pB(%pA+%#Lx): error: %s with unexpected instruction %#x"),
 		   input_bfd, input_section, rel->r_offset,
 		   "R_PPC_ADDR16_HA", insn);
 	    }
@@ -8218,7 +8218,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      else
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B(%A+%#Lx): error: %s with unexpected instruction %#x"),
+		  (_("%pB(%pA+%#Lx): error: %s with unexpected instruction %#x"),
 		   input_bfd, input_section, rel->r_offset,
 		   "R_PPC_ADDR16_LO", insn);
 	    }
@@ -8363,7 +8363,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	default:
 	  info->callbacks->einfo
 	    /* xgettext:c-format */
-	    (_("%P: %B: unknown relocation type %d for symbol %s\n"),
+	    (_("%P: %pB: unknown relocation type %d for symbol %s\n"),
 	     input_bfd, (int) r_type, sym_name);
 
 	  bfd_set_error (bfd_error_bad_value);
@@ -9123,7 +9123,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      {
 		info->callbacks->einfo
 		  /* xgettext:c-format */
-		  (_("%P: %B: the target (%s) of a %s relocation is "
+		  (_("%P: %pB: the target (%s) of a %s relocation is "
 		     "in the wrong output section (%s)\n"),
 		   input_bfd,
 		   sym_name,
@@ -9154,7 +9154,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      {
 		info->callbacks->einfo
 		  /* xgettext:c-format */
-		  (_("%P: %B: the target (%s) of a %s relocation is "
+		  (_("%P: %pB: the target (%s) of a %s relocation is "
 		     "in the wrong output section (%s)\n"),
 		   input_bfd,
 		   sym_name,
@@ -9245,7 +9245,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      {
 		info->callbacks->einfo
 		  /* xgettext:c-format */
-		  (_("%P: %B: the target (%s) of a %s relocation is "
+		  (_("%P: %pB: the target (%s) of a %s relocation is "
 		     "in the wrong output section (%s)\n"),
 		   input_bfd,
 		   sym_name,
@@ -9333,7 +9333,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      {
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: the target (%s) of a %s relocation is "
+		  (_("%pB: the target (%s) of a %s relocation is "
 		     "in the wrong output section (%s)"),
 		   input_bfd,
 		   sym_name,
@@ -9441,7 +9441,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	case R_PPC_EMB_BIT_FLD:
 	  info->callbacks->einfo
 	    /* xgettext:c-format */
-	    (_("%P: %B: relocation %s is not yet supported for symbol %s\n"),
+	    (_("%P: %pB: relocation %s is not yet supported for symbol %s\n"),
 	     input_bfd,
 	     howto->name,
 	     sym_name);
diff --git a/sdcc/support/sdbinutils/bfd/elf32-rl78.c b/sdcc/support/sdbinutils/bfd/elf32-rl78.c
index 48714c22d..50d229f19 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-rl78.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-rl78.c
@@ -289,7 +289,7 @@ rl78_info_to_howto_rela (bfd *		     abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_RL78_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid RL78 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid RL78 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = rl78_elf_howto_table + r_type;
@@ -1078,7 +1078,7 @@ rl78_elf_relocate_section
 		 and emit a more helpful error message.  */
 	      if (r_type == R_RL78_DIR24S_PCREL)
 		/* xgettext:c-format */
-		msg = _("%B(%A): error: call to undefined function '%s'");
+		msg = _("%pB(%pA): error: call to undefined function '%s'");
 	      else
 		(*info->callbacks->reloc_overflow)
 		  (info, (h ? &h->root : NULL), name, howto->name, (bfd_vma) 0,
@@ -1092,27 +1092,27 @@ rl78_elf_relocate_section
 
 	    case bfd_reloc_other:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): warning: unaligned access to symbol '%s' in the small data area");
+	      msg = _("%pB(%pA): warning: unaligned access to symbol '%s' in the small data area");
 	      break;
 
 	    case bfd_reloc_outofrange:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: out of range error");
+	      msg = _("%pB(%pA): internal error: out of range error");
 	      break;
 
 	    case bfd_reloc_notsupported:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: unsupported relocation error");
+	      msg = _("%pB(%pA): internal error: unsupported relocation error");
 	      break;
 
 	    case bfd_reloc_dangerous:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: dangerous relocation");
+	      msg = _("%pB(%pA): internal error: dangerous relocation");
 	      break;
 
 	    default:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: unknown error");
+	      msg = _("%pB(%pA): internal error: unknown error");
 	      break;
 	    }
 
@@ -1199,8 +1199,8 @@ rl78_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("RL78 ABI conflict: G10 file %B cannot be linked"
-		       " with %s file %B"),
+		    (_("RL78 ABI conflict: G10 file %pB cannot be linked"
+		       " with %s file %pB"),
 		     ibfd, rl78_cpu_name (out_cpu), obfd);
 		}
 	      else
@@ -1216,7 +1216,7 @@ rl78_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("RL78 ABI conflict: cannot link %s file %B with %s file %B"),
+		(_("RL78 ABI conflict: cannot link %s file %pB with %s file %pB"),
 		 rl78_cpu_name (in_cpu),  ibfd,
 		 rl78_cpu_name (out_cpu), obfd);
 	    }
@@ -1229,11 +1229,11 @@ rl78_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
 	  if (old_flags & E_FLAG_RL78_64BIT_DOUBLES)
 	    /* xgettext:c-format */
-	    _bfd_error_handler (_("- %B is 64-bit, %B is not"),
+	    _bfd_error_handler (_("- %pB is 64-bit, %pB is not"),
 				obfd, ibfd);
 	  else
 	    /* xgettext:c-format */
-	    _bfd_error_handler (_("- %B is 64-bit, %B is not"),
+	    _bfd_error_handler (_("- %pB is 64-bit, %pB is not"),
 				ibfd, obfd);
 	  error = TRUE;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/elf32-rx.c b/sdcc/support/sdbinutils/bfd/elf32-rx.c
index a0e1f7822..93eb79c1d 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-rx.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-rx.c
@@ -311,7 +311,7 @@ rx_info_to_howto_rela (bfd *		   abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_RX_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid RX reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid RX reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = rx_elf_howto_table + r_type;
@@ -592,14 +592,14 @@ rx_elf_relocate_section
 	  if (table_end_cache <= entry_vma || entry_vma < table_start_cache)
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B:%A: table entry %s outside table"),
+	      _bfd_error_handler (_("%pB:%pA: table entry %s outside table"),
 				  input_bfd, input_section,
 				  name);
 	    }
 	  else if ((int) (entry_vma - table_start_cache) % 4)
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B:%A: table entry %s not word-aligned within table"),
+	      _bfd_error_handler (_("%pB:%pA: table entry %s not word-aligned within table"),
 				  input_bfd, input_section,
 				  name);
 	    }
@@ -665,7 +665,7 @@ rx_elf_relocate_section
 #define OP(i)      (contents[rel->r_offset + (i)])
 #define WARN_REDHAT(type) \
       /* xgettext:c-format */ \
-      _bfd_error_handler (_("%B:%A: Warning: deprecated Red Hat reloc " type " detected against: %s."), \
+      _bfd_error_handler (_("%pB:%pA: Warning: deprecated Red Hat reloc " type " detected against: %s."), \
       input_bfd, input_section, name)
 
       /* Check for unsafe relocs in PID mode.  These are any relocs where
@@ -684,7 +684,7 @@ rx_elf_relocate_section
 	  && strcmp (name, "__romdatastart") != 0			\
 	  && !saw_subtract)						\
 	/* xgettext:c-format */						\
-	_bfd_error_handler (_("%B(%A): unsafe PID relocation %s at %#Lx (against %s in %s)"), \
+	_bfd_error_handler (_("%pB(%pA): unsafe PID relocation %s at %#Lx (against %s in %s)"), \
 			    input_bfd, input_section, howto->name,	\
 			    input_section->output_section->vma + input_section->output_offset + rel->r_offset, \
 			    name, sec->name);				\
@@ -1432,7 +1432,7 @@ rx_elf_relocate_section
 		 and emit a more helpful error message.  */
 	      if (r_type == R_RX_DIR24S_PCREL)
 		/* xgettext:c-format */
-		msg = _("%B(%A): error: call to undefined function '%s'");
+		msg = _("%pB(%pA): error: call to undefined function '%s'");
 	      else
 		(*info->callbacks->reloc_overflow)
 		  (info, (h ? &h->root : NULL), name, howto->name, (bfd_vma) 0,
@@ -1446,27 +1446,27 @@ rx_elf_relocate_section
 
 	    case bfd_reloc_other:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): warning: unaligned access to symbol '%s' in the small data area");
+	      msg = _("%pB(%pA): warning: unaligned access to symbol '%s' in the small data area");
 	      break;
 
 	    case bfd_reloc_outofrange:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: out of range error");
+	      msg = _("%pB(%pA): internal error: out of range error");
 	      break;
 
 	    case bfd_reloc_notsupported:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: unsupported relocation error");
+	      msg = _("%pB(%pA): internal error: unsupported relocation error");
 	      break;
 
 	    case bfd_reloc_dangerous:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: dangerous relocation");
+	      msg = _("%pB(%pA): internal error: dangerous relocation");
 	      break;
 
 	    default:
 	      /* xgettext:c-format */
-	      msg = _("%B(%A): internal error: unknown error");
+	      msg = _("%pB(%pA): internal error: unknown error");
 	      break;
 	    }
 
@@ -3144,7 +3144,7 @@ rx_elf_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)
 	  else
 	    {
 	      _bfd_error_handler (_("There is a conflict merging the"
-				    " ELF header flags from %B"),
+				    " ELF header flags from %pB"),
 				  ibfd);
 	      _bfd_error_handler (_("  the input  file's flags: %s"),
 				  describe_flags (new_flags));
@@ -3755,7 +3755,7 @@ rx_table_find (struct bfd_hash_entry *vent, void *vinfo)
 	     && h->type != bfd_link_hash_defweak))
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B:%A: table %s missing corresponding %s"),
+      _bfd_error_handler (_("%pB:%pA: table %s missing corresponding %s"),
 			  abfd, sec, name, buf);
       return TRUE;
     }
@@ -3763,7 +3763,7 @@ rx_table_find (struct bfd_hash_entry *vent, void *vinfo)
   if (h->u.def.section != ent->u.def.section)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B:%A: %s and %s must be in the same input section"),
+      _bfd_error_handler (_("%pB:%pA: %s and %s must be in the same input section"),
 			  h->u.def.section->owner, h->u.def.section,
 			  name, buf);
       return TRUE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-s390.c b/sdcc/support/sdbinutils/bfd/elf32-s390.c
index c5e75814d..f82b227ab 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-s390.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-s390.c
@@ -343,7 +343,7 @@ elf_s390_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
       if (r_type >= sizeof (elf_howto_table) / sizeof (elf_howto_table[0]))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid relocation type %d"),
+	  _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			      abfd, (int) r_type);
 	  r_type = R_390_NONE;
 	}
@@ -953,7 +953,7 @@ elf_s390_check_relocs (bfd *abfd,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  return FALSE;
 	}
@@ -1181,7 +1181,7 @@ elf_s390_check_relocs (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: `%s' accessed both as normal and thread local symbol"),
+		    (_("%pB: `%s' accessed both as normal and thread local symbol"),
 		     abfd, h->root.root.string);
 		  return FALSE;
 		}
@@ -1848,7 +1848,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2134,7 +2134,7 @@ invalid_tls_insn (bfd *input_bfd,
   howto = elf_howto_table + ELF32_R_TYPE (rel->r_info);
   _bfd_error_handler
     /* xgettext:c-format */
-    (_("%B(%A+%#Lx): invalid instruction for TLS relocation %s"),
+    (_("%pB(%pA+%#Lx): invalid instruction for TLS relocation %s"),
      input_bfd,
      input_section,
      rel->r_offset,
@@ -3201,7 +3201,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 				      rel->r_offset) != (bfd_vma) -1)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	  (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	   input_bfd,
 	   input_section,
 	   rel->r_offset,
@@ -3258,7 +3258,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): reloc against `%s': error %d"),
+		(_("%pB(%pA+%#Lx): reloc against `%s': error %d"),
 		 input_bfd, input_section,
 		 rel->r_offset, name, (int) r);
 	      return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-score.c b/sdcc/support/sdbinutils/bfd/elf32-score.c
index 897ab8a3f..d4f0c8453 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-score.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-score.c
@@ -2822,7 +2822,7 @@ s3_bfd_score_elf_check_relocs (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: Malformed reloc detected for section %A"), abfd, sec);
+	    (_("%pB: Malformed reloc detected for section %pA"), abfd, sec);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
@@ -2876,7 +2876,7 @@ s3_bfd_score_elf_check_relocs (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: CALL15 reloc at %#Lx not against global symbol"),
+		(_("%pB: CALL15 reloc at %#Lx not against global symbol"),
 		 abfd, rel->r_offset);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -4045,7 +4045,7 @@ s3_elf32_score_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
   if (((in_flags & EF_SCORE_PIC) != 0) != ((out_flags & EF_SCORE_PIC) != 0))
     _bfd_error_handler
-      (_("%B: warning: linking PIC files with non-PIC files"), ibfd);
+      (_("%pB: warning: linking PIC files with non-PIC files"), ibfd);
 
   /* FIXME: Maybe dependency fix compatibility should be checked here.  */
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-score7.c b/sdcc/support/sdbinutils/bfd/elf32-score7.c
index 2b803e672..dbfef32c9 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-score7.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-score7.c
@@ -2627,7 +2627,7 @@ s7_bfd_score_elf_check_relocs (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: Malformed reloc detected for section %A"), abfd, sec);
+	    (_("%pB: Malformed reloc detected for section %pA"), abfd, sec);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
@@ -2681,7 +2681,7 @@ s7_bfd_score_elf_check_relocs (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: CALL15 reloc at %#Lx not against global symbol"),
+		(_("%pB: CALL15 reloc at %#Lx not against global symbol"),
 		 abfd, rel->r_offset);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -3850,7 +3850,7 @@ s7_elf32_score_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
   if (((in_flags & EF_SCORE_PIC) != 0) != ((out_flags & EF_SCORE_PIC) != 0))
     {
-      _bfd_error_handler (_("%B: warning: linking PIC files with non-PIC files"), ibfd);
+      _bfd_error_handler (_("%pB: warning: linking PIC files with non-PIC files"), ibfd);
     }
 
   /* Maybe dependency fix compatibility should be checked here.  */
diff --git a/sdcc/support/sdbinutils/bfd/elf32-sh-symbian.c b/sdcc/support/sdbinutils/bfd/elf32-sh-symbian.c
index 9abfd739b..625cca2cc 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-sh-symbian.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-sh-symbian.c
@@ -127,7 +127,7 @@ sh_symbian_import_as (struct bfd_link_info *info, bfd * abfd,
 
 	bfd_set_error (bfd_error_invalid_operation);
 	/* xgettext:c-format */
-	_bfd_error_handler (_("%B: IMPORT AS directive for %s conceals previous IMPORT AS"),
+	_bfd_error_handler (_("%pB: IMPORT AS directive for %s conceals previous IMPORT AS"),
 			    abfd, current_name);
 	return FALSE;
       }
@@ -381,7 +381,7 @@ sh_symbian_process_embedded_commands (struct bfd_link_info *info, bfd * abfd,
 
 	  bfd_set_error (bfd_error_invalid_operation);
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: Unrecognised .directive command: %s"),
+	  _bfd_error_handler (_("%pB: Unrecognised .directive command: %s"),
 			      abfd, directive);
 	  break;
 	}
@@ -499,7 +499,7 @@ sh_symbian_relocate_section (bfd *		    output_bfd,
 	  if (new_hash == NULL)
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B: Failed to add renamed symbol %s"),
+	      _bfd_error_handler (_("%pB: Failed to add renamed symbol %s"),
 				  input_bfd, ptr->new_name);
 	      continue;
 	    }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-sh.c b/sdcc/support/sdbinutils/bfd/elf32-sh.c
index b4854a2ce..5c80ab4bc 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-sh.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-sh.c
@@ -488,7 +488,7 @@ sh_elf_info_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
       || (r >= R_SH_FIRST_INVALID_RELOC_6 && r <= R_SH_LAST_INVALID_RELOC_6))
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised SH reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised SH reloc number: %d"),
 			  abfd, r);
       bfd_set_error (bfd_error_bad_value);
       r = R_SH_NONE;
@@ -577,7 +577,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
       if (laddr >= sec->size)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: %#Lx: warning: bad R_SH_USES offset"),
+	  _bfd_error_handler (_("%pB: %#Lx: warning: bad R_SH_USES offset"),
 			      abfd, irel->r_offset);
 	  continue;
 	}
@@ -589,7 +589,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: %#Lx: warning: R_SH_USES points to unrecognized insn 0x%x"),
+	    (_("%pB: %#Lx: warning: R_SH_USES points to unrecognized insn 0x%x"),
 	     abfd, irel->r_offset, insn);
 	  continue;
 	}
@@ -607,7 +607,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: %#Lx: warning: bad R_SH_USES load offset"),
+	    (_("%pB: %#Lx: warning: bad R_SH_USES load offset"),
 	     abfd, irel->r_offset);
 	  continue;
 	}
@@ -623,7 +623,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: %#Lx: warning: could not find expected reloc"),
+	    (_("%pB: %#Lx: warning: could not find expected reloc"),
 	     abfd, paddr);
 	  continue;
 	}
@@ -652,7 +652,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: warning: symbol in unexpected section"),
+		(_("%pB: %#Lx: warning: symbol in unexpected section"),
 		 abfd, paddr);
 	      continue;
 	    }
@@ -782,7 +782,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: %#Lx: warning: could not find expected COUNT reloc"),
+	    (_("%pB: %#Lx: warning: could not find expected COUNT reloc"),
 	     abfd, paddr);
 	  continue;
 	}
@@ -792,7 +792,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
       if (irelcount->r_addend == 0)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: %#Lx: warning: bad count"),
+	  _bfd_error_handler (_("%pB: %#Lx: warning: bad count"),
 			      abfd, paddr);
 	  continue;
 	}
@@ -1196,7 +1196,7 @@ sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: fatal: reloc overflow while relaxing"),
+		(_("%pB: %#Lx: fatal: reloc overflow while relaxing"),
 		 abfd, irel->r_offset);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -1567,7 +1567,7 @@ sh_elf_swap_insns (bfd *abfd, asection *sec, void *relocs,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: fatal: reloc overflow while relaxing"),
+		(_("%pB: %#Lx: fatal: reloc overflow while relaxing"),
 		 abfd, irel->r_offset);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -3286,7 +3286,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -3389,7 +3389,7 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
 		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
 		    {
 		      info->flags |= DF_TEXTREL;
-		      info->callbacks->minfo (_("%B: dynamic relocation in read-only section `%A'\n"),
+		      info->callbacks->minfo (_("%pB: dynamic relocation in read-only section `%pA'\n"),
 					      p->sec->owner, p->sec);
 		    }
 
@@ -4000,7 +4000,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A+%#Lx): %s relocation against SEC_MERGE section"),
+		    (_("%pB(%pA+%#Lx): %s relocation against SEC_MERGE section"),
 		     input_bfd, input_section,
 		     rel->r_offset, howto->name);
 		  return FALSE;
@@ -4118,7 +4118,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+		    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 		     input_bfd,
 		     input_section,
 		     rel->r_offset,
@@ -4197,7 +4197,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: fatal: unaligned branch target for relax-support relocation"),
+		    (_("%pB: %#Lx: fatal: unaligned branch target for relax-support relocation"),
 		     input_section->owner,
 		     rel->r_offset);
 		  bfd_set_error (bfd_error_bad_value);
@@ -4231,7 +4231,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: fatal: unaligned %s relocation %#Lx"),
+		(_("%pB: %#Lx: fatal: unaligned %s relocation %#Lx"),
 		 input_section->owner,
 		 rel->r_offset, howto->name,
 		 relocation);
@@ -4247,7 +4247,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: fatal: unaligned %s relocation %#Lx"),
+		(_("%pB: %#Lx: fatal: unaligned %s relocation %#Lx"),
 		 input_section->owner,
 		 rel->r_offset, howto->name,
 		 relocation);
@@ -4262,7 +4262,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: fatal: R_SH_PSHA relocation %Ld not in range -32..32"),
+		(_("%pB: %#Lx: fatal: R_SH_PSHA relocation %Ld not in range -32..32"),
 		 input_section->owner,
 		 rel->r_offset,
 		 relocation);
@@ -4277,7 +4277,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: %#Lx: fatal: R_SH_PSHL relocation %Ld not in range -32..32"),
+		(_("%pB: %#Lx: fatal: R_SH_PSHL relocation %Ld not in range -32..32"),
 		 input_section->owner,
 		 rel->r_offset,
 		 relocation);
@@ -4423,7 +4423,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B(%A+%#Lx): cannot emit fixup to `%s' in read-only section"),
+		      (_("%pB(%pA+%#Lx): cannot emit fixup to `%s' in read-only section"),
 		       input_bfd,
 		       input_section,
 		       rel->r_offset,
@@ -4896,7 +4896,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B(%A+%#Lx): cannot emit fixup to `%s' in read-only section"),
+		      (_("%pB(%pA+%#Lx): cannot emit fixup to `%s' in read-only section"),
 		       input_bfd,
 		       input_section,
 		       rel->r_offset,
@@ -4998,7 +4998,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): %s relocation against external symbol \"%s\""),
+		(_("%pB(%pA+%#Lx): %s relocation against external symbol \"%s\""),
 		 input_bfd, input_section, rel->r_offset, howto->name,
 		 h->root.root.string);
 	      return FALSE;
@@ -6043,18 +6043,18 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
 		      && (old_got_type == GOT_NORMAL || got_type == GOT_NORMAL))
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and FDPIC symbol"),
+		      (_("%pB: `%s' accessed both as normal and FDPIC symbol"),
 		       abfd, h->root.root.string);
 		  else if (old_got_type == GOT_FUNCDESC
 			   || got_type == GOT_FUNCDESC)
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as FDPIC and thread local symbol"),
+		      (_("%pB: `%s' accessed both as FDPIC and thread local symbol"),
 		       abfd, h->root.root.string);
 		  else
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and thread local symbol"),
+		      (_("%pB: `%s' accessed both as normal and thread local symbol"),
 		       abfd, h->root.root.string);
 		  return FALSE;
 		}
@@ -6080,7 +6080,7 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
 	  if (rel->r_addend)
 	    {
 	      _bfd_error_handler
-		(_("%B: Function descriptor relocation with non-zero addend"),
+		(_("%pB: Function descriptor relocation with non-zero addend"),
 		 abfd);
 	      return FALSE;
 	    }
@@ -6129,12 +6129,12 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
 		  if (old_got_type == GOT_NORMAL)
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and FDPIC symbol"),
+		      (_("%pB: `%s' accessed both as normal and FDPIC symbol"),
 		       abfd, h->root.root.string);
 		  else
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as FDPIC and thread local symbol"),
+		      (_("%pB: `%s' accessed both as FDPIC and thread local symbol"),
 		       abfd, h->root.root.string);
 		}
 	    }
@@ -6318,7 +6318,7 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
 	  if (bfd_link_dll (info))
 	    {
 	      _bfd_error_handler
-		(_("%B: TLS local exec code cannot be linked into shared objects"),
+		(_("%pB: TLS local exec code cannot be linked into shared objects"),
 		 abfd);
 	      return FALSE;
 	    }
@@ -6433,7 +6433,7 @@ sh_merge_bfd_arch (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: uses %s instructions while previous modules "
+	(_("%pB: uses %s instructions while previous modules "
 	   "use %s instructions"),
 	 ibfd,
 	 SH_ARCH_SET_HAS_DSP (new_arch) ? "dsp" : "floating point",
@@ -6482,7 +6482,7 @@ sh_elf_merge_private_data (bfd *ibfd, struct bfd_link_info *info)
 
   if (! sh_merge_bfd_arch (ibfd, info))
     {
-      _bfd_error_handler (_("%B: uses instructions which are incompatible "
+      _bfd_error_handler (_("%pB: uses instructions which are incompatible "
 			    "with instructions used in previous modules"),
 			  ibfd);
       bfd_set_error (bfd_error_bad_value);
@@ -6495,7 +6495,7 @@ sh_elf_merge_private_data (bfd *ibfd, struct bfd_link_info *info)
 
   if (fdpic_object_p (ibfd) != fdpic_object_p (obfd))
     {
-      _bfd_error_handler (_("%B: attempt to mix FDPIC and non-FDPIC objects"),
+      _bfd_error_handler (_("%pB: attempt to mix FDPIC and non-FDPIC objects"),
 			  ibfd);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-sh64.c b/sdcc/support/sdbinutils/bfd/elf32-sh64.c
index 51eca0bbc..1870072b6 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-sh64.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-sh64.c
@@ -222,14 +222,14 @@ sh64_elf_merge_private_data (bfd *ibfd, struct bfd_link_info *info)
       if (bfd_get_arch_size (ibfd) == 32
 	  && bfd_get_arch_size (obfd) == 64)
 	/* xgettext:c-format */
-	msg = _("%B: compiled as 32-bit object and %B is 64-bit");
+	msg = _("%pB: compiled as 32-bit object and %pB is 64-bit");
       else if (bfd_get_arch_size (ibfd) == 64
 	       && bfd_get_arch_size (obfd) == 32)
 	/* xgettext:c-format */
-	msg = _("%B: compiled as 64-bit object and %B is 32-bit");
+	msg = _("%pB: compiled as 64-bit object and %pB is 32-bit");
       else
 	/* xgettext:c-format */
-	msg = _("%B: object size does not match that of target %B");
+	msg = _("%pB: object size does not match that of target %pB");
 
       _bfd_error_handler (msg, ibfd, obfd);
       bfd_set_error (bfd_error_wrong_format);
@@ -248,7 +248,7 @@ sh64_elf_merge_private_data (bfd *ibfd, struct bfd_link_info *info)
   else if ((new_flags & EF_SH_MACH_MASK) != EF_SH5)
     {
       _bfd_error_handler
-	("%B: uses non-SH64 instructions while previous modules"
+	("%pB: uses non-SH64 instructions while previous modules"
 	 " use SH64 instructions",
 	 ibfd);
       bfd_set_error (bfd_error_bad_value);
@@ -452,7 +452,7 @@ sh64_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 	{
 	  /* Make sure we don't get confused on invalid input.  */
 	  _bfd_error_handler
-	    (_("%B: encountered datalabel symbol in input"), abfd);
+	    (_("%pB: encountered datalabel symbol in input"), abfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
@@ -547,7 +547,7 @@ shmedia_prepare_reloc (struct bfd_link_info *info, bfd *abfd,
 	    if ((insn & SHMEDIA_PTB_BIT) != 0)
 	      {
 		_bfd_error_handler
-		  (_("%B: GAS error: unexpected PTB insn with R_SH_PT_16"),
+		  (_("%pB: GAS error: unexpected PTB insn with R_SH_PT_16"),
 		   input_section->owner);
 		return FALSE;
 	      }
@@ -597,7 +597,7 @@ shmedia_prepare_reloc (struct bfd_link_info *info, bfd *abfd,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: error: unaligned relocation type %d at %#Lx reloc %#Lx"),
+	(_("%pB: error: unaligned relocation type %d at %#Lx reloc %#Lx"),
 	 input_section->owner, (int) ELF32_R_TYPE (rel->r_info),
 	 rel->r_offset, *relocation);
       return FALSE;
@@ -673,7 +673,7 @@ sh64_elf_final_write_processing (bfd *abfd,
 	{
 	  bfd_set_error (bfd_error_file_truncated);
 	  _bfd_error_handler
-	    (_("%B: could not write out added .cranges entries"), abfd);
+	    (_("%pB: could not write out added .cranges entries"), abfd);
 	}
     }
 
@@ -732,7 +732,7 @@ sh64_elf_final_write_processing (bfd *abfd,
 	    {
 	      bfd_set_error (bfd_error_file_truncated);
 	      _bfd_error_handler
-		(_("%B: could not write out sorted .cranges entries"), abfd);
+		(_("%pB: could not write out sorted .cranges entries"), abfd);
 	    }
 	}
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-sparc.c b/sdcc/support/sdbinutils/bfd/elf32-sparc.c
index e8ca810d4..1a18e1ea0 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-sparc.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-sparc.c
@@ -86,7 +86,7 @@ elf32_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       error = TRUE;
       _bfd_error_handler
-	(_("%B: compiled for a 64 bit system and target is 32 bit"), ibfd);
+	(_("%pB: compiled for a 64 bit system and target is 32 bit"), ibfd);
     }
   else if ((ibfd->flags & DYNAMIC) == 0)
     {
@@ -99,7 +99,7 @@ elf32_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       && previous_ibfd_e_flags != (unsigned long) -1)
     {
       _bfd_error_handler
-	(_("%B: linking little endian files with big endian files"), ibfd);
+	(_("%pB: linking little endian files with big endian files"), ibfd);
       error = TRUE;
     }
   previous_ibfd_e_flags = elf_elfheader (ibfd)->e_flags & EF_SPARC_LEDATA;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-spu.c b/sdcc/support/sdbinutils/bfd/elf32-spu.c
index 941ae58ee..62afc6940 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-spu.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-spu.c
@@ -157,7 +157,7 @@ spu_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= R_SPU_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised SPU reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised SPU reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_SPU_NONE;
@@ -723,7 +723,7 @@ spu_elf_find_overlays (struct bfd_link_info *info)
 
 	      if ((s->vma - vma_start) & (htab->params->line_size - 1))
 		{
-		  info->callbacks->einfo (_("%X%P: overlay section %A "
+		  info->callbacks->einfo (_("%X%P: overlay section %pA "
 					    "does not start on a cache line.\n"),
 					  s);
 		  bfd_set_error (bfd_error_bad_value);
@@ -731,7 +731,7 @@ spu_elf_find_overlays (struct bfd_link_info *info)
 		}
 	      else if (s->size > htab->params->line_size)
 		{
-		  info->callbacks->einfo (_("%X%P: overlay section %A "
+		  info->callbacks->einfo (_("%X%P: overlay section %pA "
 					    "is larger than a cache line.\n"),
 					  s);
 		  bfd_set_error (bfd_error_bad_value);
@@ -751,7 +751,7 @@ spu_elf_find_overlays (struct bfd_link_info *info)
 	  s = alloc_sec[i];
 	  if (s->vma < ovl_end)
 	    {
-	      info->callbacks->einfo (_("%X%P: overlay section %A "
+	      info->callbacks->einfo (_("%X%P: overlay section %pA "
 					"is not in cache area.\n"),
 				      alloc_sec[i-1]);
 	      bfd_set_error (bfd_error_bad_value);
@@ -792,8 +792,8 @@ spu_elf_find_overlays (struct bfd_link_info *info)
 		  if (s0->vma != s->vma)
 		    {
 		      /* xgettext:c-format */
-		      info->callbacks->einfo (_("%X%P: overlay sections %A "
-						"and %A do not start at the "
+		      info->callbacks->einfo (_("%X%P: overlay sections %pA "
+						"and %pA do not start at the "
 						"same address.\n"),
 					      s0, s);
 		      bfd_set_error (bfd_error_bad_value);
@@ -1018,7 +1018,7 @@ needs_ovl_stub (struct elf_link_hash_entry *h,
 		}
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("warning: call to non-function symbol %s defined in %B"),
+		(_("warning: call to non-function symbol %s defined in %pB"),
 		 sym_name, sym_sec->owner);
 
 	    }
@@ -1368,7 +1368,7 @@ build_stub (struct bfd_link_info *info,
 	  if (stub_type != br000_ovl_stub
 	      && lrlive != stub_type - br000_ovl_stub)
 	    /* xgettext:c-format */
-	    info->callbacks->einfo (_("%A:0x%v lrlive .brinfo (%u) differs "
+	    info->callbacks->einfo (_("%pA:0x%v lrlive .brinfo (%u) differs "
 				      "from analysis (%u)\n"),
 				    isec, irela->r_offset, lrlive,
 				    stub_type - br000_ovl_stub);
@@ -1900,7 +1900,7 @@ define_ovtab_symbol (struct spu_link_hash_table *htab, const char *name)
   else if (h->root.u.def.section->owner != NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B is not allowed to define %s"),
+      _bfd_error_handler (_("%pB is not allowed to define %s"),
 			  h->root.u.def.section->owner,
 			  h->root.root.string);
       bfd_set_error (bfd_error_bad_value);
@@ -2611,7 +2611,7 @@ find_function (asection *sec, bfd_vma offset, struct bfd_link_info *info)
 	return &sinfo->fun[mid];
     }
   /* xgettext:c-format */
-  info->callbacks->einfo (_("%A:0x%v not found in function table\n"),
+  info->callbacks->einfo (_("%pA:0x%v not found in function table\n"),
 			  sec, offset);
   bfd_set_error (bfd_error_bad_value);
   return NULL;
@@ -2752,8 +2752,8 @@ mark_functions_via_relocs (asection *sec,
 		  if (!warned)
 		    info->callbacks->einfo
 		      /* xgettext:c-format */
-		      (_("%B(%A+0x%v): call to non-code section"
-			 " %B(%A), analysis incomplete\n"),
+		      (_("%pB(%pA+0x%v): call to non-code section"
+			 " %pB(%pA), analysis incomplete\n"),
 		       sec->owner, sec, irela->r_offset,
 		       sym_sec->owner, sym_sec);
 		  warned = TRUE;
@@ -4541,7 +4541,7 @@ spu_elf_auto_overlay (struct bfd_link_info *info)
       if (i == base)
 	{
 	  /* xgettext:c-format */
-	  info->callbacks->einfo (_("%B:%A%s exceeds overlay size\n"),
+	  info->callbacks->einfo (_("%pB:%pA%s exceeds overlay size\n"),
 				  ovly_sections[2 * i]->owner,
 				  ovly_sections[2 * i],
 				  ovly_sections[2 * i + 1] ? " + rodata" : "");
@@ -5040,7 +5040,7 @@ spu_elf_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%s+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%s+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd,
 	     bfd_get_section_name (input_bfd, input_section),
 	     rel->r_offset,
diff --git a/sdcc/support/sdbinutils/bfd/elf32-tic6x.c b/sdcc/support/sdbinutils/bfd/elf32-tic6x.c
index 758b6a810..04be4b386 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-tic6x.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-tic6x.c
@@ -2457,7 +2457,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 	    }
 	  else
 	    {
-	      _bfd_error_handler (_("%B: SB-relative relocation but "
+	      _bfd_error_handler (_("%pB: SB-relative relocation but "
 				    "__c6xabi_DSBT_BASE not defined"),
 				  input_bfd);
 	      ok = FALSE;
@@ -2567,7 +2567,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 	      if (h == NULL)
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B, section %A: relocation %s with non-zero addend %Ld"
+		  (_("%pB, section %pA: relocation %s with non-zero addend %Ld"
 		     " against local symbol"),
 		   input_bfd,
 		   input_section,
@@ -2576,7 +2576,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 	      else
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B, section %A: relocation %s with non-zero addend %Ld"
+		  (_("%pB, section %pA: relocation %s with non-zero addend %Ld"
 		     " against symbol `%s'"),
 		   input_bfd,
 		   input_section,
@@ -2606,7 +2606,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 	default:
 	  /* Unknown relocation.  */
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid relocation type %d"),
+	  _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			      input_bfd, r_type);
 	  ok = FALSE;
 	  continue;
@@ -2746,7 +2746,7 @@ elf32_tic6x_check_relocs (bfd *abfd, struct bfd_link_info *info,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  return FALSE;
 	}
@@ -3202,7 +3202,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -3579,7 +3579,7 @@ elf32_tic6x_obj_attrs_handle_unknown (bfd *abfd, int tag)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: error: unknown mandatory EABI object attribute %d"),
+	(_("%pB: error: unknown mandatory EABI object attribute %d"),
 	 abfd, tag);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -3588,7 +3588,7 @@ elf32_tic6x_obj_attrs_handle_unknown (bfd *abfd, int tag)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: warning: unknown EABI object attribute %d"),
+	(_("%pB: warning: unknown EABI object attribute %d"),
 	 abfd, tag);
       return TRUE;
     }
@@ -3702,7 +3702,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B requires more stack alignment than %B preserves"),
+	(_("error: %pB requires more stack alignment than %pB preserves"),
 	 ibfd, obfd);
       result = FALSE;
     }
@@ -3711,7 +3711,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B requires more stack alignment than %B preserves"),
+	(_("error: %pB requires more stack alignment than %pB preserves"),
 	 obfd, ibfd);
       result = FALSE;
     }
@@ -3721,7 +3721,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
   if (array_align_in == -1)
     {
       _bfd_error_handler
-	(_("error: unknown Tag_ABI_array_object_alignment value in %B"),
+	(_("error: unknown Tag_ABI_array_object_alignment value in %pB"),
 	 ibfd);
       result = FALSE;
     }
@@ -3730,7 +3730,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
   if (array_align_out == -1)
     {
       _bfd_error_handler
-	(_("error: unknown Tag_ABI_array_object_alignment value in %B"),
+	(_("error: unknown Tag_ABI_array_object_alignment value in %pB"),
 	 obfd);
       result = FALSE;
     }
@@ -3739,7 +3739,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
   if (array_expect_in == -1)
     {
       _bfd_error_handler
-	(_("error: unknown Tag_ABI_array_object_align_expected value in %B"),
+	(_("error: unknown Tag_ABI_array_object_align_expected value in %pB"),
 	 ibfd);
       result = FALSE;
     }
@@ -3748,7 +3748,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
   if (array_expect_out == -1)
     {
       _bfd_error_handler
-	(_("error: unknown Tag_ABI_array_object_align_expected value in %B"),
+	(_("error: unknown Tag_ABI_array_object_align_expected value in %pB"),
 	 obfd);
       result = FALSE;
     }
@@ -3757,7 +3757,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B requires more array alignment than %B preserves"),
+	(_("error: %pB requires more array alignment than %pB preserves"),
 	 ibfd, obfd);
       result = FALSE;
     }
@@ -3765,7 +3765,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("error: %B requires more array alignment than %B preserves"),
+	(_("error: %pB requires more array alignment than %pB preserves"),
 	 obfd, ibfd);
       result = FALSE;
     }
@@ -3788,7 +3788,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("warning: %B and %B differ in wchar_t size"), obfd, ibfd);
+		(_("warning: %pB and %pB differ in wchar_t size"), obfd, ibfd);
 	    }
 	  break;
 
@@ -3807,7 +3807,7 @@ elf32_tic6x_merge_attributes (bfd *ibfd, struct bfd_link_info *info)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("warning: %B and %B differ in whether code is "
+		(_("warning: %pB and %pB differ in whether code is "
 		   "compiled for DSBT"),
 		 obfd, ibfd);
 	    }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-tilepro.c b/sdcc/support/sdbinutils/bfd/elf32-tilepro.c
index 96ba98dad..e5f93ddfa 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-tilepro.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-tilepro.c
@@ -1468,7 +1468,7 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  return FALSE;
 	}
@@ -1581,7 +1581,7 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and thread local symbol"),
+		      (_("%pB: `%s' accessed both as normal and thread local symbol"),
 		       abfd, h ? h->root.root.string : "<local>");
 		    return FALSE;
 		  }
@@ -2234,7 +2234,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2328,7 +2328,7 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,
 		    {
 		      info->flags |= DF_TEXTREL;
 
-		      info->callbacks->minfo (_("%B: dynamic relocation in read-only section `%A'\n"),
+		      info->callbacks->minfo (_("%pB: dynamic relocation in read-only section `%pA'\n"),
 					      p->sec->owner, p->sec);
 		    }
 		}
@@ -3144,7 +3144,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 			    {
 			      BFD_FAIL ();
 			      _bfd_error_handler
-				(_("%B: probably compiled without -fPIC?"),
+				(_("%pB: probably compiled without -fPIC?"),
 				 input_bfd);
 			      bfd_set_error (bfd_error_bad_value);
 			      return FALSE;
@@ -3398,7 +3398,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 				      rel->r_offset) != (bfd_vma) -1)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	  (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	   input_bfd,
 	   input_section,
 	   rel->r_offset,
@@ -3749,7 +3749,7 @@ tilepro_elf_finish_dynamic_sections (bfd *output_bfd,
       if (bfd_is_abs_section (htab->elf.sgotplt->output_section))
 	{
 	  _bfd_error_handler
-	    (_("discarded output section: `%A'"), htab->elf.sgotplt);
+	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
 	  return FALSE;
 	}
 
diff --git a/sdcc/support/sdbinutils/bfd/elf32-v850.c b/sdcc/support/sdbinutils/bfd/elf32-v850.c
index 99c060afc..5fb373209 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-v850.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-v850.c
@@ -61,7 +61,7 @@ v850_elf_check_relocs (bfd *abfd,
     return TRUE;
 
 #ifdef DEBUG
-  _bfd_error_handler ("v850_elf_check_relocs called for section %A in %B",
+  _bfd_error_handler ("v850_elf_check_relocs called for section %pA in %pB",
 		      sec, abfd);
 #endif
 
@@ -490,7 +490,7 @@ v850_elf_perform_relocation (bfd *abfd,
     {
     default:
 #ifdef DEBUG
-      fprintf (stderr, "%B: reloc number %d not recognised\n", abfd, r_type);
+      fprintf (stderr, "%pB: reloc number %d not recognised\n", abfd, r_type);
 #endif
       return bfd_reloc_notsupported;
 
@@ -1895,7 +1895,7 @@ v850_elf_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_V850_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid V850 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid V850 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &v850_elf_howto_table[r_type];
@@ -1914,7 +1914,7 @@ v850_elf_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_V850_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid V850 reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid V850 reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &v850_elf_howto_table[r_type];
@@ -2145,7 +2145,7 @@ v850_elf_final_link_relocate (reloc_howto_type *howto,
 
     default:
 #ifdef DEBUG
-      fprintf (stderr, "%B: reloc number %d not recognised\n", input_bfd, r_type);
+      fprintf (stderr, "%pB: reloc number %d not recognised\n", input_bfd, r_type);
 #endif
       return bfd_reloc_notsupported;
     }
@@ -2521,7 +2521,7 @@ v850_elf_merge_notes (bfd * ibfd, bfd *obfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("error: %B needs 8-byte alignment but %B is set for 4-byte alignment"),
+		    (_("error: %pB needs 8-byte alignment but %pB is set for 4-byte alignment"),
 				      ibfd, obfd);
 		  result = FALSE;
 		}
@@ -2537,8 +2537,8 @@ v850_elf_merge_notes (bfd * ibfd, bfd *obfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("error: %B uses 64-bit doubles but "
-		       "%B uses 32-bit doubles"), ibfd, obfd);
+		    (_("error: %pB uses 64-bit doubles but "
+		       "%pB uses 32-bit doubles"), ibfd, obfd);
 		  result = FALSE;
 		}
 	      else
@@ -2552,7 +2552,7 @@ v850_elf_merge_notes (bfd * ibfd, bfd *obfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("error: %B uses FPU-3.0 but %B only supports FPU-2.0"),
+		    (_("error: %pB uses FPU-3.0 but %pB only supports FPU-2.0"),
 		     ibfd, obfd);
 		  result = FALSE;
 		}
@@ -2809,7 +2809,7 @@ v850_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       if ((in_flags & EF_V800_850E3) != (out_flags & EF_V800_850E3))
 	{
 	  _bfd_error_handler
-	    (_("%B: Architecture mismatch with previous modules"), ibfd);
+	    (_("%pB: Architecture mismatch with previous modules"), ibfd);
 	  elf_elfheader (obfd)->e_flags |= EF_V800_850E3;
 	}
 
@@ -2865,7 +2865,7 @@ v850_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	}
 
       _bfd_error_handler
-	(_("%B: Architecture mismatch with previous modules"), ibfd);
+	(_("%pB: Architecture mismatch with previous modules"), ibfd);
     }
 
   return result;
@@ -3598,7 +3598,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGCALL points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGCALL points to "
 		       "unrecognized insns"),
 		     abfd, irel->r_offset);
 		  continue;
@@ -3608,7 +3608,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGCALL points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGCALL points to "
 		       "unrecognized insn %#x"),
 		     abfd,
 		     irel->r_offset + no_match,
@@ -3653,7 +3653,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGCALL points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGCALL points to "
 		       "unrecognized reloc"),
 		     abfd, irel->r_offset);
 
@@ -3693,7 +3693,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGCALL points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGCALL points to "
 		       "unrecognized reloc %#Lx"),
 		     abfd, irel->r_offset,
 		     irelcall->r_offset);
@@ -3836,7 +3836,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGJUMP points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGJUMP points to "
 		       "unrecognized insns"),
 		     abfd, irel->r_offset);
 		  continue;
@@ -3846,7 +3846,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGJUMP points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGJUMP points to "
 		       "unrecognized insn %#x"),
 		     abfd,
 		     irel->r_offset + no_match,
@@ -3880,7 +3880,7 @@ v850_elf_relax_section (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: %#Lx: warning: R_V850_LONGJUMP points to "
+		    (_("%pB: %#Lx: warning: R_V850_LONGJUMP points to "
 		       "unrecognized reloc"),
 		     abfd, irel->r_offset);
 		  continue;
diff --git a/sdcc/support/sdbinutils/bfd/elf32-vax.c b/sdcc/support/sdbinutils/bfd/elf32-vax.c
index 54364ed0e..773e06dff 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-vax.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-vax.c
@@ -287,7 +287,7 @@ rtype_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
   if (r_type >= R_VAX_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised VAX reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised VAX reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_VAX_NONE;
@@ -628,7 +628,7 @@ elf_vax_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
 		  if (eh->got_addend != (bfd_vma) rel->r_addend)
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: warning: GOT addend of %Ld to `%s' does"
+		      (_("%pB: warning: GOT addend of %Ld to `%s' does"
 			 " not match previous GOT addend of %Ld"),
 			 abfd, rel->r_addend, h->root.root.string,
 			 eh->got_addend);
@@ -1442,8 +1442,8 @@ elf_vax_relocate_section (bfd *output_bfd,
 	  else if (rel->r_addend != 0)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: warning: PLT addend of %Ld to `%s'"
-		 " from %A section ignored"),
+	      (_("%pB: warning: PLT addend of %Ld to `%s'"
+		 " from %pA section ignored"),
 	       input_bfd, rel->r_addend, h->root.root.string, input_section);
 	  rel->r_addend = 0;
 
@@ -1567,14 +1567,14 @@ elf_vax_relocate_section (bfd *output_bfd,
 		  if (h != NULL)
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: warning: %s relocation against symbol `%s'"
-			 " from %A section"),
+		      (_("%pB: warning: %s relocation against symbol `%s'"
+			 " from %pA section"),
 		      input_bfd, howto->name, h->root.root.string,
 		      input_section);
 		  else
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: warning: %s relocation to %#Lx from %A section"),
+		      (_("%pB: warning: %s relocation to %#Lx from %pA section"),
 		      input_bfd, howto->name, outrel.r_addend,
 		      input_section);
 		}
diff --git a/sdcc/support/sdbinutils/bfd/elf32-visium.c b/sdcc/support/sdbinutils/bfd/elf32-visium.c
index 45f3337d4..18c5f751c 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-visium.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-visium.c
@@ -478,7 +478,7 @@ visium_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
       if (r_type >= (unsigned int) R_VISIUM_max)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid Visium reloc number: %d"), abfd, r_type);
+	  _bfd_error_handler (_("%pB: invalid Visium reloc number: %d"), abfd, r_type);
 	  r_type = 0;
 	}
       cache_ptr->howto = &visium_elf_howto_table[r_type];
@@ -814,7 +814,7 @@ visium_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       if (mismatch)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: compiled %s -mtune=%s and linked with modules"
+	  (_("%pB: compiled %s -mtune=%s and linked with modules"
 	     " compiled %s -mtune=%s"),
 	   ibfd, new_opt_with, opt_arch, old_opt_with, opt_arch);
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-wasm32.c b/sdcc/support/sdbinutils/bfd/elf32-wasm32.c
index 5205bef60..501dca843 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-wasm32.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-wasm32.c
@@ -103,7 +103,7 @@ elf32_wasm32_rtype_to_howto (bfd *abfd, unsigned r_type)
   if (i >= ARRAY_SIZE (elf32_wasm32_howto_table))
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid relocation type %d"),
+      _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			  abfd, (int) r_type);
       i = R_WASM32_NONE;
     }
diff --git a/sdcc/support/sdbinutils/bfd/elf32-xgate.c b/sdcc/support/sdbinutils/bfd/elf32-xgate.c
index 5a93b5e85..1395af4a6 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-xgate.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-xgate.c
@@ -425,7 +425,7 @@ xgate_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_XGATE_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid XGate reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid XGate reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_xgate_howto_table[r_type];
diff --git a/sdcc/support/sdbinutils/bfd/elf32-xtensa.c b/sdcc/support/sdbinutils/bfd/elf32-xtensa.c
index b3a7467b7..18e446ec3 100644
--- a/sdcc/support/sdbinutils/bfd/elf32-xtensa.c
+++ b/sdcc/support/sdbinutils/bfd/elf32-xtensa.c
@@ -482,7 +482,7 @@ elf_xtensa_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_XTENSA_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid XTENSA reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid XTENSA reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_howto_table[r_type];
@@ -923,7 +923,7 @@ xtensa_read_table_entries (bfd *abfd,
 	      blocks[blk - 1].size != 0)
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B(%A): invalid property table"),
+	      _bfd_error_handler (_("%pB(%pA): invalid property table"),
 				  abfd, section);
 	      bfd_set_error (bfd_error_bad_value);
 	      free (blocks);
@@ -1015,7 +1015,7 @@ elf_xtensa_check_relocs (bfd *abfd,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  return FALSE;
 	}
@@ -1189,7 +1189,7 @@ elf_xtensa_check_relocs (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: `%s' accessed both as normal and thread local symbol"),
+		(_("%pB: `%s' accessed both as normal and thread local symbol"),
 		 abfd,
 		 h ? h->root.root.string : "<local>");
 	      return FALSE;
@@ -2652,7 +2652,7 @@ elf_xtensa_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): relocation offset out of range (size=%#Lx)"),
+	    (_("%pB(%pA+%#Lx): relocation offset out of range (size=%#Lx)"),
 	     input_bfd, input_section, rel->r_offset, input_size);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -2678,9 +2678,9 @@ elf_xtensa_relocate_section (bfd *output_bfd,
 	  _bfd_error_handler
 	    ((sym_type == STT_TLS
 	      /* xgettext:c-format */
-	      ? _("%B(%A+%#Lx): %s used with TLS symbol %s")
+	      ? _("%pB(%pA+%#Lx): %s used with TLS symbol %s")
 	      /* xgettext:c-format */
-	      : _("%B(%A+%#Lx): %s used with non-TLS symbol %s")),
+	      : _("%pB(%pA+%#Lx): %s used with non-TLS symbol %s")),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -2936,7 +2936,7 @@ elf_xtensa_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -3347,7 +3347,7 @@ elf_xtensa_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: incompatible machine type. Output is 0x%x. Input is 0x%x"),
+	(_("%pB: incompatible machine type. Output is 0x%x. Input is 0x%x"),
 	 ibfd, out_mach, in_mach);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
@@ -6414,7 +6414,7 @@ extend_ebb_bounds_forward (ebb_t *ebb)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): could not decode instruction; "
+	    (_("%pB(%pA+%#Lx): could not decode instruction; "
 	       "possible configuration mismatch"),
 	     ebb->sec->owner, ebb->sec, ebb->end_offset + insn_block_len);
 	  return FALSE;
@@ -6492,7 +6492,7 @@ extend_ebb_bounds_backward (ebb_t *ebb)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): could not decode instruction; "
+	    (_("%pB(%pA+%#Lx): could not decode instruction; "
 	       "possible configuration mismatch"),
 	     ebb->sec->owner, ebb->sec, ebb->end_offset + insn_block_len);
 	  return FALSE;
@@ -7607,7 +7607,7 @@ compute_text_actions (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): could not decode instruction for "
+	    (_("%pB(%pA+%#Lx): could not decode instruction for "
 	       "XTENSA_ASM_SIMPLIFY relocation; "
 	       "possible configuration mismatch"),
 	     sec->owner, sec, r_offset);
@@ -7868,7 +7868,7 @@ compute_ebb_proposed_actions (ebb_constraint *ebb_table)
  decode_error:
   _bfd_error_handler
     /* xgettext:c-format */
-    (_("%B(%A+%#Lx): could not decode instruction; "
+    (_("%pB(%pA+%#Lx): could not decode instruction; "
        "possible configuration mismatch"),
      ebb->sec->owner, ebb->sec, offset);
   return FALSE;
@@ -10646,7 +10646,7 @@ do_fix_for_relocatable_link (Elf_Internal_Rela *rel,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unexpected fix for %s relocation"),
+	    (_("%pB(%pA+%#Lx): unexpected fix for %s relocation"),
 	     input_bfd, input_section, rel->r_offset,
 	     elf_howto_table[r_type].name);
 	  return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf64-alpha.c b/sdcc/support/sdbinutils/bfd/elf64-alpha.c
index db4001cce..0dd5fce14 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-alpha.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-alpha.c
@@ -1109,7 +1109,7 @@ elf64_alpha_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
   if (r_type >= R_ALPHA_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: unrecognised Alpha reloc number: %d"),
+      _bfd_error_handler (_("%pB: unrecognised Alpha reloc number: %d"),
 			  abfd, r_type);
       bfd_set_error (bfd_error_bad_value);
       r_type = R_ALPHA_NONE;
@@ -2459,7 +2459,7 @@ elf64_alpha_size_got_sections (struct bfd_link_info *info,
 	      /* Yikes! A single object file has too many entries.  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: .got subsegment exceeds 64K (size %d)"),
+		(_("%pB: .got subsegment exceeds 64K (size %d)"),
 		 i, alpha_elf_tdata (this_got)->total_got_size);
 	      return FALSE;
 	    }
@@ -3014,7 +3014,7 @@ elf64_alpha_relax_got_load (struct alpha_relax_info *info, bfd_vma symval,
       reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: %A+%#Lx: warning: %s relocation against unexpected insn"),
+	(_("%pB: %pA+%#Lx: warning: %s relocation against unexpected insn"),
 	 info->abfd, info->sec, irel->r_offset, howto->name);
       return TRUE;
     }
@@ -3209,7 +3209,7 @@ elf64_alpha_relax_with_lituse (struct alpha_relax_info *info,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: %A+%#Lx: warning: LITERAL relocation against unexpected insn"),
+	(_("%pB: %pA+%#Lx: warning: LITERAL relocation against unexpected insn"),
 	 abfd, info->sec, irel->r_offset);
       return TRUE;
     }
@@ -4095,7 +4095,7 @@ elf64_alpha_relocate_section_r (bfd *output_bfd ATTRIBUTE_UNUSED,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: unknown relocation type %d"),
+	    (_("%pB: unknown relocation type %d"),
 	     input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret_val = FALSE;
@@ -4243,7 +4243,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: unknown relocation type %d"),
+	    (_("%pB: unknown relocation type %d"),
 	     input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret_val = FALSE;
@@ -4409,7 +4409,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: gp-relative relocation against dynamic symbol %s"),
+		(_("%pB: gp-relative relocation against dynamic symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
@@ -4422,7 +4422,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: gp-relative relocation against dynamic symbol %s"),
+		(_("%pB: gp-relative relocation against dynamic symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
@@ -4449,7 +4449,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: pc-relative relocation against dynamic symbol %s"),
+		(_("%pB: pc-relative relocation against dynamic symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
@@ -4478,7 +4478,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	      {
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: change in gp: BRSGP %s"),
+		  (_("%pB: change in gp: BRSGP %s"),
 		   input_bfd, h->root.root.root.string);
 		ret_val = FALSE;
 	      }
@@ -4509,7 +4509,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		  }
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: !samegp reloc against symbol without .prologue: %s"),
+		  (_("%pB: !samegp reloc against symbol without .prologue: %s"),
 		   input_bfd, name);
 		ret_val = FALSE;
 		break;
@@ -4567,7 +4567,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: unhandled dynamic relocation against %s"),
+		      (_("%pB: unhandled dynamic relocation against %s"),
 		       input_bfd,
 		       h->root.root.root.string);
 		    ret_val = FALSE;
@@ -4593,7 +4593,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: pc-relative relocation against dynamic symbol %s"),
+		(_("%pB: pc-relative relocation against dynamic symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
@@ -4602,7 +4602,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: pc-relative relocation against undefined weak symbol %s"),
+		(_("%pB: pc-relative relocation against undefined weak symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
@@ -4668,7 +4668,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: dtp-relative relocation against dynamic symbol %s"),
+		(_("%pB: dtp-relative relocation against dynamic symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
@@ -4685,7 +4685,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: TLS local exec code cannot be linked into shared objects"),
+		(_("%pB: TLS local exec code cannot be linked into shared objects"),
 		input_bfd);
 	      ret_val = FALSE;
 	    }
@@ -4693,7 +4693,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: tp-relative relocation against dynamic symbol %s"),
+		(_("%pB: tp-relative relocation against dynamic symbol %s"),
 		 input_bfd, h->root.root.root.string);
 	      ret_val = FALSE;
 	    }
diff --git a/sdcc/support/sdbinutils/bfd/elf64-gen.c b/sdcc/support/sdbinutils/bfd/elf64-gen.c
index 46bb32bf0..2dbc1dd11 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-gen.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-gen.c
@@ -66,7 +66,7 @@ check_for_relocs (bfd * abfd, asection * o, void * failed)
 
       ehdrp = elf_elfheader (abfd);
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Relocations in generic ELF (EM: %d)"),
+      _bfd_error_handler (_("%pB: Relocations in generic ELF (EM: %d)"),
 			  abfd, ehdrp->e_machine);
 
       bfd_set_error (bfd_error_wrong_format);
diff --git a/sdcc/support/sdbinutils/bfd/elf64-hppa.c b/sdcc/support/sdbinutils/bfd/elf64-hppa.c
index ff96a8cfb..20c9eb818 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-hppa.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-hppa.c
@@ -3283,7 +3283,7 @@ elf_hppa_final_link_relocate (Elf_Internal_Rela *rel,
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B(%A+%#Lx): cannot reach %s"),
+	      (_("%pB(%pA+%#Lx): cannot reach %s"),
 	      input_bfd,
 	      input_section,
 	      offset,
diff --git a/sdcc/support/sdbinutils/bfd/elf64-ia64-vms.c b/sdcc/support/sdbinutils/bfd/elf64-ia64-vms.c
index 0fab317bf..fd2e107e5 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-ia64-vms.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-ia64-vms.c
@@ -584,7 +584,7 @@ elf64_ia64_relax_section (bfd *abfd, asection *sec,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: Can't relax br at %#Lx in section `%A'."
+		(_("%pB: Can't relax br at %#Lx in section `%pA'."
 		   " Please use brl or indirect branch."),
 		 sec->owner, roff, sec);
 	      bfd_set_error (bfd_error_bad_value);
@@ -3278,7 +3278,7 @@ elf64_ia64_choose_gp (bfd *abfd, struct bfd_link_info *info, bfd_boolean final)
 overflow:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: short data segment overflowed (%#Lx >= 0x400000)"),
+	    (_("%pB: short data segment overflowed (%#Lx >= 0x400000)"),
 	     abfd, max_short_vma - min_short_vma);
 	  return FALSE;
 	}
@@ -3288,7 +3288,7 @@ overflow:
 		   && max_short_vma - gp_val >= 0x200000))
 	{
 	  _bfd_error_handler
-	    (_("%B: __gp does not cover short data segment"), abfd);
+	    (_("%pB: __gp does not cover short data segment"), abfd);
 	  return FALSE;
 	}
     }
@@ -3427,7 +3427,7 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: unknown relocation type %d"),
+	    (_("%pB: unknown relocation type %d"),
 	     input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret_val = FALSE;
@@ -3554,7 +3554,7 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 		     shared libraries nor dynamic executables.  */
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: non-pic code with imm relocation against"
+		    (_("%pB: non-pic code with imm relocation against"
 		       " dynamic symbol `%s'"),
 		     input_bfd,
 		     h ? h->root.root.string
@@ -3618,7 +3618,7 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: @gprel relocation against dynamic symbol %s"),
+		(_("%pB: @gprel relocation against dynamic symbol %s"),
 		 input_bfd,
 		 h ? h->root.root.string
 		   : bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
@@ -3677,7 +3677,7 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 		      /* ??? People shouldn't be doing non-pic code in
 			 shared libraries.  Hork.  */
 		      _bfd_error_handler
-			(_("%B: linking non-pic code in a position independent executable"),
+			(_("%pB: linking non-pic code in a position independent executable"),
 			 input_bfd);
 		      ret_val = FALSE;
 		      continue;
@@ -3779,13 +3779,13 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 
 	      if (r_type == R_IA64_PCREL21BI)
 		/* xgettext:c-format */
-		msg = _("%B: @internal branch to dynamic symbol %s");
+		msg = _("%pB: @internal branch to dynamic symbol %s");
 	      else if (r_type == R_IA64_PCREL21F || r_type == R_IA64_PCREL21M)
 		/* xgettext:c-format */
-		msg = _("%B: speculation fixup to dynamic symbol %s");
+		msg = _("%pB: speculation fixup to dynamic symbol %s");
 	      else
 		/* xgettext:c-format */
-		msg = _("%B: @pcrel relocation against dynamic symbol %s");
+		msg = _("%pB: @pcrel relocation against dynamic symbol %s");
 	      _bfd_error_handler (msg, input_bfd,
 				  h ? h->root.root.string
 				  : bfd_elf_sym_name (input_bfd,
@@ -3946,8 +3946,8 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 	      case R_IA64_LTOFF_DTPREL22:
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: missing TLS section for relocation %s against `%s'"
-		     " at %#Lx in section `%A'."),
+		  (_("%pB: missing TLS section for relocation %s against `%s'"
+		     " at %#Lx in section `%pA'."),
 		   input_bfd, howto->name, name,
 		   rel->r_offset, input_section);
 		break;
@@ -3963,8 +3963,8 @@ elf64_ia64_relocate_section (bfd *output_bfd,
 		       that the section is too big to relax.  */
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: Can't relax br (%s) to `%s' at %#Lx in section"
-			 " `%A' with size %#Lx (> 0x1000000)."),
+		      (_("%pB: Can't relax br (%s) to `%s' at %#Lx in section"
+			 " `%pA' with size %#Lx (> 0x1000000)."),
 		       input_bfd, howto->name, name, rel->r_offset,
 		       input_section, input_section->size);
 		    break;
@@ -4254,7 +4254,7 @@ elf64_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_TRAPNIL) != (out_flags & EF_IA_64_TRAPNIL))
     {
       _bfd_error_handler
-	(_("%B: linking trap-on-NULL-dereference with non-trapping files"),
+	(_("%pB: linking trap-on-NULL-dereference with non-trapping files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4263,7 +4263,7 @@ elf64_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_BE) != (out_flags & EF_IA_64_BE))
     {
       _bfd_error_handler
-	(_("%B: linking big-endian files with little-endian files"),
+	(_("%pB: linking big-endian files with little-endian files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4272,7 +4272,7 @@ elf64_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_ABI64) != (out_flags & EF_IA_64_ABI64))
     {
       _bfd_error_handler
-	(_("%B: linking 64-bit files with 32-bit files"),
+	(_("%pB: linking 64-bit files with 32-bit files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4281,7 +4281,7 @@ elf64_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_CONS_GP) != (out_flags & EF_IA_64_CONS_GP))
     {
       _bfd_error_handler
-	(_("%B: linking constant-gp files with non-constant-gp files"),
+	(_("%pB: linking constant-gp files with non-constant-gp files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4291,7 +4291,7 @@ elf64_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       != (out_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
     {
       _bfd_error_handler
-	(_("%B: linking auto-pic files with non-auto-pic files"),
+	(_("%pB: linking auto-pic files with non-auto-pic files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -5134,15 +5134,15 @@ error_free_dyn:
 		  if (normal_bfd == NULL)
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("Warning: alignment %u of common symbol `%s' in %B"
-			 " is greater than the alignment (%u) of its section %A"),
+		      (_("Warning: alignment %u of common symbol `%s' in %pB"
+			 " is greater than the alignment (%u) of its section %pA"),
 		       1 << common_align, name, common_bfd,
 		       1 << normal_align, h->root.u.def.section);
 		  else
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("Warning: alignment %u of symbol `%s' in %B"
-			 " is smaller than %u in %B"),
+		      (_("Warning: alignment %u of symbol `%s' in %pB"
+			 " is smaller than %u in %pB"),
 		       1 << normal_align, name, normal_bfd,
 		       1 << common_align, common_bfd);
 		}
@@ -5158,7 +5158,7 @@ error_free_dyn:
 		_bfd_error_handler
 		  /* xgettext:c-format */
 		  (_("Warning: size of symbol `%s' changed"
-		     " from %Lu in %B to %Lu in %B"),
+		     " from %Lu in %pB to %Lu in %pB"),
 		   name, h->size, old_bfd, isym->st_size, abfd);
 
 	      h->size = isym->st_size;
@@ -5184,7 +5184,7 @@ error_free_dyn:
 		    _bfd_error_handler
 		      /* xgettext:c-format */
 		      (_("Warning: type of symbol `%s' changed"
-			 " from %d to %d in %B"),
+			 " from %d to %d in %pB"),
 		       name, h->type, type, abfd);
 
 		  h->type = type;
diff --git a/sdcc/support/sdbinutils/bfd/elf64-mmix.c b/sdcc/support/sdbinutils/bfd/elf64-mmix.c
index 16930c1f5..4516f318d 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-mmix.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-mmix.c
@@ -1192,7 +1192,7 @@ mmix_elf_perform_relocation (asection *isec, reloc_howto_type *howto,
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: Internal inconsistency error for value for\n\
+	      (_("%pB: Internal inconsistency error for value for\n\
  linker-allocated global register: linked: %#Lx != relaxed: %#Lx"),
 	       isec->owner,
 	       value,
@@ -1261,7 +1261,7 @@ mmix_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
   if (r_type >= (unsigned int) R_MMIX_max)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid MMIX reloc number: %d"), abfd, r_type);
+      _bfd_error_handler (_("%pB: invalid MMIX reloc number: %d"), abfd, r_type);
       r_type = 0;
     }
   cache_ptr->howto = &elf_mmix_howto_table[r_type];
@@ -1613,14 +1613,14 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,
 	  if (symname == NULL || *symname == 0)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: base-plus-offset relocation against register symbol:"
-		 " (unknown) in %A"),
+	      (_("%pB: base-plus-offset relocation against register symbol:"
+		 " (unknown) in %pA"),
 	       input_section->owner, symsec);
 	  else
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: base-plus-offset relocation against register symbol:"
-		 " %s in %A"),
+	      (_("%pB: base-plus-offset relocation against register symbol:"
+		 " %s in %pA"),
 	       input_section->owner, symname, symsec);
 	  return bfd_reloc_overflow;
 	}
@@ -1664,14 +1664,14 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,
 	  if (symname == NULL || *symname == 0)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: register relocation against non-register symbol:"
-		 " (unknown) in %A"),
+	      (_("%pB: register relocation against non-register symbol:"
+		 " (unknown) in %pA"),
 	       input_section->owner, symsec);
 	  else
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: register relocation against non-register symbol:"
-		 " %s in %A"),
+	      (_("%pB: register relocation against non-register symbol:"
+		 " %s in %pA"),
 	       input_section->owner, symname, symsec);
 
 	  /* The bfd_reloc_outofrange return value, though intuitively a
@@ -1707,7 +1707,7 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,
 		       MMIX_REG_SECTION_NAME) != 0)
 	{
 	  _bfd_error_handler
-	    (_("%B: directive LOCAL valid only with a register or absolute value"),
+	    (_("%pB: directive LOCAL valid only with a register or absolute value"),
 	     input_section->owner);
 
 	  return bfd_reloc_overflow;
@@ -1738,7 +1738,7 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,
 	    /* FIXME: Better error message.  */
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: LOCAL directive: Register $%Ld is not a local register."
+	      (_("%pB: LOCAL directive: Register $%Ld is not a local register."
 		 "  First global register is $%Ld."),
 	       input_section->owner, srel, first_global);
 
@@ -2166,7 +2166,7 @@ mmix_elf_add_symbol_hook (bfd *abfd,
 	     h->u.def.section->owner is NULL.  */
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: Error: multiple definition of `%s'; start of %s "
+	    (_("%pB: Error: multiple definition of `%s'; start of %s "
 	       "is set in a earlier linked file\n"),
 	     abfd, *namep,
 	     *namep + strlen (MMIX_LOC_SECTION_START_SYMBOL_PREFIX));
diff --git a/sdcc/support/sdbinutils/bfd/elf64-ppc.c b/sdcc/support/sdbinutils/bfd/elf64-ppc.c
index 5cbb03553..f35a0ab8d 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-ppc.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-ppc.c
@@ -2519,7 +2519,7 @@ ppc64_elf_info_to_howto (bfd *abfd, arelent *cache_ptr,
   if (type >= ARRAY_SIZE (ppc64_elf_howto_table))
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: invalid relocation type %d"),
+      _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			  abfd, (int) type);
       type = R_PPC64_NONE;
     }
@@ -4652,7 +4652,7 @@ ppc_add_stub (const char *stub_name,
   if (stub_entry == NULL)
     {
       /* xgettext:c-format */
-      info->callbacks->einfo (_("%P: %B: cannot create stub entry %s\n"),
+      info->callbacks->einfo (_("%P: %pB: cannot create stub entry %s\n"),
 			      section->owner, stub_name);
       return NULL;
     }
@@ -5158,7 +5158,7 @@ ppc64_elf_before_check_relocs (bfd *ibfd, struct bfd_link_info *info)
       else if (abiversion (ibfd) >= 2)
 	{
 	  /* xgettext:c-format */
-	  info->callbacks->einfo (_("%P: %B .opd not allowed in ABI"
+	  info->callbacks->einfo (_("%P: %pB .opd not allowed in ABI"
 				    " version %d\n"),
 				  ibfd, abiversion (ibfd));
 	  bfd_set_error (bfd_error_bad_value);
@@ -6047,7 +6047,7 @@ ppc64_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B uses unknown e_flags 0x%lx"), ibfd, iflags);
+	(_("%pB uses unknown e_flags 0x%lx"), ibfd, iflags);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
     }
@@ -6055,7 +6055,7 @@ ppc64_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: ABI version %ld is not compatible with ABI version %ld output"),
+	(_("%pB: ABI version %ld is not compatible with ABI version %ld output"),
 	 ibfd, iflags, oflags);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -7534,7 +7534,7 @@ tocsave_find (struct ppc_link_hash_table *htab,
   if (ent.sec == NULL || ent.sec->output_section == NULL)
     {
       _bfd_error_handler
-	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"), ibfd);
+	(_("%pB: undefined symbol on R_PPC64_TOCSAVE relocation"), ibfd);
       return NULL;
     }
 
@@ -7761,7 +7761,7 @@ dec_dynrel_count (bfd_vma r_info,
     }
 
   /* xgettext:c-format */
-  info->callbacks->einfo (_("%P: dynreloc miscount for %B, section %A\n"),
+  info->callbacks->einfo (_("%P: dynreloc miscount for %pB, section %pA\n"),
 			  sec->owner, sec);
   bfd_set_error (bfd_error_bad_value);
   return FALSE;
@@ -7850,7 +7850,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
 		 optimization for them!  */
 	    broken_opd:
 	      _bfd_error_handler
-		(_("%B: .opd is not a regular array of opd entries"), ibfd);
+		(_("%pB: .opd is not a regular array of opd entries"), ibfd);
 	      broken = TRUE;
 	      break;
 	    }
@@ -7860,7 +7860,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: unexpected reloc type %u in .opd section"),
+		(_("%pB: unexpected reloc type %u in .opd section"),
 		 ibfd, r_type);
 	      broken = TRUE;
 	      break;
@@ -7882,7 +7882,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
 
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: undefined sym `%s' in .opd section"),
+		(_("%pB: undefined sym `%s' in .opd section"),
 		 ibfd, sym_name);
 	      broken = TRUE;
 	      break;
@@ -9940,7 +9940,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -12169,7 +12169,7 @@ group_sections (struct bfd_link_info *info,
 	  big_sec = total > group_size;
 	  if (big_sec && !suppress_size_errors)
 	    /* xgettext:c-format */
-	    _bfd_error_handler (_("%B section %A exceeds stub group size"),
+	    _bfd_error_handler (_("%pB section %pA exceeds stub group size"),
 				tail->owner, tail);
 	  curr_toc = htab->sec_info[tail->id].toc_off;
 
@@ -14394,7 +14394,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	default:
 	  info->callbacks->einfo
 	    /* xgettext:c-format */
-	    (_("%P: %B: unknown relocation type %d for `%T'\n"),
+	    (_("%P: %pB: unknown relocation type %d for `%T'\n"),
 	     input_bfd, (int) r_type, sym_name);
 
 	  bfd_set_error (bfd_error_bad_value);
@@ -15055,7 +15055,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 
 	  info->callbacks->einfo
 	    /* xgettext:c-format */
-	    (_("%P: %B: %s is not supported for `%T'\n"),
+	    (_("%P: %pB: %s is not supported for `%T'\n"),
 	     input_bfd,
 	     ppc64_elf_howto_table[r_type]->name, sym_name);
 
diff --git a/sdcc/support/sdbinutils/bfd/elf64-s390.c b/sdcc/support/sdbinutils/bfd/elf64-s390.c
index 754997146..22e81d4cc 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-s390.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-s390.c
@@ -370,7 +370,7 @@ elf_s390_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
       if (r_type >= sizeof (elf_howto_table) / sizeof (elf_howto_table[0]))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid relocation type %d"),
+	  _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			      abfd, (int) r_type);
 	  r_type = R_390_NONE;
 	}
@@ -872,7 +872,7 @@ elf_s390_check_relocs (bfd *abfd,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  return FALSE;
 	}
@@ -1110,7 +1110,7 @@ elf_s390_check_relocs (bfd *abfd,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: `%s' accessed both as normal and thread local symbol"),
+		    (_("%pB: `%s' accessed both as normal and thread local symbol"),
 		     abfd, h->root.root.string);
 		  return FALSE;
 		}
@@ -1782,7 +1782,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2072,7 +2072,7 @@ invalid_tls_insn (bfd *input_bfd,
   howto = elf_howto_table + ELF64_R_TYPE (rel->r_info);
   _bfd_error_handler
     /* xgettext:c-format */
-    (_("%B(%A+%#Lx): invalid instruction for TLS relocation %s"),
+    (_("%pB(%pA+%#Lx): invalid instruction for TLS relocation %s"),
      input_bfd,
      input_section,
      rel->r_offset,
@@ -2530,7 +2530,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 	      && bfd_link_pie (info)
 	      && !h->def_regular)
 	    {
-	      _bfd_error_handler (_("%B: `%s' non-PLT reloc for symbol defined "
+	      _bfd_error_handler (_("%pB: `%s' non-PLT reloc for symbol defined "
 				    "in shared library and accessed "
 				    "from executable "
 				    "(rebuild file with -fPIC ?)"),
@@ -3115,7 +3115,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 				      rel->r_offset) != (bfd_vma) -1)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	  (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	   input_bfd,
 	   input_section,
 	   rel->r_offset,
@@ -3172,7 +3172,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): reloc against `%s': error %d"),
+		(_("%pB(%pA+%#Lx): reloc against `%s': error %d"),
 		 input_bfd, input_section,
 		 rel->r_offset, name, (int) r);
 	      return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elf64-sh64.c b/sdcc/support/sdbinutils/bfd/elf64-sh64.c
index 8a41764ff..7c993b74f 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-sh64.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-sh64.c
@@ -1536,7 +1536,7 @@ sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A+%#Lx): %s relocation against SEC_MERGE section"),
+		    (_("%pB(%pA+%#Lx): %s relocation against SEC_MERGE section"),
 		     input_bfd, input_section,
 		     rel->r_offset, howto->name);
 		  return FALSE;
@@ -1633,7 +1633,7 @@ sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+		    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 		     input_bfd,
 		     input_section,
 		     rel->r_offset,
@@ -1677,7 +1677,7 @@ sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: error: unaligned relocation type %d at %08Lx reloc %08Lx"),
+	    (_("%pB: error: unaligned relocation type %d at %08Lx reloc %08Lx"),
 	     input_bfd, (int) r_type, rel->r_offset,
 	     relocation);
 	  bfd_set_error (bfd_error_bad_value);
@@ -2274,14 +2274,14 @@ sh_elf64_merge_private_data (bfd *ibfd, struct bfd_link_info *info)
       if (bfd_get_arch_size (ibfd) == 32
 	  && bfd_get_arch_size (obfd) == 64)
 	/* xgettext:c-format */
-	msg = _("%B: compiled as 32-bit object and %B is 64-bit");
+	msg = _("%pB: compiled as 32-bit object and %pB is 64-bit");
       else if (bfd_get_arch_size (ibfd) == 64
 	       && bfd_get_arch_size (obfd) == 32)
 	/* xgettext:c-format */
-	msg = _("%B: compiled as 64-bit object and %B is 32-bit");
+	msg = _("%pB: compiled as 64-bit object and %pB is 32-bit");
       else
 	/* xgettext:c-format */
-	msg = _("%B: object size does not match that of target %B");
+	msg = _("%pB: object size does not match that of target %pB");
 
       _bfd_error_handler (msg, ibfd, obfd);
       bfd_set_error (bfd_error_wrong_format);
@@ -2302,7 +2302,7 @@ sh_elf64_merge_private_data (bfd *ibfd, struct bfd_link_info *info)
   else if ((new_flags & EF_SH_MACH_MASK) != EF_SH5)
     {
       _bfd_error_handler
-	("%B: does not use the SH64 64-bit ABI as previous modules do", ibfd);
+	("%pB: does not use the SH64 64-bit ABI as previous modules do", ibfd);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
     }
@@ -2769,7 +2769,7 @@ sh64_elf64_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 	{
 	  /* Make sure we don't get confused on invalid input.  */
 	  _bfd_error_handler
-	    (_("%B: encountered datalabel symbol in input"), abfd);
+	    (_("%pB: encountered datalabel symbol in input"), abfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/elf64-sparc.c b/sdcc/support/sdbinutils/bfd/elf64-sparc.c
index 089636fb5..a9671e29b 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-sparc.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-sparc.c
@@ -457,7 +457,7 @@ elf64_sparc_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 	case 6: reg -= 4; break;
 	default:
 	  _bfd_error_handler
-	    (_("%B: Only registers %%g[2367] can be declared using STT_REGISTER"),
+	    (_("%pB: Only registers %%g[2367] can be declared using STT_REGISTER"),
 	     abfd);
 	  return FALSE;
 	}
@@ -478,8 +478,8 @@ elf64_sparc_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("Register %%g%d used incompatibly: %s in %B,"
-	       " previously %s in %B"),
+	    (_("Register %%g%d used incompatibly: %s in %pB,"
+	       " previously %s in %pB"),
 	     (int) sym->st_value, **namep ? *namep : "#scratch", abfd,
 	     *p->name ? p->name : "#scratch", p->abfd);
 	  return FALSE;
@@ -502,8 +502,8 @@ elf64_sparc_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 		    type = 0;
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("Symbol `%s' has differing types: REGISTER in %B,"
-		       " previously %s in %B"),
+		    (_("Symbol `%s' has differing types: REGISTER in %pB,"
+		       " previously %s in %pB"),
 		     *namep, abfd, stt_types[type], p->abfd);
 		  return FALSE;
 		}
@@ -549,8 +549,8 @@ elf64_sparc_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 	      type = 0;
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("Symbol `%s' has differing types: %s in %B,"
-		 " previously REGISTER in %B"),
+	      (_("Symbol `%s' has differing types: %s in %pB,"
+		 " previously REGISTER in %pB"),
 	       *namep, stt_types[type], abfd, p->abfd);
 	    return FALSE;
 	  }
@@ -704,7 +704,7 @@ elf64_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	    {
 	      error = TRUE;
 	      _bfd_error_handler
-		(_("%B: linking UltraSPARC specific with HAL specific code"),
+		(_("%pB: linking UltraSPARC specific with HAL specific code"),
 		 ibfd);
 	    }
 	  /* Choose the most restrictive memory ordering.  */
@@ -724,7 +724,7 @@ elf64_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  error = TRUE;
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: uses different e_flags (%#x) fields than previous modules (%#x)"),
+	    (_("%pB: uses different e_flags (%#x) fields than previous modules (%#x)"),
 	     ibfd, new_flags, old_flags);
 	}
 
diff --git a/sdcc/support/sdbinutils/bfd/elf64-x86-64.c b/sdcc/support/sdbinutils/bfd/elf64-x86-64.c
index ba4f47bff..8d783658f 100644
--- a/sdcc/support/sdbinutils/bfd/elf64-x86-64.c
+++ b/sdcc/support/sdbinutils/bfd/elf64-x86-64.c
@@ -282,7 +282,7 @@ elf_x86_64_rtype_to_howto (bfd *abfd, unsigned r_type)
       if (r_type >= (unsigned int) R_X86_64_standard)
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: invalid relocation type %d"),
+	  _bfd_error_handler (_("%pB: invalid relocation type %d"),
 			      abfd, (int) r_type);
 	  r_type = R_X86_64_NONE;
 	}
@@ -1332,8 +1332,8 @@ elf_x86_64_tls_transition (struct bfd_link_info *info, bfd *abfd,
 
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: TLS transition from %s to %s against `%s' at %#Lx "
-	   "in section `%A' failed"),
+	(_("%pB: TLS transition from %s to %s against `%s' at %#Lx "
+	   "in section `%pA' failed"),
 	 abfd, from->name, to->name, name, rel->r_offset, sec);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -1401,7 +1401,7 @@ elf_x86_64_need_pic (struct bfd_link_info *info,
     object = _("a PDE object");
 
   /* xgettext:c-format */
-  _bfd_error_handler (_("%B: relocation %s against %s%s`%s' can "
+  _bfd_error_handler (_("%pB: relocation %s against %s%s`%s' can "
 			"not be used when making %s%s"),
 		      input_bfd, howto->name, und, v, name,
 		      object, pic);
@@ -1820,7 +1820,7 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  goto error_return;
 	}
@@ -1886,7 +1886,7 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 					   NULL);
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: relocation %s against symbol `%s' isn't "
+		  (_("%pB: relocation %s against symbol `%s' isn't "
 		     "supported in x32 mode"), abfd,
 		   x86_64_elf_howto_table[r_type].name, name);
 		bfd_set_error (bfd_error_bad_value);
@@ -2024,7 +2024,7 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 					       isym, NULL);
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: '%s' accessed both as normal and"
+		      (_("%pB: '%s' accessed both as normal and"
 			 " thread local symbol"),
 		       abfd, name);
 		    bfd_set_error (bfd_error_bad_value);
@@ -2622,7 +2622,7 @@ bad_ifunc_reloc:
 					 NULL);
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against STT_GNU_IFUNC "
+		(_("%pB: relocation %s against STT_GNU_IFUNC "
 		   "symbol `%s' isn't supported"), input_bfd,
 		 howto->name, name);
 	      bfd_set_error (bfd_error_bad_value);
@@ -2648,7 +2648,7 @@ do_ifunc_pointer:
 					     sym, NULL);
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: relocation %s against STT_GNU_IFUNC "
+		    (_("%pB: relocation %s against STT_GNU_IFUNC "
 		       "symbol `%s' has non-zero addend: %Ld"),
 		     input_bfd, howto->name, name, rel->r_addend);
 		  bfd_set_error (bfd_error_bad_value);
@@ -2679,7 +2679,7 @@ do_ifunc_pointer:
 
 		  if (POINTER_LOCAL_IFUNC_P (info, h))
 		    {
-		      info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
+		      info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
 					      h->root.root.string,
 					      h->root.u.def.section->owner);
 
@@ -2885,7 +2885,7 @@ do_ifunc_pointer:
 
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: relocation R_X86_64_GOTOFF64 against undefined %s"
+		    (_("%pB: relocation R_X86_64_GOTOFF64 against undefined %s"
 		       " `%s' can not be used when making a shared object"),
 		     input_bfd, v, h->root.root.string);
 		  bfd_set_error (bfd_error_bad_value);
@@ -2899,7 +2899,7 @@ do_ifunc_pointer:
 		{
 		  _bfd_error_handler
 	      /* xgettext:c-format */
-		    (_("%B: relocation R_X86_64_GOTOFF64 against protected %s"
+		    (_("%pB: relocation R_X86_64_GOTOFF64 against protected %s"
 		       " `%s' can not be used when making a shared object"),
 		     input_bfd,
 		     h->type == STT_FUNC ? "function" : "data",
@@ -3150,8 +3150,8 @@ direct:
 						     sym, NULL);
 			  _bfd_error_handler
 			    /* xgettext:c-format */
-			    (_("%B: addend %s%#x in relocation %s against "
-			       "symbol `%s' at %#Lx in section `%A' is "
+			    (_("%pB: addend %s%#x in relocation %s against "
+			       "symbol `%s' at %#Lx in section `%pA' is "
 			       "out of range"),
 			     input_bfd, addend < 0 ? "-" : "", addend,
 			     howto->name, name, rel->r_offset, input_section);
@@ -3787,7 +3787,7 @@ direct:
 	    default:
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+		(_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 		 input_bfd,
 		 input_section,
 		 rel->r_offset,
@@ -3836,7 +3836,7 @@ check_relocation_error:
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B(%A+%#Lx): reloc against `%s': error %d"),
+		(_("%pB(%pA+%#Lx): reloc against `%s': error %d"),
 		 input_bfd, input_section,
 		 rel->r_offset, name, (int) r);
 	      return FALSE;
@@ -3983,7 +3983,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
       /* Check PC-relative offset overflow in PLT entry.  */
       if ((plt_got_pcrel_offset + 0x80000000) > 0xffffffff)
 	/* xgettext:c-format */
-	info->callbacks->einfo (_("%F%B: PC-relative offset overflow in PLT entry for `%s'\n"),
+	info->callbacks->einfo (_("%F%pB: PC-relative offset overflow in PLT entry for `%s'\n"),
 				output_bfd, h->root.root.string);
 
       bfd_put_32 (output_bfd, plt_got_pcrel_offset,
@@ -4009,7 +4009,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 			   + got_offset);
 	  if (PLT_LOCAL_IFUNC_P (info, h))
 	    {
-	      info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
+	      info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
 				      h->root.root.string,
 				      h->root.u.def.section->owner);
 
@@ -4046,7 +4046,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 		 will overflow first.  */
 	      if (plt0_offset > 0x80000000)
 		/* xgettext:c-format */
-		info->callbacks->einfo (_("%F%B: branch displacement overflow in PLT entry for `%s'\n"),
+		info->callbacks->einfo (_("%F%pB: branch displacement overflow in PLT entry for `%s'\n"),
 					output_bfd, h->root.root.string);
 	      bfd_put_32 (output_bfd, - plt0_offset,
 			  (plt->contents + h->plt.offset
@@ -4099,7 +4099,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
       if ((got_after_plt && got_pcrel_offset < 0)
 	  || (!got_after_plt && got_pcrel_offset > 0))
 	/* xgettext:c-format */
-	info->callbacks->einfo (_("%F%B: PC-relative offset overflow in GOT PLT entry for `%s'\n"),
+	info->callbacks->einfo (_("%F%pB: PC-relative offset overflow in GOT PLT entry for `%s'\n"),
 				output_bfd, h->root.root.string);
 
       bfd_put_32 (output_bfd, got_pcrel_offset,
@@ -4163,7 +4163,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 		}
 	      if (SYMBOL_REFERENCES_LOCAL_P (info, h))
 		{
-		  info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
+		  info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
 					  h->root.root.string,
 					  h->root.u.def.section->owner);
 
diff --git a/sdcc/support/sdbinutils/bfd/elfcode.h b/sdcc/support/sdbinutils/bfd/elfcode.h
index 00a900124..45aed50b8 100644
--- a/sdcc/support/sdbinutils/bfd/elfcode.h
+++ b/sdcc/support/sdbinutils/bfd/elfcode.h
@@ -757,7 +757,7 @@ elf_object_p (bfd *abfd)
 	     so that at least some processing can be done.  */
 	  i_ehdrp->e_shstrndx = SHN_UNDEF;
 	  _bfd_error_handler
-	    (_("warning: %B has a corrupt string table index - ignoring"),
+	    (_("warning: %pB has a corrupt string table index - ignoring"),
 	     abfd);
 	}
     }
@@ -1196,7 +1196,7 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: version count (%Ld) does not match symbol count (%ld)"),
+	    (_("%pB: version count (%Ld) does not match symbol count (%ld)"),
 	     abfd,
 	     verhdr->sh_size / sizeof (Elf_External_Versym),
 	     symcount);
@@ -1453,7 +1453,7 @@ elf_slurp_reloc_table_from_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A): relocation %d has invalid symbol index %ld"),
+	    (_("%pB(%pA): relocation %d has invalid symbol index %ld"),
 	     abfd, asect, i, (long) ELF_R_SYM (rela.r_info));
 	  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/elfcore.h b/sdcc/support/sdbinutils/bfd/elfcore.h
index 562b70889..34a18a5fe 100644
--- a/sdcc/support/sdbinutils/bfd/elfcore.h
+++ b/sdcc/support/sdbinutils/bfd/elfcore.h
@@ -297,7 +297,7 @@ elf_core_file_p (bfd *abfd)
 	  {
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("warning: %B is truncated: expected core file "
+	      (_("warning: %pB is truncated: expected core file "
 		 "size >= %Lu, found: %llu"),
 	       abfd, high, (unsigned long long) statbuf.st_size);
 	  }
diff --git a/sdcc/support/sdbinutils/bfd/elflink.c b/sdcc/support/sdbinutils/bfd/elflink.c
index e3751fa12..cdc4086c4 100644
--- a/sdcc/support/sdbinutils/bfd/elflink.c
+++ b/sdcc/support/sdbinutils/bfd/elflink.c
@@ -1350,26 +1350,26 @@ _bfd_elf_merge_symbol (bfd *abfd,
       if (tdef && ntdef)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%s: TLS definition in %B section %A "
-	     "mismatches non-TLS definition in %B section %A"),
+	  (_("%s: TLS definition in %pB section %pA "
+	     "mismatches non-TLS definition in %pB section %pA"),
 	   h->root.root.string, tbfd, tsec, ntbfd, ntsec);
       else if (!tdef && !ntdef)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%s: TLS reference in %B "
-	     "mismatches non-TLS reference in %B"),
+	  (_("%s: TLS reference in %pB "
+	     "mismatches non-TLS reference in %pB"),
 	   h->root.root.string, tbfd, ntbfd);
       else if (tdef)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%s: TLS definition in %B section %A "
-	     "mismatches non-TLS reference in %B"),
+	  (_("%s: TLS definition in %pB section %pA "
+	     "mismatches non-TLS reference in %pB"),
 	   h->root.root.string, tbfd, tsec, ntbfd);
       else
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%s: TLS reference in %B "
-	     "mismatches non-TLS definition in %B section %A"),
+	  (_("%s: TLS reference in %pB "
+	     "mismatches non-TLS definition in %pB section %pA"),
 	   h->root.root.string, tbfd, ntbfd, ntsec);
 
       bfd_set_error (bfd_error_bad_value);
@@ -2049,7 +2049,7 @@ nondefault:
 	  && hi->root.type != bfd_link_hash_defweak)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: unexpected redefinition of indirect versioned symbol `%s'"),
+	  (_("%pB: unexpected redefinition of indirect versioned symbol `%s'"),
 	   abfd, shortname);
     }
   else
@@ -2342,7 +2342,7 @@ _bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)
 	     generating a shared archive.  Return an error.  */
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: version node not found for symbol %s"),
+	    (_("%pB: version node not found for symbol %s"),
 	     info->output_bfd, h->root.root.string);
 	  bfd_set_error (bfd_error_bad_value);
 	  sinfo->failed = TRUE;
@@ -2431,8 +2431,8 @@ elf_link_read_relocs_from_section (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: bad reloc symbol index (%#Lx >= %#lx)"
-		   " for offset %#Lx in section `%A'"),
+		(_("%pB: bad reloc symbol index (%#Lx >= %#lx)"
+		   " for offset %#Lx in section `%pA'"),
 		 abfd, r_symndx, (unsigned long) nsyms,
 		 irela->r_offset, sec);
 	      bfd_set_error (bfd_error_bad_value);
@@ -2443,8 +2443,8 @@ elf_link_read_relocs_from_section (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: non-zero symbol index (%#Lx)"
-	       " for offset %#Lx in section `%A'"
+	    (_("%pB: non-zero symbol index (%#Lx)"
+	       " for offset %#Lx in section `%pA'"
 	       " when the object file has no symbol table"),
 	     abfd, r_symndx,
 	     irela->r_offset, sec);
@@ -2634,7 +2634,7 @@ _bfd_elf_link_output_relocs (bfd *output_bfd,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: relocation size mismatch in %B section %A"),
+	(_("%pB: relocation size mismatch in %pB section %pA"),
 	 output_bfd, input_section->owner, input_section);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
@@ -3815,7 +3815,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	      && ehdr->e_machine == bed->elf_machine_alt2)))
     info->callbacks->einfo
       /* xgettext:c-format */
-      (_("%P: alternate ELF machine code found (%d) in %B, expecting %d\n"),
+      (_("%P: alternate ELF machine code found (%d) in %pB, expecting %d\n"),
        ehdr->e_machine, abfd, bed->elf_machine_code);
 
   /* As a GNU extension, any input sections which are named
@@ -4481,7 +4481,7 @@ error_free_dyn:
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: %s: invalid version %u (max %d)"),
+			(_("%pB: %s: invalid version %u (max %d)"),
 			 abfd, name, vernum,
 			 elf_tdata (abfd)->cverdefs);
 		      bfd_set_error (bfd_error_bad_value);
@@ -4518,7 +4518,7 @@ error_free_dyn:
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: %s: invalid needed version %d"),
+			(_("%pB: %s: invalid needed version %d"),
 			 abfd, name, vernum);
 		      bfd_set_error (bfd_error_bad_value);
 		      goto error_free_vers;
@@ -4770,15 +4770,15 @@ error_free_dyn:
 		  if (normal_bfd == NULL)
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("Warning: alignment %u of common symbol `%s' in %B is"
-			 " greater than the alignment (%u) of its section %A"),
+		      (_("Warning: alignment %u of common symbol `%s' in %pB is"
+			 " greater than the alignment (%u) of its section %pA"),
 		       1 << common_align, name, common_bfd,
 		       1 << normal_align, h->root.u.def.section);
 		  else
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("Warning: alignment %u of symbol `%s' in %B"
-			 " is smaller than %u in %B"),
+		      (_("Warning: alignment %u of symbol `%s' in %pB"
+			 " is smaller than %u in %pB"),
 		       1 << normal_align, name, normal_bfd,
 		       1 << common_align, common_bfd);
 		}
@@ -4795,7 +4795,7 @@ error_free_dyn:
 		_bfd_error_handler
 		  /* xgettext:c-format */
 		  (_("Warning: size of symbol `%s' changed"
-		     " from %Lu in %B to %Lu in %B"),
+		     " from %Lu in %pB to %Lu in %pB"),
 		   name, h->size, old_bfd, isym->st_size, abfd);
 
 	      h->size = isym->st_size;
@@ -4829,7 +4829,7 @@ error_free_dyn:
 		    /* xgettext:c-format */
 		    _bfd_error_handler
 		      (_("Warning: type of symbol `%s' changed"
-			 " from %d to %d in %B"),
+			 " from %d to %d in %pB"),
 		       name, h->type, type, abfd);
 
 		  h->type = type;
@@ -4929,7 +4929,7 @@ error_free_dyn:
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: undefined reference to symbol '%s'"),
+		    (_("%pB: undefined reference to symbol '%s'"),
 		     old_bfd, name);
 		  bfd_set_error (bfd_error_missing_dso);
 		  goto error_free_vers;
@@ -6005,11 +6005,11 @@ bfd_elf_stack_segment_size (bfd *output_bfd,
       h->type = STT_OBJECT;
       if (info->stacksize)
 	/* xgettext:c-format */
-	_bfd_error_handler (_("%B: stack size specified and %s set"),
+	_bfd_error_handler (_("%pB: stack size specified and %s set"),
 			    output_bfd, legacy_symbol);
       else if (h->root.u.def.section != bfd_abs_section_ptr)
 	/* xgettext:c-format */
-	_bfd_error_handler (_("%B: %s not absolute"),
+	_bfd_error_handler (_("%pB: %s not absolute"),
 			    output_bfd, legacy_symbol);
       else
 	info->stacksize = h->root.u.def.value;
@@ -6777,7 +6777,7 @@ bfd_elf_size_dynamic_sections (bfd *output_bfd,
 			== SHT_PREINIT_ARRAY)
 		      {
 			_bfd_error_handler
-			  (_("%B: .preinit_array section is not allowed in DSO"),
+			  (_("%pB: .preinit_array section is not allowed in DSO"),
 			   sub);
 			break;
 		      }
@@ -8707,10 +8707,10 @@ elf_link_adjust_relocs (bfd *abfd,
 	  && ! info->gc_keep_exported)
 	{
 	  /* PR 21524: Let the user know if a symbol was removed by garbage collection.  */
-	  _bfd_error_handler (_("%B:%A: error: relocation references symbol %s which was removed by garbage collection."),
+	  _bfd_error_handler (_("%pB:%pA: error: relocation references symbol %s which was removed by garbage collection."),
 			      abfd, sec,
 			      (*rel_hash)->root.root.string);
-	  _bfd_error_handler (_("%B:%A: error: try relinking with --gc-keep-exported enabled."),
+	  _bfd_error_handler (_("%pB:%pA: error: try relinking with --gc-keep-exported enabled."),
 			      abfd, sec);
 	  bfd_set_error (bfd_error_invalid_operation);
 	  return FALSE;
@@ -8946,7 +8946,7 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
 		    /* Section size is only divisible by rela.  */
 		    if (use_rela_initialised && !use_rela)
 		      {
-			_bfd_error_handler (_("%B: Unable to sort relocs - "
+			_bfd_error_handler (_("%pB: Unable to sort relocs - "
 					      "they are in more than one size"),
 					    abfd);
 			bfd_set_error (bfd_error_invalid_operation);
@@ -8964,7 +8964,7 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
 		/* Section size is only divisible by rel.  */
 		if (use_rela_initialised && use_rela)
 		  {
-		    _bfd_error_handler (_("%B: Unable to sort relocs - "
+		    _bfd_error_handler (_("%pB: Unable to sort relocs - "
 					  "they are in more than one size"),
 					abfd);
 		    bfd_set_error (bfd_error_invalid_operation);
@@ -8980,7 +8980,7 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
 	      {
 		/* The section size is not divisible by either -
 		   something is wrong.  */
-		_bfd_error_handler (_("%B: Unable to sort relocs - "
+		_bfd_error_handler (_("%pB: Unable to sort relocs - "
 				      "they are of an unknown size"), abfd);
 		bfd_set_error (bfd_error_invalid_operation);
 		return 0;
@@ -9003,7 +9003,7 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
 		    /* Section size is only divisible by rela.  */
 		    if (use_rela_initialised && !use_rela)
 		      {
-			_bfd_error_handler (_("%B: Unable to sort relocs - "
+			_bfd_error_handler (_("%pB: Unable to sort relocs - "
 					      "they are in more than one size"),
 					    abfd);
 			bfd_set_error (bfd_error_invalid_operation);
@@ -9021,7 +9021,7 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
 		/* Section size is only divisible by rel.  */
 		if (use_rela_initialised && use_rela)
 		  {
-		    _bfd_error_handler (_("%B: Unable to sort relocs - "
+		    _bfd_error_handler (_("%pB: Unable to sort relocs - "
 					  "they are in more than one size"),
 					abfd);
 		    bfd_set_error (bfd_error_invalid_operation);
@@ -9037,7 +9037,7 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
 	      {
 		/* The section size is not divisible by either -
 		   something is wrong.  */
-		_bfd_error_handler (_("%B: Unable to sort relocs - "
+		_bfd_error_handler (_("%pB: Unable to sort relocs - "
 				      "they are of an unknown size"), abfd);
 		bfd_set_error (bfd_error_invalid_operation);
 		return 0;
@@ -9357,7 +9357,7 @@ check_dynsym (bfd *abfd, Elf_Internal_Sym *sym)
 	 beyond 64k.  */
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: Too many sections: %d (>= %d)"),
+	(_("%pB: Too many sections: %d (>= %d)"),
 	 abfd, bfd_count_sections (abfd), SHN_LORESERVE & 0xffff);
       bfd_set_error (bfd_error_nonrepresentable_section);
       return FALSE;
@@ -9637,13 +9637,13 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
 
       if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL)
 	/* xgettext:c-format */
-	msg = _("%B: internal symbol `%s' in %B is referenced by DSO");
+	msg = _("%pB: internal symbol `%s' in %pB is referenced by DSO");
       else if (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
 	/* xgettext:c-format */
-	msg = _("%B: hidden symbol `%s' in %B is referenced by DSO");
+	msg = _("%pB: hidden symbol `%s' in %pB is referenced by DSO");
       else
 	/* xgettext:c-format */
-	msg = _("%B: local symbol `%s' in %B is referenced by DSO");
+	msg = _("%pB: local symbol `%s' in %pB is referenced by DSO");
       def_bfd = flinfo->output_bfd;
       if (hi->root.u.def.section != bfd_abs_section_ptr)
 	def_bfd = hi->root.u.def.section->owner;
@@ -9729,7 +9729,7 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
 	      {
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: could not find output section %A for input section %A"),
+		  (_("%pB: could not find output section %pA for input section %pA"),
 		   flinfo->output_bfd, input_sec->output_section, input_sec);
 		bfd_set_error (bfd_error_nonrepresentable_section);
 		eoinfo->failed = TRUE;
@@ -9883,13 +9883,13 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
 
       if (ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED)
 	/* xgettext:c-format */
-	msg = _("%B: protected symbol `%s' isn't defined");
+	msg = _("%pB: protected symbol `%s' isn't defined");
       else if (ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL)
 	/* xgettext:c-format */
-	msg = _("%B: internal symbol `%s' isn't defined");
+	msg = _("%pB: internal symbol `%s' isn't defined");
       else
 	/* xgettext:c-format */
-	msg = _("%B: hidden symbol `%s' isn't defined");
+	msg = _("%pB: hidden symbol `%s' isn't defined");
       _bfd_error_handler (msg, flinfo->output_bfd, h->root.root.string);
       bfd_set_error (bfd_error_bad_value);
       eoinfo->failed = TRUE;
@@ -9920,7 +9920,7 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: No symbol version section for versioned symbol `%s'"),
+		(_("%pB: No symbol version section for versioned symbol `%s'"),
 		 flinfo->output_bfd, h->root.root.string);
 	      eoinfo->failed = TRUE;
 	      return FALSE;
@@ -10530,7 +10530,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("error: %B: size of section %A is not "
+		    (_("error: %pB: size of section %pA is not "
 		       "multiple of address size"),
 		     input_bfd, o);
 		  bfd_set_error (bfd_error_bad_value);
@@ -10575,7 +10575,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("error: %B contains a reloc (%#Lx) for section %A "
+			(_("error: %pB contains a reloc (%#Lx) for section %pA "
 			   "that references a non-existent global symbol"),
 			 input_bfd, rel->r_info, o);
 		      bfd_set_error (bfd_error_bad_value);
@@ -10661,8 +10661,8 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		      if (action_discarded & COMPLAIN)
 			(*flinfo->info->callbacks->einfo)
 			  /* xgettext:c-format */
-			  (_("%X`%s' referenced in section `%A' of %B: "
-			     "defined in discarded section `%A' of %B\n"),
+			  (_("%X`%s' referenced in section `%pA' of %pB: "
+			     "defined in discarded section `%pA' of %pB\n"),
 			   sym_name, o, input_bfd, sec, sec->owner);
 
 		      /* Try to do the best we can to support buggy old
@@ -11249,7 +11249,7 @@ elf_get_linked_section_vma (struct bfd_link_order *p)
       if (bed->link_order_error_handler)
 	bed->link_order_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: warning: sh_link not set for section `%A'"), s->owner, s);
+	  (_("%pB: warning: sh_link not set for section `%pA'"), s->owner, s);
       return 0;
     }
   else
@@ -11330,13 +11330,13 @@ elf_fixup_link_order (bfd *abfd, asection *o)
 	  if (other_sec && linkorder_sec)
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%A has both ordered [`%A' in %B] "
-		 "and unordered [`%A' in %B] sections"),
+	      (_("%pA has both ordered [`%pA' in %pB] "
+		 "and unordered [`%pA' in %pB] sections"),
 	       o, linkorder_sec, linkorder_sec->owner,
 	       other_sec, other_sec->owner);
 	  else
 	    _bfd_error_handler
-	      (_("%A has both ordered and unordered sections"), o);
+	      (_("%pA has both ordered and unordered sections"), o);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
 	}
@@ -11438,7 +11438,7 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)
   if (symcount == 0)
     {
       bfd_set_error (bfd_error_no_symbols);
-      _bfd_error_handler (_("%B: no symbol found for import library"),
+      _bfd_error_handler (_("%pB: no symbol found for import library"),
 			  implib_bfd);
       goto free_sym_buf;
     }
@@ -12060,7 +12060,7 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
 		      bfd_set_error (bfd_error_wrong_format);
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: file class %s incompatible with %s"),
+			(_("%pB: file class %s incompatible with %s"),
 			 sub, iclass, oclass);
 		    }
 
@@ -12277,7 +12277,7 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
 
   if (info->out_implib_bfd && !elf_output_implib (abfd, info))
     {
-      _bfd_error_handler (_("%B: failed to generate import library"),
+      _bfd_error_handler (_("%pB: failed to generate import library"),
 			  info->out_implib_bfd);
       return FALSE;
     }
@@ -12826,7 +12826,7 @@ _bfd_elf_gc_mark_rsec (struct bfd_link_info *info, asection *sec,
       h = cookie->sym_hashes[r_symndx - cookie->extsymoff];
       if (h == NULL)
 	{
-	  info->callbacks->einfo (_("%F%P: corrupt input: %B\n"),
+	  info->callbacks->einfo (_("%F%P: corrupt input: %pB\n"),
 				  sec->owner);
 	  return NULL;
 	}
@@ -13148,7 +13148,7 @@ elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
 
 	  if (info->print_gc_sections && o->size != 0)
 	    /* xgettext:c-format */
-	    _bfd_error_handler (_("Removing unused section '%A' in file '%B'"),
+	    _bfd_error_handler (_("Removing unused section '%pA' in file '%pB'"),
 				o, sub);
 	}
     }
@@ -13492,7 +13492,7 @@ bfd_elf_gc_record_vtinherit (bfd *abfd,
     }
 
   /* xgettext:c-format */
-  _bfd_error_handler (_("%B: %A+%#Lx: No symbol found for INHERIT"),
+  _bfd_error_handler (_("%pB: %pA+%#Lx: No symbol found for INHERIT"),
 		      abfd, sec, offset);
   bfd_set_error (bfd_error_invalid_operation);
   return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elfnn-aarch64.c b/sdcc/support/sdbinutils/bfd/elfnn-aarch64.c
index d5711e0eb..a43dded3c 100644
--- a/sdcc/support/sdbinutils/bfd/elfnn-aarch64.c
+++ b/sdcc/support/sdbinutils/bfd/elfnn-aarch64.c
@@ -2851,7 +2851,7 @@ _bfd_aarch64_add_stub_entry_in_group (const char *stub_name,
   if (stub_entry == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
+      _bfd_error_handler (_("%pB: cannot create stub entry %s"),
 			  section->owner, stub_name);
       return NULL;
     }
@@ -4776,7 +4776,7 @@ make_branch_to_erratum_835769_stub (struct bfd_hash_entry *gen_entry,
   abfd = stub_entry->target_section->owner;
   if (!aarch64_valid_branch_p (veneer_entry_loc, veneered_insn_loc))
     _bfd_error_handler
-      (_("%B: error: Erratum 835769 stub out "
+      (_("%pB: error: Erratum 835769 stub out "
 	 "of range (input file too large)"), abfd);
 
   target = stub_entry->target_value;
@@ -4857,7 +4857,7 @@ _bfd_aarch64_erratum_843419_branch_to_stub (struct bfd_hash_entry *gen_entry,
       abfd = stub_entry->target_section->owner;
       if (!aarch64_valid_branch_p (veneer_entry_loc, veneered_insn_loc))
 	_bfd_error_handler
-	  (_("%B: error: Erratum 843419 stub out "
+	  (_("%pB: error: Erratum 843419 stub out "
 	     "of range (input file too large)"), abfd);
 
       branch_insn = 0x14000000;
@@ -4998,7 +4998,7 @@ elfNN_aarch64_final_link_relocate (reloc_howto_type *howto,
 	    name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym, NULL);
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd, input_section, rel->r_offset, howto->name, name);
 	  bfd_set_error (bfd_error_bad_value);
 	  return bfd_reloc_notsupported;
@@ -5021,7 +5021,7 @@ bad_ifunc_reloc:
 				     NULL);
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: relocation %s against STT_GNU_IFUNC "
+	    (_("%pB: relocation %s against STT_GNU_IFUNC "
 	       "symbol `%s' isn't handled by %s"), input_bfd,
 	     howto->name, name, __FUNCTION__);
 	  bfd_set_error (bfd_error_bad_value);
@@ -5037,7 +5037,7 @@ bad_ifunc_reloc:
 					 sym, NULL);
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against STT_GNU_IFUNC "
+		(_("%pB: relocation %s against STT_GNU_IFUNC "
 		   "symbol `%s' has non-zero addend: %Ld"),
 		 input_bfd, howto->name, name, rel->r_addend);
 	      bfd_set_error (bfd_error_bad_value);
@@ -5363,7 +5363,7 @@ bad_ifunc_reloc:
 
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: relocation %s against symbol `%s' which may bind "
+	    (_("%pB: relocation %s against symbol `%s' which may bind "
 	       "externally can not be used when making a shared object; "
 	       "recompile with -fPIC"),
 	     input_bfd, elfNN_aarch64_howto_table[howto_index].name,
@@ -5454,7 +5454,7 @@ bad_ifunc_reloc:
 	    int howto_index = bfd_r_type - BFD_RELOC_AARCH64_RELOC_START;
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: Local symbol descriptor table be NULL when applying "
+	      (_("%pB: Local symbol descriptor table be NULL when applying "
 		 "relocation %s against local symbol"),
 	       input_bfd, elfNN_aarch64_howto_table[howto_index].name);
 	    abort ();
@@ -6182,9 +6182,9 @@ elfNN_aarch64_relocate_section (bfd *output_bfd,
 	  _bfd_error_handler
 	    ((sym_type == STT_TLS
 	      /* xgettext:c-format */
-	      ? _("%B(%A+%#Lx): %s used with TLS symbol %s")
+	      ? _("%pB(%pA+%#Lx): %s used with TLS symbol %s")
 	      /* xgettext:c-format */
-	      : _("%B(%A+%#Lx): %s used with non-TLS symbol %s")),
+	      : _("%pB(%pA+%#Lx): %s used with non-TLS symbol %s")),
 	     input_bfd,
 	     input_section, rel->r_offset, howto->name, name);
 	}
@@ -6454,7 +6454,7 @@ elfNN_aarch64_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd, input_section, rel->r_offset, howto->name,
 	     h->root.root.string);
 	  return FALSE;
@@ -6975,7 +6975,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, struct bfd_link_info *info,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"), abfd, r_symndx);
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"), abfd, r_symndx);
 	  return FALSE;
 	}
 
@@ -7081,7 +7081,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	      int howto_index = bfd_r_type - BFD_RELOC_AARCH64_RELOC_START;
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against `%s' can not be used when making "
+		(_("%pB: relocation %s against `%s' can not be used when making "
 		   "a shared object"),
 		 abfd, elfNN_aarch64_howto_table[howto_index].name,
 		 (h) ? h->root.root.string : "a local symbol");
@@ -7100,7 +7100,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	      int howto_index = bfd_r_type - BFD_RELOC_AARCH64_RELOC_START;
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against `%s' can not be used when making "
+		(_("%pB: relocation %s against `%s' can not be used when making "
 		   "a shared object; recompile with -fPIC"),
 		 abfd, elfNN_aarch64_howto_table[howto_index].name,
 		 (h) ? h->root.root.string : "a local symbol");
@@ -7532,7 +7532,7 @@ elfNN_aarch64_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSE
 				       0, &sym))
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B symbol number %lu references"
+	      _bfd_error_handler (_("%pB symbol number %lu references"
 				    " nonexistent SHT_SYMTAB_SHNDX section"),
 				    abfd, r_symndx);
 	      /* Ideally an error class should be returned here.  */
@@ -8316,7 +8316,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -9169,7 +9169,7 @@ elfNN_aarch64_finish_dynamic_sections (bfd *output_bfd,
       if (bfd_is_abs_section (htab->root.sgotplt->output_section))
 	{
 	  _bfd_error_handler
-	    (_("discarded output section: `%A'"), htab->root.sgotplt);
+	    (_("discarded output section: `%pA'"), htab->root.sgotplt);
 	  return FALSE;
 	}
 
diff --git a/sdcc/support/sdbinutils/bfd/elfnn-ia64.c b/sdcc/support/sdbinutils/bfd/elfnn-ia64.c
index 3af05f66f..fc3c43983 100644
--- a/sdcc/support/sdbinutils/bfd/elfnn-ia64.c
+++ b/sdcc/support/sdbinutils/bfd/elfnn-ia64.c
@@ -617,7 +617,7 @@ elfNN_ia64_relax_section (bfd *abfd, asection *sec,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: Can't relax br at %#Lx in section `%A'."
+		(_("%pB: Can't relax br at %#Lx in section `%pA'."
 		   " Please use brl or indirect branch."),
 		 sec->owner, roff, sec);
 	      bfd_set_error (bfd_error_bad_value);
@@ -3693,7 +3693,7 @@ elfNN_ia64_choose_gp (bfd *abfd, struct bfd_link_info *info, bfd_boolean final)
 overflow:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: short data segment overflowed (%#Lx >= 0x400000)"),
+	    (_("%pB: short data segment overflowed (%#Lx >= 0x400000)"),
 	     abfd, max_short_vma - min_short_vma);
 	  return FALSE;
 	}
@@ -3703,7 +3703,7 @@ overflow:
 		   && max_short_vma - gp_val >= 0x200000))
 	{
 	  _bfd_error_handler
-	    (_("%B: __gp does not cover short data segment"), abfd);
+	    (_("%pB: __gp does not cover short data segment"), abfd);
 	  return FALSE;
 	}
     }
@@ -3844,7 +3844,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: unknown relocation type %d"), input_bfd, (int) r_type);
+	    (_("%pB: unknown relocation type %d"), input_bfd, (int) r_type);
 	  bfd_set_error (bfd_error_bad_value);
 	  ret_val = FALSE;
 	  continue;
@@ -3971,7 +3971,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 		     shared libraries nor dynamic executables.  */
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: non-pic code with imm relocation against dynamic symbol `%s'"),
+		    (_("%pB: non-pic code with imm relocation against dynamic symbol `%s'"),
 		     input_bfd,
 		     h ? h->root.root.string
 		       : bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
@@ -4039,7 +4039,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: @gprel relocation against dynamic symbol %s"),
+		(_("%pB: @gprel relocation against dynamic symbol %s"),
 		 input_bfd,
 		 h ? h->root.root.string
 		   : bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
@@ -4102,7 +4102,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 		      /* ??? People shouldn't be doing non-pic code in
 			 shared libraries.  Hork.  */
 		      _bfd_error_handler
-			(_("%B: linking non-pic code in a position independent executable"),
+			(_("%pB: linking non-pic code in a position independent executable"),
 			 input_bfd);
 		      ret_val = FALSE;
 		      continue;
@@ -4240,13 +4240,13 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 
 	      if (r_type == R_IA64_PCREL21BI)
 		/* xgettext:c-format */
-		msg = _("%B: @internal branch to dynamic symbol %s");
+		msg = _("%pB: @internal branch to dynamic symbol %s");
 	      else if (r_type == R_IA64_PCREL21F || r_type == R_IA64_PCREL21M)
 		/* xgettext:c-format */
-		msg = _("%B: speculation fixup to dynamic symbol %s");
+		msg = _("%pB: speculation fixup to dynamic symbol %s");
 	      else
 		/* xgettext:c-format */
-		msg = _("%B: @pcrel relocation against dynamic symbol %s");
+		msg = _("%pB: @pcrel relocation against dynamic symbol %s");
 	      _bfd_error_handler (msg, input_bfd,
 				  h ? h->root.root.string
 				  : bfd_elf_sym_name (input_bfd,
@@ -4481,8 +4481,8 @@ missing_tls_sec:
 	      case R_IA64_LTOFF_DTPREL22:
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: missing TLS section for relocation %s against `%s'"
-		     " at %#Lx in section `%A'."),
+		  (_("%pB: missing TLS section for relocation %s against `%s'"
+		     " at %#Lx in section `%pA'."),
 		   input_bfd, howto->name, name,
 		   rel->r_offset, input_section);
 		break;
@@ -4498,8 +4498,8 @@ missing_tls_sec:
 		       that the section is too big to relax.  */
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: Can't relax br (%s) to `%s' at %#Lx"
-			 " in section `%A' with size %#Lx (> 0x1000000)."),
+		      (_("%pB: Can't relax br (%s) to `%s' at %#Lx"
+			 " in section `%pA' with size %#Lx (> 0x1000000)."),
 		       input_bfd, howto->name, name, rel->r_offset,
 		       input_section, input_section->size);
 		    break;
@@ -4755,7 +4755,7 @@ elfNN_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_TRAPNIL) != (out_flags & EF_IA_64_TRAPNIL))
     {
       _bfd_error_handler
-	(_("%B: linking trap-on-NULL-dereference with non-trapping files"),
+	(_("%pB: linking trap-on-NULL-dereference with non-trapping files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4764,7 +4764,7 @@ elfNN_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_BE) != (out_flags & EF_IA_64_BE))
     {
       _bfd_error_handler
-	(_("%B: linking big-endian files with little-endian files"),
+	(_("%pB: linking big-endian files with little-endian files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4773,7 +4773,7 @@ elfNN_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_ABI64) != (out_flags & EF_IA_64_ABI64))
     {
       _bfd_error_handler
-	(_("%B: linking 64-bit files with 32-bit files"),
+	(_("%pB: linking 64-bit files with 32-bit files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4782,7 +4782,7 @@ elfNN_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((in_flags & EF_IA_64_CONS_GP) != (out_flags & EF_IA_64_CONS_GP))
     {
       _bfd_error_handler
-	(_("%B: linking constant-gp files with non-constant-gp files"),
+	(_("%pB: linking constant-gp files with non-constant-gp files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
@@ -4792,7 +4792,7 @@ elfNN_ia64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       != (out_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
     {
       _bfd_error_handler
-	(_("%B: linking auto-pic files with non-auto-pic files"),
+	(_("%pB: linking auto-pic files with non-auto-pic files"),
 	 ibfd);
 
       bfd_set_error (bfd_error_bad_value);
diff --git a/sdcc/support/sdbinutils/bfd/elfnn-riscv.c b/sdcc/support/sdbinutils/bfd/elfnn-riscv.c
index 5f66f4f2d..c93eba247 100644
--- a/sdcc/support/sdbinutils/bfd/elfnn-riscv.c
+++ b/sdcc/support/sdbinutils/bfd/elfnn-riscv.c
@@ -424,7 +424,7 @@ riscv_elf_record_tls_type (bfd *abfd, struct elf_link_hash_entry *h,
   if ((*new_tls_type & GOT_NORMAL) && (*new_tls_type & ~GOT_NORMAL))
     {
       (*_bfd_error_handler)
-	(_("%B: `%s' accessed both as normal and thread local symbol"),
+	(_("%pB: `%s' accessed both as normal and thread local symbol"),
 	 abfd, h ? h->root.root.string : "<local>");
       return FALSE;
     }
@@ -468,7 +468,7 @@ static bfd_boolean
 bad_static_reloc (bfd *abfd, unsigned r_type, struct elf_link_hash_entry *h)
 {
   (*_bfd_error_handler)
-    (_("%B: relocation %s against `%s' can not be used when making a shared "
+    (_("%pB: relocation %s against `%s' can not be used when making a shared "
        "object; recompile with -fPIC"),
       abfd, riscv_elf_rtype_to_howto (r_type)->name,
       h != NULL ? h->root.root.string : "a local symbol");
@@ -510,7 +510,7 @@ riscv_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
-	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
+	  (*_bfd_error_handler) (_("%pB: bad symbol index: %d"),
 				 abfd, r_symndx);
 	  return FALSE;
 	}
@@ -1109,7 +1109,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2203,7 +2203,7 @@ riscv_elf_relocate_section (bfd *output_bfd,
 				      rel->r_offset) != (bfd_vma) -1)
 	{
 	  (*_bfd_error_handler)
-	    (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	    (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	     input_bfd,
 	     input_section,
 	     rel->r_offset,
@@ -2489,7 +2489,7 @@ riscv_elf_finish_dynamic_sections (bfd *output_bfd,
       if (bfd_is_abs_section (output_section))
 	{
 	  (*_bfd_error_handler)
-	    (_("discarded output section: `%A'"), htab->elf.sgotplt);
+	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
 	  return FALSE;
 	}
 
@@ -2567,7 +2567,7 @@ _bfd_riscv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
     {
       (*_bfd_error_handler)
-	(_("%B: ABI is incompatible with that of the selected emulation:\n"
+	(_("%pB: ABI is incompatible with that of the selected emulation:\n"
 	   "  target emulation `%s' does not match `%s'"),
 	 ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
       return FALSE;
@@ -2587,7 +2587,7 @@ _bfd_riscv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if ((old_flags ^ new_flags) & EF_RISCV_FLOAT_ABI)
     {
       (*_bfd_error_handler)
-	(_("%B: can't link hard-float modules with soft-float modules"), ibfd);
+	(_("%pB: can't link hard-float modules with soft-float modules"), ibfd);
       goto fail;
     }
 
@@ -3067,7 +3067,7 @@ _bfd_riscv_relax_align (bfd *abfd, asection *sec,
   if (rel->r_addend < nop_bytes)
     {
       (*_bfd_error_handler)
-	(_("%B(%A+0x%lx): %d bytes required for alignment "
+	(_("%pB(%pA+0x%lx): %d bytes required for alignment "
 	   "to %d-byte boundary, but only %d present"),
 	   abfd, sym_sec, rel->r_offset, nop_bytes, alignment, rel->r_addend);
       bfd_set_error (bfd_error_bad_value);
@@ -3133,7 +3133,7 @@ _bfd_riscv_relax_pc  (bfd *abfd,
 	sym_sec = hi_reloc.sym_sec;
 	if (!riscv_use_pcgp_hi_reloc(pcgp_relocs, hi->hi_sec_off))
 	  (*_bfd_error_handler)
-	   (_("%B(%A+0x%lx): Unable to clear RISCV_PCREL_HI20 reloc"
+	   (_("%pB(%pA+0x%lx): Unable to clear RISCV_PCREL_HI20 reloc"
 	      "for cooresponding RISCV_PCREL_LO12 reloc"),
 	    abfd, sec, rel->r_offset);
       }
diff --git a/sdcc/support/sdbinutils/bfd/elfxx-sparc.c b/sdcc/support/sdbinutils/bfd/elfxx-sparc.c
index 9f9fedadf..33e3fbc56 100644
--- a/sdcc/support/sdbinutils/bfd/elfxx-sparc.c
+++ b/sdcc/support/sdbinutils/bfd/elfxx-sparc.c
@@ -1417,7 +1417,7 @@ _bfd_sparc_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"), abfd, r_symndx);
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"), abfd, r_symndx);
 	  return FALSE;
 	}
 
@@ -1598,7 +1598,7 @@ _bfd_sparc_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and thread local symbol"),
+		      (_("%pB: `%s' accessed both as normal and thread local symbol"),
 		       abfd, h ? h->root.root.string : "<local>");
 		    return FALSE;
 		  }
@@ -2449,7 +2449,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2548,7 +2548,7 @@ _bfd_sparc_elf_size_dynamic_sections (bfd *output_bfd,
 		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
 		    {
 		      info->flags |= DF_TEXTREL;
-		      info->callbacks->minfo (_("%B: dynamic relocation in read-only section `%A'\n"),
+		      info->callbacks->minfo (_("%pB: dynamic relocation in read-only section `%pA'\n"),
 					      p->sec->owner, p->sec);
 		    }
 		}
@@ -3121,7 +3121,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,
 					 NULL);
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocation %s against STT_GNU_IFUNC "
+		(_("%pB: relocation %s against STT_GNU_IFUNC "
 		   "symbol `%s' isn't handled by %s"), input_bfd,
 		 _bfd_sparc_elf_howto_table[r_type].name,
 		 name, __FUNCTION__);
@@ -3529,7 +3529,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,
 			    {
 			      BFD_FAIL ();
 			      _bfd_error_handler
-				(_("%B: probably compiled without -fPIC?"),
+				(_("%pB: probably compiled without -fPIC?"),
 				 input_bfd);
 			      bfd_set_error (bfd_error_bad_value);
 			      return FALSE;
@@ -3910,7 +3910,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,
 				      rel->r_offset) != (bfd_vma) -1)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	  (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	   input_bfd,
 	   input_section,
 	   rel->r_offset,
diff --git a/sdcc/support/sdbinutils/bfd/elfxx-tilegx.c b/sdcc/support/sdbinutils/bfd/elfxx-tilegx.c
index 7596b49ba..99dea9b8c 100644
--- a/sdcc/support/sdbinutils/bfd/elfxx-tilegx.c
+++ b/sdcc/support/sdbinutils/bfd/elfxx-tilegx.c
@@ -1685,7 +1685,7 @@ tilegx_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: bad symbol index: %d"),
+	  _bfd_error_handler (_("%pB: bad symbol index: %d"),
 			      abfd, r_symndx);
 	  return FALSE;
 	}
@@ -1790,7 +1790,7 @@ tilegx_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: `%s' accessed both as normal and thread local symbol"),
+		      (_("%pB: `%s' accessed both as normal and thread local symbol"),
 		       abfd, h ? h->root.root.string : "<local>");
 		    return FALSE;
 		  }
@@ -2476,7 +2476,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo
-	(_("%B: dynamic relocation against `%T' in read-only section `%A'\n"),
+	(_("%pB: dynamic relocation against `%T' in read-only section `%pA'\n"),
 	 sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -2564,7 +2564,7 @@ tilegx_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
 		    {
 		      info->flags |= DF_TEXTREL;
 
-		      info->callbacks->minfo (_("%B: dynamic relocation in read-only section `%A'\n"),
+		      info->callbacks->minfo (_("%pB: dynamic relocation in read-only section `%pA'\n"),
 					      p->sec->owner, p->sec);
 		    }
 		}
@@ -3528,7 +3528,7 @@ tilegx_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 			    {
 			      BFD_FAIL ();
 			      _bfd_error_handler
-				(_("%B: probably compiled without -fPIC?"),
+				(_("%pB: probably compiled without -fPIC?"),
 				 input_bfd);
 			      bfd_set_error (bfd_error_bad_value);
 			      return FALSE;
@@ -3778,7 +3778,7 @@ tilegx_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 				      rel->r_offset) != (bfd_vma) -1)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B(%A+%#Lx): unresolvable %s relocation against symbol `%s'"),
+	  (_("%pB(%pA+%#Lx): unresolvable %s relocation against symbol `%s'"),
 	   input_bfd,
 	   input_section,
 	   rel->r_offset,
@@ -4129,7 +4129,7 @@ tilegx_elf_finish_dynamic_sections (bfd *output_bfd,
       if (bfd_is_abs_section (htab->elf.sgotplt->output_section))
 	{
 	  _bfd_error_handler
-	    (_("discarded output section: `%A'"), htab->elf.sgotplt);
+	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
 	  return FALSE;
 	}
 
@@ -4238,7 +4238,7 @@ _bfd_tilegx_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: Cannot link together %s and %s objects."),
+	(_("%pB: Cannot link together %s and %s objects."),
 	 ibfd, targ1, targ2);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/elfxx-x86.c b/sdcc/support/sdbinutils/bfd/elfxx-x86.c
index a7db5d9df..e80a4c345 100644
--- a/sdcc/support/sdbinutils/bfd/elfxx-x86.c
+++ b/sdcc/support/sdbinutils/bfd/elfxx-x86.c
@@ -560,15 +560,15 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)
 
       info->flags |= DF_TEXTREL;
       /* xgettext:c-format */
-      info->callbacks->minfo (_("%B: dynamic relocation against `%T' "
-				"in read-only section `%A'\n"),
+      info->callbacks->minfo (_("%pB: dynamic relocation against `%T' "
+				"in read-only section `%pA'\n"),
 			      sec->owner, h->root.root.string, sec);
 
       if ((info->warn_shared_textrel && bfd_link_pic (info))
 	  || info->error_textrel)
 	/* xgettext:c-format */
-	info->callbacks->einfo (_("%P: %B: warning: relocation against `%s' "
-				  "in read-only section `%A'\n"),
+	info->callbacks->einfo (_("%P: %pB: warning: relocation against `%s' "
+				  "in read-only section `%pA'\n"),
 				sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
@@ -960,8 +960,8 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,
 			  || info->error_textrel)
 			/* xgettext:c-format */
 			info->callbacks->einfo
-			  (_("%P: %B: warning: relocation "
-			     "in read-only section `%A'\n"),
+			  (_("%P: %pB: warning: relocation "
+			     "in read-only section `%pA'\n"),
 			   p->sec->owner, p->sec);
 		    }
 		}
@@ -1342,7 +1342,7 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,
       if (bfd_is_abs_section (htab->elf.sgotplt->output_section))
 	{
 	  _bfd_error_handler
-	    (_("discarded output section: `%A'"), htab->elf.sgotplt);
+	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
 	  return NULL;
 	}
 
@@ -2247,10 +2247,10 @@ _bfd_x86_elf_parse_gnu_properties (bfd *abfd, unsigned int type,
 	{
 	  _bfd_error_handler
 	    ((type == GNU_PROPERTY_X86_ISA_1_USED
-	      ? _("error: %B: <corrupt x86 ISA used size: 0x%x>")
+	      ? _("error: %pB: <corrupt x86 ISA used size: 0x%x>")
 	      : (type == GNU_PROPERTY_X86_ISA_1_NEEDED
-		 ? _("error: %B: <corrupt x86 ISA needed size: 0x%x>")
-		 : _("error: %B: <corrupt x86 feature size: 0x%x>"))),
+		 ? _("error: %pB: <corrupt x86 ISA needed size: 0x%x>")
+		 : _("error: %pB: <corrupt x86 feature size: 0x%x>"))),
 	     abfd, datasz);
 	  return property_corrupt;
 	}
@@ -2427,7 +2427,7 @@ _bfd_x86_elf_link_setup_gnu_properties
 	  if (!bfd_set_section_alignment (ebfd, sec, class_align))
 	    {
 error_alignment:
-	      info->callbacks->einfo (_("%F%A: failed to align section\n"),
+	      info->callbacks->einfo (_("%F%pA: failed to align section\n"),
 				      sec);
 	    }
 
diff --git a/sdcc/support/sdbinutils/bfd/hpux-core.c b/sdcc/support/sdbinutils/bfd/hpux-core.c
index aab3d9a54..dfcf9b6ab 100644
--- a/sdcc/support/sdbinutils/bfd/hpux-core.c
+++ b/sdcc/support/sdbinutils/bfd/hpux-core.c
@@ -337,7 +337,7 @@ hpux_core_core_file_p (bfd *abfd)
      */
   if ((unknown_sections > 0) && (good_sections > 0))
     _bfd_error_handler
-      ("%B appears to be a core file,\nbut contains unknown sections."
+      ("%pB appears to be a core file,\nbut contains unknown sections."
        "  It may have been created on an incompatible\nversion of HP-UX."
        "  As a result, some information may be unavailable.\n",
        abfd);
diff --git a/sdcc/support/sdbinutils/bfd/ieee.c b/sdcc/support/sdbinutils/bfd/ieee.c
index 174ab19c1..61b8f3574 100644
--- a/sdcc/support/sdbinutils/bfd/ieee.c
+++ b/sdcc/support/sdbinutils/bfd/ieee.c
@@ -156,7 +156,7 @@ ieee_write_id (bfd *abfd, const char *id)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: string too long (%ld chars, max 65535)"), abfd, (long) length);
+	(_("%pB: string too long (%ld chars, max 65535)"), abfd, (long) length);
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
     }
@@ -299,7 +299,7 @@ ieee_write_expression (bfd *abfd,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: unrecognized symbol `%s' flags 0x%x"),
+		(_("%pB: unrecognized symbol `%s' flags 0x%x"),
 		 abfd, bfd_asymbol_name (symbol), symbol->flags);
 	      bfd_set_error (bfd_error_invalid_operation);
 	      return FALSE;
@@ -834,7 +834,7 @@ ieee_slurp_external_symbols (bfd *abfd)
 		  default:
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: unimplemented ATI record %u for symbol %u"),
+		      (_("%pB: unimplemented ATI record %u for symbol %u"),
 		       abfd, symbol_attribute_def, symbol_name_index);
 		    bfd_set_error (bfd_error_bad_value);
 		    return FALSE;
@@ -859,7 +859,7 @@ ieee_slurp_external_symbols (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: unexpected ATN type %Ld in external part"),
+		      (_("%pB: unexpected ATN type %Ld in external part"),
 			 abfd, value);
 		    bfd_set_error (bfd_error_bad_value);
 		    return FALSE;
@@ -881,7 +881,7 @@ ieee_slurp_external_symbols (bfd *abfd)
 
 		      default:
 			_bfd_error_handler
-			  (_("%B: unexpected type after ATN"), abfd);
+			  (_("%pB: unexpected type after ATN"), abfd);
 			bfd_set_error (bfd_error_bad_value);
 			return FALSE;
 		      }
diff --git a/sdcc/support/sdbinutils/bfd/ihex.c b/sdcc/support/sdbinutils/bfd/ihex.c
index 247d1a8b4..29de113ae 100644
--- a/sdcc/support/sdbinutils/bfd/ihex.c
+++ b/sdcc/support/sdbinutils/bfd/ihex.c
@@ -227,7 +227,7 @@ ihex_bad_byte (bfd *abfd, unsigned int lineno, int c, bfd_boolean error)
 	}
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B:%d: unexpected character `%s' in Intel Hex file"),
+	(_("%pB:%d: unexpected character `%s' in Intel Hex file"),
 	 abfd, lineno, buf);
       bfd_set_error (bfd_error_bad_value);
     }
@@ -335,7 +335,7 @@ ihex_scan (bfd *abfd)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B:%u: bad checksum in Intel Hex file (expected %u, found %u)"),
+		(_("%pB:%u: bad checksum in Intel Hex file (expected %u, found %u)"),
 		 abfd, lineno,
 		 (- chksum) & 0xff, (unsigned int) HEX2 (buf + 2 * i));
 	      bfd_set_error (bfd_error_bad_value);
@@ -391,7 +391,7 @@ ihex_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B:%u: bad extended address record length in Intel Hex file"),
+		    (_("%pB:%u: bad extended address record length in Intel Hex file"),
 		     abfd, lineno);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -409,7 +409,7 @@ ihex_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B:%u: bad extended start address length in Intel Hex file"),
+		    (_("%pB:%u: bad extended start address length in Intel Hex file"),
 		     abfd, lineno);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -427,7 +427,7 @@ ihex_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B:%u: bad extended linear address record length in Intel Hex file"),
+		    (_("%pB:%u: bad extended linear address record length in Intel Hex file"),
 		     abfd, lineno);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -445,7 +445,7 @@ ihex_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B:%u: bad extended linear start address length in Intel Hex file"),
+		    (_("%pB:%u: bad extended linear start address length in Intel Hex file"),
 		     abfd, lineno);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -463,7 +463,7 @@ ihex_scan (bfd *abfd)
 	    default:
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B:%u: unrecognized ihex type %u in Intel Hex file"),
+		(_("%pB:%u: unrecognized ihex type %u in Intel Hex file"),
 		 abfd, lineno, type);
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
@@ -582,7 +582,7 @@ ihex_read_section (bfd *abfd, asection *section, bfd_byte *contents)
       if (type != 0)
 	{
 	  _bfd_error_handler
-	    (_("%B: internal error in ihex_read_section"), abfd);
+	    (_("%pB: internal error in ihex_read_section"), abfd);
 	  bfd_set_error (bfd_error_bad_value);
 	  goto error_return;
 	}
@@ -616,7 +616,7 @@ ihex_read_section (bfd *abfd, asection *section, bfd_byte *contents)
   if ((bfd_size_type) (p - contents) < section->size)
     {
       _bfd_error_handler
-	(_("%B: bad section length in ihex_read_section"), abfd);
+	(_("%pB: bad section length in ihex_read_section"), abfd);
       bfd_set_error (bfd_error_bad_value);
       goto error_return;
     }
@@ -827,7 +827,7 @@ ihex_write_object_contents (bfd *abfd)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: address %#Lx out of range for Intel Hex file"),
+			(_("%pB: address %#Lx out of range for Intel Hex file"),
 			 abfd, where);
 		      bfd_set_error (bfd_error_bad_value);
 		      return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/libbfd.c b/sdcc/support/sdbinutils/bfd/libbfd.c
index 6f29fe73a..8f1fa025e 100644
--- a/sdcc/support/sdbinutils/bfd/libbfd.c
+++ b/sdcc/support/sdbinutils/bfd/libbfd.c
@@ -796,7 +796,7 @@ _bfd_generic_get_section_contents (bfd *abfd,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: unable to get decompressed section %A"),
+	(_("%pB: unable to get decompressed section %pA"),
 	 abfd, section);
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/linker.c b/sdcc/support/sdbinutils/bfd/linker.c
index dac21bd9e..35b82efc2 100644
--- a/sdcc/support/sdbinutils/bfd/linker.c
+++ b/sdcc/support/sdbinutils/bfd/linker.c
@@ -1407,7 +1407,7 @@ _bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
 	  && name[1] == '_'
 	  && strcmp (name + (name[2] == '_'), "__gnu_lto_slim") == 0)
 	_bfd_error_handler
-	  (_("%B: plugin needed to handle lto object"), abfd);
+	  (_("%pB: plugin needed to handle lto object"), abfd);
     }
   else
     row = DEF_ROW;
@@ -1675,7 +1675,7 @@ _bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: indirect symbol `%s' to `%s' is a loop"),
+		(_("%pB: indirect symbol `%s' to `%s' is a loop"),
 		 abfd, name, string);
 	      bfd_set_error (bfd_error_invalid_operation);
 	      return FALSE;
@@ -2831,7 +2831,7 @@ _bfd_handle_already_linked (asection *sec,
     case SEC_LINK_DUPLICATES_ONE_ONLY:
       info->callbacks->einfo
 	/* xgettext:c-format */
-	(_("%B: ignoring duplicate section `%A'\n"),
+	(_("%pB: ignoring duplicate section `%pA'\n"),
 	 sec->owner, sec);
       break;
 
@@ -2841,7 +2841,7 @@ _bfd_handle_already_linked (asection *sec,
       else if (sec->size != l->sec->size)
 	info->callbacks->einfo
 	  /* xgettext:c-format */
-	  (_("%B: duplicate section `%A' has different size\n"),
+	  (_("%pB: duplicate section `%pA' has different size\n"),
 	   sec->owner, sec);
       break;
 
@@ -2851,7 +2851,7 @@ _bfd_handle_already_linked (asection *sec,
       else if (sec->size != l->sec->size)
 	info->callbacks->einfo
 	  /* xgettext:c-format */
-	  (_("%B: duplicate section `%A' has different size\n"),
+	  (_("%pB: duplicate section `%pA' has different size\n"),
 	   sec->owner, sec);
       else if (sec->size != 0)
 	{
@@ -2860,18 +2860,18 @@ _bfd_handle_already_linked (asection *sec,
 	  if (!bfd_malloc_and_get_section (sec->owner, sec, &sec_contents))
 	    info->callbacks->einfo
 	      /* xgettext:c-format */
-	      (_("%B: could not read contents of section `%A'\n"),
+	      (_("%pB: could not read contents of section `%pA'\n"),
 	       sec->owner, sec);
 	  else if (!bfd_malloc_and_get_section (l->sec->owner, l->sec,
 						&l_sec_contents))
 	    info->callbacks->einfo
 	      /* xgettext:c-format */
-	      (_("%B: could not read contents of section `%A'\n"),
+	      (_("%pB: could not read contents of section `%pA'\n"),
 	       l->sec->owner, l->sec);
 	  else if (memcmp (sec_contents, l_sec_contents, sec->size) != 0)
 	    info->callbacks->einfo
 	      /* xgettext:c-format */
-	      (_("%B: duplicate section `%A' has different contents\n"),
+	      (_("%pB: duplicate section `%pA' has different contents\n"),
 	       sec->owner, sec);
 
 	  if (sec_contents)
@@ -3359,10 +3359,10 @@ _bfd_generic_verify_endian_match (bfd *ibfd, struct bfd_link_info *info)
       && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
     {
       if (bfd_big_endian (ibfd))
-	_bfd_error_handler (_("%B: compiled for a big endian system "
+	_bfd_error_handler (_("%pB: compiled for a big endian system "
 			      "and target is little endian"), ibfd);
       else
-	_bfd_error_handler (_("%B: compiled for a little endian system "
+	_bfd_error_handler (_("%pB: compiled for a little endian system "
 			      "and target is big endian"), ibfd);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/mach-o.c b/sdcc/support/sdbinutils/bfd/mach-o.c
index a6299d05d..611060c0f 100644
--- a/sdcc/support/sdbinutils/bfd/mach-o.c
+++ b/sdcc/support/sdbinutils/bfd/mach-o.c
@@ -4759,7 +4759,7 @@ bfd_mach_o_read_command (bfd *abfd, bfd_mach_o_load_command *command)
       break;
     default:
       command->len = 0;
-      _bfd_error_handler (_("%B: unknown load command %#x"),
+      _bfd_error_handler (_("%pB: unknown load command %#x"),
 			  abfd, command->type);
       return FALSE;
     }
diff --git a/sdcc/support/sdbinutils/bfd/merge.c b/sdcc/support/sdbinutils/bfd/merge.c
index 832cb16d5..9b3e8eaca 100644
--- a/sdcc/support/sdbinutils/bfd/merge.c
+++ b/sdcc/support/sdbinutils/bfd/merge.c
@@ -865,7 +865,7 @@ _bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
       if (offset > sec->rawsize)
 	_bfd_error_handler
 	  /* xgettext:c-format */
-	  (_("%B: access beyond end of merged section (%Ld)"),
+	  (_("%pB: access beyond end of merged section (%Ld)"),
 	   sec->owner, offset);
       return secinfo->first_str ? sec->size : 0;
     }
diff --git a/sdcc/support/sdbinutils/bfd/mmo.c b/sdcc/support/sdbinutils/bfd/mmo.c
index 66d1286e0..c57da230b 100644
--- a/sdcc/support/sdbinutils/bfd/mmo.c
+++ b/sdcc/support/sdbinutils/bfd/mmo.c
@@ -465,7 +465,7 @@ mmo_make_section (bfd *abfd, const char *secname)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: No core to allocate section name %s\n"),
+	    (_("%pB: No core to allocate section name %s\n"),
 	     abfd, secname);
 	  bfd_set_error (bfd_error_system_call);
 	  return NULL;
@@ -541,7 +541,7 @@ mmo_object_p (bfd *abfd)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: No core to allocate a symbol %d bytes long\n"),
+	(_("%pB: No core to allocate a symbol %d bytes long\n"),
 	 abfd, abfd->tdata.mmo_data->max_symbol_length);
       goto bad_final;
     }
@@ -955,7 +955,7 @@ mmo_write_loc_chunk (bfd *abfd, bfd_vma vma, const bfd_byte *loc,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: attempt to emit contents at non-multiple-of-4"
+	    (_("%pB: attempt to emit contents at non-multiple-of-4"
 	       " address %#Lx"),
 	     abfd, vma);
 	  bfd_set_error (bfd_error_bad_value);
@@ -1252,7 +1252,7 @@ mmo_create_symbol (bfd *abfd, const char *symname, bfd_vma addr, enum
       && !mmo_ignore_symbol_consistency (abfd))
     {
       _bfd_error_handler
-	(_("%B: invalid mmo file: initialization value for $255"
+	(_("%pB: invalid mmo file: initialization value for $255"
 	   " is not `Main'\n"),
 	 abfd);
       bfd_set_error (bfd_error_bad_value);
@@ -1399,7 +1399,7 @@ SUBSECTION
 
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: unsupported wide character sequence"
+		(_("%pB: unsupported wide character sequence"
 		   " 0x%02X 0x%02X after symbol name starting with `%s'\n"),
 		 abfd, c, c2, abfd->tdata.mmo_data->lop_stab_symbol);
 	      bfd_set_error (bfd_error_bad_value);
@@ -1633,7 +1633,7 @@ mmo_scan (bfd *abfd)
 	    default:
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: invalid mmo file: unsupported lopcode `%d'\n"),
+		(_("%pB: invalid mmo file: unsupported lopcode `%d'\n"),
 		 abfd, buf[1]);
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
@@ -1644,7 +1644,7 @@ mmo_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: invalid mmo file: expected YZ = 1"
+		    (_("%pB: invalid mmo file: expected YZ = 1"
 		       " got YZ = %d for lop_quote\n"),
 		     abfd, y*256+z);
 		  bfd_set_error (bfd_error_bad_value);
@@ -1682,7 +1682,7 @@ mmo_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: invalid mmo file: expected z = 1 or z = 2,"
+		    (_("%pB: invalid mmo file: expected z = 1 or z = 2,"
 		       " got z = %d for lop_loc\n"),
 		     abfd, z);
 		  bfd_set_error (bfd_error_bad_value);
@@ -1733,7 +1733,7 @@ mmo_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: invalid mmo file: expected z = 1 or z = 2,"
+		      (_("%pB: invalid mmo file: expected z = 1 or z = 2,"
 			 " got z = %d for lop_fixo\n"),
 		       abfd, z);
 		    bfd_set_error (bfd_error_bad_value);
@@ -1774,7 +1774,7 @@ mmo_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: invalid mmo file: expected y = 0,"
+		      (_("%pB: invalid mmo file: expected y = 0,"
 			 " got y = %d for lop_fixrx\n"),
 		       abfd, y);
 		    bfd_set_error (bfd_error_bad_value);
@@ -1785,7 +1785,7 @@ mmo_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: invalid mmo file: expected z = 16 or z = 24,"
+		      (_("%pB: invalid mmo file: expected z = 16 or z = 24,"
 			 " got z = %d for lop_fixrx\n"),
 		       abfd, z);
 		    bfd_set_error (bfd_error_bad_value);
@@ -1810,7 +1810,7 @@ mmo_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: invalid mmo file: leading byte of operand word"
+		      (_("%pB: invalid mmo file: leading byte of operand word"
 			 " must be 0 or 1, got %d for lop_fixrx\n"),
 		       abfd, buf[0]);
 		    bfd_set_error (bfd_error_bad_value);
@@ -1835,7 +1835,7 @@ mmo_scan (bfd *abfd)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: cannot allocate file name for file number %d,"
+			(_("%pB: cannot allocate file name for file number %d,"
 			   " %d bytes\n"),
 			 abfd, y, z * 4 + 1);
 		      bfd_set_error (bfd_error_system_call);
@@ -1857,7 +1857,7 @@ mmo_scan (bfd *abfd)
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
-			(_("%B: invalid mmo file: file number %d `%s',"
+			(_("%pB: invalid mmo file: file number %d `%s',"
 			   " was already entered as `%s'\n"),
 			 abfd, y, fname, file_names[y]);
 		      bfd_set_error (bfd_error_bad_value);
@@ -1871,7 +1871,7 @@ mmo_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: invalid mmo file: file name for number %d"
+		    (_("%pB: invalid mmo file: file name for number %d"
 		       " was not specified before use\n"),
 		     abfd, y);
 		  bfd_set_error (bfd_error_bad_value);
@@ -1978,7 +1978,7 @@ mmo_scan (bfd *abfd)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: invalid mmo file: fields y and z of lop_stab"
+		    (_("%pB: invalid mmo file: fields y and z of lop_stab"
 		       " non-zero, y: %d, z: %d\n"),
 		     abfd, y, z);
 		  bfd_set_error (bfd_error_bad_value);
@@ -2015,7 +2015,7 @@ mmo_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: invalid mmo file: lop_end not last item in"
+		      (_("%pB: invalid mmo file: lop_end not last item in"
 			 " file\n"),
 		       abfd);
 		    bfd_set_error (bfd_error_bad_value);
@@ -2029,7 +2029,7 @@ mmo_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B: invalid mmo file: YZ of lop_end (%ld)"
+		      (_("%pB: invalid mmo file: YZ of lop_end (%ld)"
 			 " not equal to the number of tetras to the preceding"
 			 " lop_stab (%ld)\n"),
 		       abfd, (long) (y * 256 + z),
@@ -2740,7 +2740,7 @@ mmo_internal_add_3_sym (bfd *abfd, struct mmo_symbol_trie *rootp,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: invalid symbol table: duplicate symbol `%s'\n"),
+	(_("%pB: invalid symbol table: duplicate symbol `%s'\n"),
 	 abfd, trie->sym.name);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
@@ -2983,7 +2983,7 @@ mmo_write_symbols_and_terminator (bfd *abfd)
 
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: Bad symbol definition: `Main' set to %s rather"
+	      (_("%pB: Bad symbol definition: `Main' set to %s rather"
 		 " than the start address %s\n"),
 	       abfd, vmas_main, vmas_start);
 	    bfd_set_error (bfd_error_bad_value);
@@ -3082,7 +3082,7 @@ mmo_write_symbols_and_terminator (bfd *abfd)
 
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: warning: symbol table too large for mmo, larger than 65535"
+	(_("%pB: warning: symbol table too large for mmo, larger than 65535"
 	   " 32-bit words: %d.  Only `Main' will be emitted.\n"),
 	 abfd, trie_len);
 
@@ -3128,7 +3128,7 @@ mmo_write_symbols_and_terminator (bfd *abfd)
 	 diagnostic and fail "normally".  */
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: internal error, symbol table changed size from %d to %d"
+	(_("%pB: internal error, symbol table changed size from %d to %d"
 	   " words\n"),
 	 abfd, trie_len,
 	 (abfd->tdata.mmo_data->byte_no + 3)/4);
@@ -3181,7 +3181,7 @@ mmo_write_section_unless_reg_contents (bfd *abfd, asection *sec, void *p)
 	     this.  */
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: internal error, internal register section %A had"
+	    (_("%pB: internal error, internal register section %pA had"
 	       " contents\n"),
 	     abfd, sec);
 	  bfd_set_error (bfd_error_bad_value);
@@ -3232,19 +3232,19 @@ mmo_write_object_contents (bfd *abfd)
 	  if (sec->size == 0)
 	    /* There must always be at least one such register.  */
 	    _bfd_error_handler
-	      (_("%B: no initialized registers; section length 0\n"),
+	      (_("%pB: no initialized registers; section length 0\n"),
 	       abfd);
 	  else if (sec->vma > (256 - 32) * 8)
 	    /* Provide better error message for the case of too many
 	       global registers.  */
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: too many initialized registers; section length %Ld"),
+	      (_("%pB: too many initialized registers; section length %Ld"),
 	       abfd, sec->size);
 	  else
 	    _bfd_error_handler
 	      /* xgettext:c-format */
-	      (_("%B: invalid start address for initialized registers of"
+	      (_("%pB: invalid start address for initialized registers of"
 		 " length %Ld: %#Lx"),
 	       abfd, sec->size, sec->vma);
 
diff --git a/sdcc/support/sdbinutils/bfd/oasys.c b/sdcc/support/sdbinutils/bfd/oasys.c
index d8e38a8f6..21c5d9d11 100644
--- a/sdcc/support/sdbinutils/bfd/oasys.c
+++ b/sdcc/support/sdbinutils/bfd/oasys.c
@@ -878,7 +878,7 @@ oasys_write_sections (bfd *abfd)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: can not represent section `%A' in oasys"), abfd, s);
+	    (_("%pB: can not represent section `%pA' in oasys"), abfd, s);
 	  bfd_set_error (bfd_error_nonrepresentable_section);
 	  return FALSE;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/pdp11.c b/sdcc/support/sdbinutils/bfd/pdp11.c
index c9311dcc1..21cccb599 100644
--- a/sdcc/support/sdbinutils/bfd/pdp11.c
+++ b/sdcc/support/sdbinutils/bfd/pdp11.c
@@ -1149,7 +1149,7 @@ NAME (aout, set_section_contents) (bfd *abfd,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: can not represent section `%A' in a.out object file format"),
+	(_("%pB: can not represent section `%pA' in a.out object file format"),
 	 abfd, section);
       bfd_set_error (bfd_error_nonrepresentable_section);
       return FALSE;
@@ -1382,7 +1382,7 @@ translate_to_native_sym_flags (bfd *abfd,
 	 file.  */
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: can not represent section for symbol `%s' in a.out object file format"),
+	(_("%pB: can not represent section for symbol `%s' in a.out object file format"),
 	 abfd, cache_ptr->name != NULL ? cache_ptr->name : "*unknown*");
       bfd_set_error (bfd_error_nonrepresentable_section);
       return FALSE;
@@ -1410,7 +1410,7 @@ translate_to_native_sym_flags (bfd *abfd,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: can not represent section `%A' in a.out object file format"),
+	(_("%pB: can not represent section `%pA' in a.out object file format"),
 	 abfd, sec);
       bfd_set_error (bfd_error_nonrepresentable_section);
       return FALSE;
@@ -3705,7 +3705,7 @@ NAME (aout, final_link) (bfd *abfd,
 		 by the reloc size.  */
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: relocatable link from %s to %s not supported"),
+		(_("%pB: relocatable link from %s to %s not supported"),
 		 abfd, sub->xvec->name, abfd->xvec->name);
 	      bfd_set_error (bfd_error_invalid_operation);
 	      goto error_return;
diff --git a/sdcc/support/sdbinutils/bfd/pe-mips.c b/sdcc/support/sdbinutils/bfd/pe-mips.c
index b81f683df..a9ac187ac 100644
--- a/sdcc/support/sdbinutils/bfd/pe-mips.c
+++ b/sdcc/support/sdbinutils/bfd/pe-mips.c
@@ -606,7 +606,7 @@ coff_pe_mips_relocate_section (bfd *output_bfd,
   if (bfd_link_relocatable (info))
     {
       _bfd_error_handler
-	(_("%B: `ld -r' not supported with PE MIPS objects\n"), input_bfd);
+	(_("%pB: `ld -r' not supported with PE MIPS objects\n"), input_bfd);
       bfd_set_error (bfd_error_bad_value);
       return FALSE;
     }
@@ -717,7 +717,7 @@ coff_pe_mips_relocate_section (bfd *output_bfd,
 
 #define UI(x)						       \
       /* xgettext:c-format */				       \
-	_bfd_error_handler (_("%B: unimplemented %s\n"),       \
+	_bfd_error_handler (_("%pB: unimplemented %s\n"),       \
 			    input_bfd, x);		       \
 	bfd_set_error (bfd_error_bad_value);
 
@@ -743,7 +743,7 @@ coff_pe_mips_relocate_section (bfd *output_bfd,
 	  targ = val + (tmp & 0x03ffffff) * 4;
 	  if ((src & 0xf0000000) != (targ & 0xf0000000))
 	    {
-	      _bfd_error_handler (_("%B: jump too far away\n"), input_bfd);
+	      _bfd_error_handler (_("%pB: jump too far away\n"), input_bfd);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
 	    }
@@ -769,7 +769,7 @@ coff_pe_mips_relocate_section (bfd *output_bfd,
 	      targ = val + low + ((tmp & 0xffff) << 16);
 	      break;
 	    default:
-	      _bfd_error_handler (_("%B: bad pair/reflo after refhi\n"),
+	      _bfd_error_handler (_("%pB: bad pair/reflo after refhi\n"),
 				  input_bfd);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
diff --git a/sdcc/support/sdbinutils/bfd/peXXigen.c b/sdcc/support/sdbinutils/bfd/peXXigen.c
index 679dabf4c..92fa2793a 100644
--- a/sdcc/support/sdbinutils/bfd/peXXigen.c
+++ b/sdcc/support/sdbinutils/bfd/peXXigen.c
@@ -154,7 +154,7 @@ _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)
 	  name = _bfd_coff_internal_syment_name (abfd, in, namebuf);
 	  if (name == NULL)
 	    {
-	      _bfd_error_handler (_("%B: unable to find name for empty section"),
+	      _bfd_error_handler (_("%pB: unable to find name for empty section"),
 				  abfd);
 	      bfd_set_error (bfd_error_invalid_target);
 	      return;
@@ -180,7 +180,7 @@ _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)
 	      name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1);
 	      if (name == NULL)
 		{
-		  _bfd_error_handler (_("%B: out of memory creating name for empty section"),
+		  _bfd_error_handler (_("%pB: out of memory creating name for empty section"),
 				      abfd);
 		  return;
 		}
@@ -191,7 +191,7 @@ _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)
 	  sec = bfd_make_section_anyway_with_flags (abfd, name, flags);
 	  if (sec == NULL)
 	    {
-	      _bfd_error_handler (_("%B: unable to create fake empty section"),
+	      _bfd_error_handler (_("%pB: unable to create fake empty section"),
 				  abfd);
 	      return;
 	    }
@@ -529,7 +529,7 @@ _bfd_XXi_swap_aouthdr_in (bfd * abfd,
       {
 	/* xgettext:c-format */
 	_bfd_error_handler
-	  (_("%B: aout header specifies an invalid number of data-directory entries: %ld"),
+	  (_("%pB: aout header specifies an invalid number of data-directory entries: %ld"),
 	   abfd, a->NumberOfRvaAndSizes);
 	bfd_set_error (bfd_error_bad_value);
 
@@ -1086,7 +1086,7 @@ _bfd_XXi_swap_scnhdr_out (bfd * abfd, void * in, void * out)
       else
 	{
 	  /* xgettext:c-format */
-	  _bfd_error_handler (_("%B: line number overflow: 0x%lx > 0xffff"),
+	  _bfd_error_handler (_("%pB: line number overflow: 0x%lx > 0xffff"),
 			      abfd, scnhdr_int->s_nlnno);
 	  bfd_set_error (bfd_error_file_truncated);
 	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nlnno);
@@ -2986,7 +2986,7 @@ _bfd_XX_bfd_copy_private_bfd_data_common (bfd * ibfd, bfd * obfd)
 	      > bfd_get_section_size (section))
 	    {
 	      /* xgettext:c-format */
-	      _bfd_error_handler (_("%B: Data Directory size (%lx) exceeds space left in section (%Lx)"),
+	      _bfd_error_handler (_("%pB: Data Directory size (%lx) exceeds space left in section (%Lx)"),
 				  obfd, ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size,
 				  bfd_get_section_size (section) - (addr - section->vma));
 	      return FALSE;
@@ -3022,7 +3022,7 @@ _bfd_XX_bfd_copy_private_bfd_data_common (bfd * ibfd, bfd * obfd)
 	}
       else if (section)
 	{
-	  _bfd_error_handler (_("%B: Failed to read debug data section"), obfd);
+	  _bfd_error_handler (_("%pB: Failed to read debug data section"), obfd);
 	  return FALSE;
 	}
     }
@@ -4225,7 +4225,7 @@ rsrc_process_section (bfd * abfd,
       if (data > dataend)
 	{
 	  /* Corrupted .rsrc section - cannot merge.  */
-	  _bfd_error_handler (_("%B: .rsrc merge failure: corrupt .rsrc section"),
+	  _bfd_error_handler (_("%pB: .rsrc merge failure: corrupt .rsrc section"),
 			      abfd);
 	  bfd_set_error (bfd_error_file_truncated);
 	  goto end;
@@ -4233,7 +4233,7 @@ rsrc_process_section (bfd * abfd,
 
       if ((data - p) > rsrc_sizes [num_resource_sets])
 	{
-	  _bfd_error_handler (_("%B: .rsrc merge failure: unexpected .rsrc size"),
+	  _bfd_error_handler (_("%pB: .rsrc merge failure: unexpected .rsrc size"),
 			      abfd);
 	  bfd_set_error (bfd_error_file_truncated);
 	  goto end;
@@ -4372,7 +4372,7 @@ _bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
       else
 	{
 	  _bfd_error_handler
-	    (_("%B: unable to fill in DataDictionary[1] because .idata$2 is missing"),
+	    (_("%pB: unable to fill in DataDictionary[1] because .idata$2 is missing"),
 	     abfd);
 	  result = FALSE;
 	}
@@ -4392,7 +4392,7 @@ _bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
       else
 	{
 	  _bfd_error_handler
-	    (_("%B: unable to fill in DataDictionary[1] because .idata$4 is missing"),
+	    (_("%pB: unable to fill in DataDictionary[1] because .idata$4 is missing"),
 	     abfd);
 	  result = FALSE;
 	}
@@ -4413,7 +4413,7 @@ _bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
       else
 	{
 	  _bfd_error_handler
-	    (_("%B: unable to fill in DataDictionary[12] because .idata$5 is missing"),
+	    (_("%pB: unable to fill in DataDictionary[12] because .idata$5 is missing"),
 	     abfd);
 	  result = FALSE;
 	}
@@ -4433,7 +4433,7 @@ _bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
       else
 	{
 	  _bfd_error_handler
-	    (_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE (12)] because .idata$6 is missing"),
+	    (_("%pB: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE (12)] because .idata$6 is missing"),
 	     abfd);
 	  result = FALSE;
 	}
@@ -4475,7 +4475,7 @@ _bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
 	  else
 	    {
 	      _bfd_error_handler
-		(_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE(12)]"
+		(_("%pB: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE(12)]"
 		   " because .idata$6 is missing"), abfd);
 	      result = FALSE;
 	    }
@@ -4500,7 +4500,7 @@ _bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
       else
 	{
 	  _bfd_error_handler
-	    (_("%B: unable to fill in DataDictionary[9] because __tls_used is missing"),
+	    (_("%pB: unable to fill in DataDictionary[9] because __tls_used is missing"),
 	     abfd);
 	  result = FALSE;
 	}
diff --git a/sdcc/support/sdbinutils/bfd/peicode.h b/sdcc/support/sdbinutils/bfd/peicode.h
index 94dd861a9..c0f8c474a 100644
--- a/sdcc/support/sdbinutils/bfd/peicode.h
+++ b/sdcc/support/sdbinutils/bfd/peicode.h
@@ -772,13 +772,13 @@ pe_ILF_build_a_bfd (bfd *	    abfd,
     case IMPORT_CONST:
       /* XXX code yet to be written.  */
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Unhandled import type; %x"),
+      _bfd_error_handler (_("%pB: Unhandled import type; %x"),
 			  abfd, import_type);
       return FALSE;
 
     default:
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Unrecognised import type; %x"),
+      _bfd_error_handler (_("%pB: Unrecognised import type; %x"),
 			  abfd, import_type);
       return FALSE;
     }
@@ -793,7 +793,7 @@ pe_ILF_build_a_bfd (bfd *	    abfd,
 
     default:
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: Unrecognised import name type; %x"),
+      _bfd_error_handler (_("%pB: Unrecognised import name type; %x"),
 			  abfd, import_name_type);
       return FALSE;
     }
@@ -1214,7 +1214,7 @@ pe_ILF_object_p (bfd * abfd)
     default:
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: Unrecognised machine type (0x%x)"
+	(_("%pB: Unrecognised machine type (0x%x)"
 	   " in Import Library Format archive"),
 	 abfd, machine);
       bfd_set_error (bfd_error_malformed_archive);
@@ -1227,7 +1227,7 @@ pe_ILF_object_p (bfd * abfd)
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: Recognised but unhandled machine type (0x%x)"
+	(_("%pB: Recognised but unhandled machine type (0x%x)"
 	   " in Import Library Format archive"),
 	 abfd, machine);
       bfd_set_error (bfd_error_wrong_format);
@@ -1245,7 +1245,7 @@ pe_ILF_object_p (bfd * abfd)
   if (size == 0)
     {
       _bfd_error_handler
-	(_("%B: size field is zero in Import Library Format header"), abfd);
+	(_("%pB: size field is zero in Import Library Format header"), abfd);
       bfd_set_error (bfd_error_malformed_archive);
 
       return NULL;
@@ -1277,7 +1277,7 @@ pe_ILF_object_p (bfd * abfd)
       || (bfd_size_type) ((bfd_byte *) source_dll - ptr) >= size)
     {
       _bfd_error_handler
-	(_("%B: string not null terminated in ILF object file."), abfd);
+	(_("%pB: string not null terminated in ILF object file."), abfd);
       bfd_set_error (bfd_error_malformed_archive);
       bfd_release (abfd, ptr);
       return NULL;
@@ -1332,7 +1332,7 @@ pe_bfd_read_buildid (bfd *abfd)
   if (dataoff >= section->size
       || size > section->size - dataoff)
     {
-      _bfd_error_handler (_("%B: Error: Debug Data ends beyond end of debug directory."),
+      _bfd_error_handler (_("%pB: Error: Debug Data ends beyond end of debug directory."),
 			  abfd);
       return;
     }
diff --git a/sdcc/support/sdbinutils/bfd/reloc.c b/sdcc/support/sdbinutils/bfd/reloc.c
index a1353a281..3e4095977 100644
--- a/sdcc/support/sdbinutils/bfd/reloc.c
+++ b/sdcc/support/sdbinutils/bfd/reloc.c
@@ -8204,7 +8204,7 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 	    {
 	      link_info->callbacks->einfo
 		/* xgettext:c-format */
-		(_("%X%P: %B(%A): error: relocation for offset %V has no value\n"),
+		(_("%X%P: %pB(%pA): error: relocation for offset %V has no value\n"),
 		 abfd, input_section, (* parent)->address);
 	      goto error_return;
 	    }
@@ -8270,7 +8270,7 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 		     message instead.  */
 		  link_info->callbacks->einfo
 		    /* xgettext:c-format */
-		    (_("%X%P: %B(%A): relocation \"%R\" goes out of range\n"),
+		    (_("%X%P: %pB(%pA): relocation \"%R\" goes out of range\n"),
 		     abfd, input_section, * parent);
 		  goto error_return;
 
@@ -8280,7 +8280,7 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 		     Do not abort.  Issue an error message instead.  */
 		  link_info->callbacks->einfo
 		    /* xgettext:c-format */
-		    (_("%X%P: %B(%A): relocation \"%R\" is not supported\n"),
+		    (_("%X%P: %pB(%pA): relocation \"%R\" is not supported\n"),
 		     abfd, input_section, * parent);
 		  goto error_return;
 
@@ -8289,7 +8289,7 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 		     Report unexpected results, without aborting.  */
 		  link_info->callbacks->einfo
 		    /* xgettext:c-format */
-		    (_("%X%P: %B(%A): relocation \"%R\" returns an unrecognized value %x\n"),
+		    (_("%X%P: %pB(%pA): relocation \"%R\" returns an unrecognized value %x\n"),
 		     abfd, input_section, * parent, r);
 		  break;
 		}
@@ -8351,7 +8351,7 @@ bfd_boolean
 _bfd_unrecognized_reloc (bfd * abfd, sec_ptr section, unsigned int r_type)
 {
    /* xgettext:c-format */
-  _bfd_error_handler (_("%B: unrecognized relocation (%#x) in section `%A'"),
+  _bfd_error_handler (_("%pB: unrecognized relocation (%#x) in section `%pA'"),
 		      abfd, r_type, section);
 
   /* PR 21803: Suggest the most likely cause of this error.  */
diff --git a/sdcc/support/sdbinutils/bfd/rs6000-core.c b/sdcc/support/sdbinutils/bfd/rs6000-core.c
index 8958c4ab9..a2f0d2315 100644
--- a/sdcc/support/sdbinutils/bfd/rs6000-core.c
+++ b/sdcc/support/sdbinutils/bfd/rs6000-core.c
@@ -468,7 +468,7 @@ rs6000coff_core_p (bfd *abfd)
 
   /* Issue warning if the core file was truncated during writing.  */
   if (c_flag & CORE_TRUNC)
-    _bfd_error_handler (_("%B: warning core file truncated"), abfd);
+    _bfd_error_handler (_("%pB: warning core file truncated"), abfd);
 
   /* Allocate core file header.  */
 #ifndef BFD64
diff --git a/sdcc/support/sdbinutils/bfd/srec.c b/sdcc/support/sdbinutils/bfd/srec.c
index 705de510d..05358d97a 100644
--- a/sdcc/support/sdbinutils/bfd/srec.c
+++ b/sdcc/support/sdbinutils/bfd/srec.c
@@ -257,7 +257,7 @@ srec_bad_byte (bfd *abfd,
 	}
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B:%d: Unexpected character `%s' in S-record file\n"),
+	(_("%pB:%d: Unexpected character `%s' in S-record file\n"),
 	 abfd, lineno, buf);
       bfd_set_error (bfd_error_bad_value);
     }
@@ -485,7 +485,7 @@ srec_scan (bfd *abfd)
 	    if (bytes < min_bytes)
 	      {
 		/* xgettext:c-format */
-		_bfd_error_handler (_("%B:%d: byte count %d too small\n"),
+		_bfd_error_handler (_("%pB:%d: byte count %d too small\n"),
 				    abfd, lineno, bytes);
 		bfd_set_error (bfd_error_bad_value);
 		goto error_return;
@@ -578,7 +578,7 @@ srec_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B:%d: Bad checksum in S-record file\n"),
+		      (_("%pB:%d: Bad checksum in S-record file\n"),
 		       abfd, lineno);
 		    bfd_set_error (bfd_error_bad_value);
 		    goto error_return;
@@ -612,7 +612,7 @@ srec_scan (bfd *abfd)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
-		      (_("%B:%d: Bad checksum in S-record file\n"),
+		      (_("%pB:%d: Bad checksum in S-record file\n"),
 		       abfd, lineno);
 		    bfd_set_error (bfd_error_bad_value);
 		    goto error_return;
diff --git a/sdcc/support/sdbinutils/bfd/stabs.c b/sdcc/support/sdbinutils/bfd/stabs.c
index 7a1a6e53c..d7770e78a 100644
--- a/sdcc/support/sdbinutils/bfd/stabs.c
+++ b/sdcc/support/sdbinutils/bfd/stabs.c
@@ -276,7 +276,7 @@ _bfd_link_section_stabs (bfd *abfd,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B(%A+%#lx): Stabs entry has invalid string index."),
+	    (_("%pB(%pA+%#lx): Stabs entry has invalid string index."),
 	     abfd, stabsec, (long) (sym - stabbuf));
 	  bfd_set_error (bfd_error_bad_value);
 	  goto error_return;
diff --git a/sdcc/support/sdbinutils/bfd/vms-alpha.c b/sdcc/support/sdbinutils/bfd/vms-alpha.c
index d93ac10ae..5769b355d 100644
--- a/sdcc/support/sdbinutils/bfd/vms-alpha.c
+++ b/sdcc/support/sdbinutils/bfd/vms-alpha.c
@@ -3827,7 +3827,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 
 	  if (section->reloc_count == 0)
 	    _bfd_error_handler
-	      (_("SEC_RELOC with no relocs in section %A"), section);
+	      (_("SEC_RELOC with no relocs in section %pA"), section);
 
 #if VMS_DEBUG
 	  else
@@ -3879,7 +3879,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 
 		  /* Regular relocs are intertwined with binary data.  */
 		  if (curr_addr > addr)
-		    _bfd_error_handler (_("Size error in section %A"),
+		    _bfd_error_handler (_("Size error in section %pA"),
 					section);
 		  size = addr - curr_addr;
 		  sto_imm (abfd, section, size, curr_data, curr_addr);
@@ -4092,7 +4092,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 	    {
 	      /* Output rest of section.  */
 	      if (curr_addr > section->size)
-		_bfd_error_handler (_("Size error in section %A"), section);
+		_bfd_error_handler (_("Size error in section %pA"), section);
 	      size = section->size - curr_addr;
 	      sto_imm (abfd, section, size, curr_data, curr_addr);
 	      curr_data += size;
@@ -8969,7 +8969,7 @@ alpha_vms_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
 	    {
 	      (*info->callbacks->einfo)
 		/* xgettext:c-format */
-		(_("%P: multiple entry points: in modules %B and %B\n"),
+		(_("%P: multiple entry points: in modules %pB and %pB\n"),
 		 startbfd, sub);
 	      continue;
 	    }
diff --git a/sdcc/support/sdbinutils/bfd/xcofflink.c b/sdcc/support/sdbinutils/bfd/xcofflink.c
index 90067e3a4..80b23c56b 100644
--- a/sdcc/support/sdbinutils/bfd/xcofflink.c
+++ b/sdcc/support/sdbinutils/bfd/xcofflink.c
@@ -829,7 +829,7 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
    if (info->output_bfd->xvec != abfd->xvec)
     {
       _bfd_error_handler
-	(_("%B: XCOFF shared object when not producing XCOFF output"),
+	(_("%pB: XCOFF shared object when not producing XCOFF output"),
 	 abfd);
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
@@ -850,7 +850,7 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
   if (lsec == NULL)
     {
       _bfd_error_handler
-	(_("%B: dynamic object with no .loader section"),
+	(_("%pB: dynamic object with no .loader section"),
 	 abfd);
       bfd_set_error (bfd_error_no_symbols);
       return FALSE;
@@ -1410,7 +1410,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: `%s' has line numbers but no enclosing section"),
+		    (_("%pB: `%s' has line numbers but no enclosing section"),
 		     abfd, name);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -1463,7 +1463,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: class %d symbol `%s' has no aux entries"),
+	    (_("%pB: class %d symbol `%s' has no aux entries"),
 	     abfd, sym.n_sclass, name);
 	  bfd_set_error (bfd_error_bad_value);
 	  goto error_return;
@@ -1486,7 +1486,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	default:
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: symbol `%s' has unrecognized csect type %d"),
+	    (_("%pB: symbol `%s' has unrecognized csect type %d"),
 	     abfd, name, smtyp);
 	  bfd_set_error (bfd_error_bad_value);
 	  goto error_return;
@@ -1499,7 +1499,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	    {
 	      _bfd_error_handler
 		/* xgettext:c-format */
-		(_("%B: bad XTY_ER symbol `%s': class %d scnum %d scnlen %Ld"),
+		(_("%pB: bad XTY_ER symbol `%s': class %d scnum %d scnlen %Ld"),
 		 abfd, name, sym.n_sclass, sym.n_scnum,
 		 aux.x_csect.x_scnlen.l);
 	      bfd_set_error (bfd_error_bad_value);
@@ -1529,7 +1529,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: XMC_TC0 symbol `%s' is class %d scnlen %Ld"),
+		    (_("%pB: XMC_TC0 symbol `%s' is class %d scnlen %Ld"),
 		     abfd, name, sym.n_sclass, aux.x_csect.x_scnlen.l);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -1676,7 +1676,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	      {
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: csect `%s' not in enclosing section"),
+		  (_("%pB: csect `%s' not in enclosing section"),
 		   abfd, name);
 		bfd_set_error (bfd_error_bad_value);
 		goto error_return;
@@ -1784,7 +1784,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	      {
 		_bfd_error_handler
 		  /* xgettext:c-format */
-		  (_("%B: misplaced XTY_LD `%s'"),
+		  (_("%pB: misplaced XTY_LD `%s'"),
 		   abfd, name);
 		bfd_set_error (bfd_error_bad_value);
 		goto error_return;
@@ -2105,7 +2105,7 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
-		    (_("%B: reloc %s:%Ld not in csect"),
+		    (_("%pB: reloc %s:%Ld not in csect"),
 		     abfd, o->name, i);
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
@@ -4059,7 +4059,7 @@ xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *flinfo,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: loader reloc in unrecognized section `%s'"),
+	    (_("%pB: loader reloc in unrecognized section `%s'"),
 	     reference_bfd, secname);
 	  bfd_set_error (bfd_error_nonrepresentable_section);
 	  return FALSE;
@@ -4071,7 +4071,7 @@ xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *flinfo,
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
-	    (_("%B: `%s' in loader reloc but not loader sym"),
+	    (_("%pB: `%s' in loader reloc but not loader sym"),
 	     reference_bfd, h->root.root.string);
 	  bfd_set_error (bfd_error_bad_value);
 	  return FALSE;
@@ -4088,7 +4088,7 @@ xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *flinfo,
     {
       _bfd_error_handler
 	/* xgettext:c-format */
-	(_("%B: loader reloc in read-only section %A"),
+	(_("%pB: loader reloc in read-only section %pA"),
 	 reference_bfd, output_section);
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
-- 
2.28.0.windows.1

