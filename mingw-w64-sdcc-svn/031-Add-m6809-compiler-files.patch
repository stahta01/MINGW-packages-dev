From 2965b419494c4069d20512d4994a9359870d9619 Mon Sep 17 00:00:00 2001
From: Tim Stahlhut <stahta01@gmail.com>
Date: Wed, 26 Aug 2020 10:22:40 -0400
Subject: Add m6809 compiler files

Forked from z80 compiler files.
---
 sdcc/src/mc6809/Makefile.in |    7 +
 sdcc/src/mc6809/gen.c       | 2557 +++++++++++++++++++++++++++++++++++
 sdcc/src/mc6809/gen.h       |   84 ++
 sdcc/src/mc6809/m6809.h     |   40 +
 sdcc/src/mc6809/main.c      |  664 +++++++++
 sdcc/src/mc6809/mappings.i  |  167 +++
 sdcc/src/mc6809/peep.c      | 1287 ++++++++++++++++++
 sdcc/src/mc6809/peep.h      |   28 +
 sdcc/src/mc6809/peeph.def   |  278 ++++
 sdcc/src/mc6809/ralloc.c    | 2059 ++++++++++++++++++++++++++++
 sdcc/src/mc6809/ralloc.h    |   62 +
 sdcc/src/mc6809/ralloc2.cc  |  930 +++++++++++++
 sdcc/src/mc6809/reg_index.h |   57 +
 sdcc/src/mc6809/support.c   |   37 +
 sdcc/src/mc6809/support.h   |   20 +
 15 files changed, 8277 insertions(+)
 create mode 100644 sdcc/src/mc6809/Makefile.in
 create mode 100644 sdcc/src/mc6809/gen.c
 create mode 100644 sdcc/src/mc6809/gen.h
 create mode 100644 sdcc/src/mc6809/m6809.h
 create mode 100644 sdcc/src/mc6809/main.c
 create mode 100644 sdcc/src/mc6809/mappings.i
 create mode 100644 sdcc/src/mc6809/peep.c
 create mode 100644 sdcc/src/mc6809/peep.h
 create mode 100644 sdcc/src/mc6809/peeph.def
 create mode 100644 sdcc/src/mc6809/ralloc.c
 create mode 100644 sdcc/src/mc6809/ralloc.h
 create mode 100644 sdcc/src/mc6809/ralloc2.cc
 create mode 100644 sdcc/src/mc6809/reg_index.h
 create mode 100644 sdcc/src/mc6809/support.c
 create mode 100644 sdcc/src/mc6809/support.h

diff --git a/sdcc/src/mc6809/Makefile.in b/sdcc/src/mc6809/Makefile.in
new file mode 100644
index 000000000..dfb8a5245
--- /dev/null
+++ b/sdcc/src/mc6809/Makefile.in
@@ -0,0 +1,7 @@
+VPATH        = @srcdir@
+srcdir       = @srcdir@
+top_builddir = @top_builddir@
+top_srcdir   = @top_srcdir@
+
+# Make all in this directory
+include $(srcdir)/../port.mk
diff --git a/sdcc/src/mc6809/gen.c b/sdcc/src/mc6809/gen.c
new file mode 100644
index 000000000..08f71481e
--- /dev/null
+++ b/sdcc/src/mc6809/gen.c
@@ -0,0 +1,2557 @@
+/*-------------------------------------------------------------------------
+  gen.c - code generator for MC6809 / HD6309.
+
+  Copyright (C) 1998, Sandeep Dutta . sandeep.dutta@usa.net
+  Copyright (C) 1999, Jean-Louis VERN.jlvern@writeme.com
+  Copyright (C) 2000, Michael Hope <michaelh@juju.net.nz>
+  Copyright (C) 2011-2018, Philipp Klaus Krause pkk@spth.de, philipp@informatik.uni-frankfurt.de)
+  Copyright (C) 2020, Tim Stahlhut stahta01@gmail.com
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the
+  Free Software Foundation; either version 2, or (at your option) any
+  later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+-------------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "m6809.h"
+#include "gen.h"
+#include "dbuf_string.h"
+
+/* This is the down and dirty file with all kinds of kludgy & hacky
+   stuff. This is what it is all about CODE GENERATION for a specific MCU.
+   Some of the routines may be reusable, will have to see */
+
+/* MC6809 calling convention description.
+?   Parameters are passed right to left.  As the stack grows downwards,
+?   the parameters are arranged in left to right in memory.
+
+   Everything is caller saves. i.e. the caller must save any registers
+?   that it wants to preserve over the call.
+?   va args functions do not use register parameters.  All arguments
+?   are passed on the stack.
+*/
+
+enum
+{
+  /* Set to enable debugging trace statements in the output assembly code. */
+  DISABLE_DEBUG = 0
+};
+
+// #define DEBUG_DRY_COST
+
+extern struct dbuf_s *codeOutBuf;
+
+enum
+{
+  INT8MIN = -128,
+  INT8MAX = 127
+};
+
+enum
+{
+  LSB,
+  MSB16,
+  MSB24,
+  MSB32
+};
+
+enum asminst
+{
+  A_ABX,
+  A_ADC8,
+  A_ADD8,
+  A_ADD16,
+  A_AND8,
+  A_ANDCC,
+  A_ASL,
+  A_ASL8,
+  A_ASR,
+  A_ASR8,
+  A_BCC,
+  A_BCS,
+  A_BEQ,
+  A_BGE,
+  A_BGT,
+  A_BHI,
+  A_BHS,
+  A_BIT8,
+  A_BLE,
+  A_BLO,
+  A_BLS,
+  A_BLT,
+  A_BMI,
+  A_BNE,
+  A_BPL,
+  A_BRA,
+  A_BRN,
+  A_BSR,
+  A_BVC,
+  A_BVS,
+  A_CLR,
+  A_CLR8,
+  A_CMP8,
+  A_CMP16,
+  A_COM,
+  A_COM8,
+  A_CWAI,
+  A_DAA,
+  A_DEC,
+  A_DEC8,
+  A_EOR8,
+  A_EXG,
+  A_INC,
+  A_INC8,
+  A_JMP,
+  A_JSR,
+  A_LBCC,
+  A_LBCS,
+  A_LBEQ,
+  A_LBGE,
+  A_LBGT,
+  A_LBHI,
+  A_LBHS,
+  A_LBLE,
+  A_LBLO,
+  A_LBLS,
+  A_LBLT,
+  A_LBMI,
+  A_LBNE,
+  A_LBPL,
+  A_LBRA,
+  A_LBRN,
+  A_LBSR,
+  A_LBVC,
+  A_LBVS,
+  A_LD8,
+  A_LD16,
+  A_LEA16,
+  A_LSL,
+  A_LSL8,
+  A_LSR,
+  A_LSR8,
+  A_MUL,
+  A_NEG,
+  A_NEG8,
+  A_NOP,
+  A_OR8,
+  A_ORCC,
+  A_PSHS,
+  A_PSHU,
+  A_PULS,
+  A_PULU,
+  A_ROL,
+  A_ROL8,
+  A_ROR,
+  A_ROR8,
+  A_RTI,
+  A_RTS,
+  A_SBC8,
+  A_SEX,
+  A_ST8,
+  A_ST16,
+  A_SUB8,
+  A_SUB16,
+  A_SWI,
+  A_SWI2,
+  A_SWI3,
+  A_SYNC,
+  A_TFR,
+  A_TST,
+  A_TST8,
+  A_MAX=A_TST8
+};
+
+static const char *asminstnames[] =
+{
+  "abx",
+  "adc",
+  "add",
+  "add",
+  "and",
+  "andcc",
+  "asl",
+  "asl",
+  "asr",
+  "asr",
+  "bcc",
+  "bcs",
+  "beq",
+  "bge",
+  "bgt",
+  "bhi",
+  "bhs",
+  "bit",
+  "ble",
+  "blo",
+  "bls",
+  "blt",
+  "bmi",
+  "bne",
+  "bpl",
+  "bra",
+  "brn",
+  "bsr",
+  "bvc",
+  "bvs",
+  "clr",
+  "clr",
+  "cmp",
+  "cmp",
+  "com",
+  "com",
+  "cwai",
+  "daa",
+  "dec",
+  "dec",
+  "eor",
+  "exg",
+  "inc",
+  "inc",
+  "jmp",
+  "jsr",
+  "lbcc",
+  "lbcs",
+  "lbeq",
+  "lbge",
+  "lbgt",
+  "lbhi",
+  "lbhs",
+  "lble",
+  "lblo",
+  "lbls",
+  "lblt",
+  "lbmi",
+  "lbne",
+  "lbpl",
+  "lbra",
+  "lbrn",
+  "lbsr",
+  "lbvc",
+  "lbvs",
+  "ld",
+  "ld",
+  "lea",
+  "lsl",
+  "lsl",
+  "lsr",
+  "lsr",
+  "mul",
+  "neg",
+  "neg",
+  "nop",
+  "or",
+  "orcc",
+  "pshs",
+  "pshu",
+  "puls",
+  "pulu",
+  "rol",
+  "rol",
+  "ror",
+  "ror",
+  "rti",
+  "rts",
+  "sbc",
+  "sex",
+  "st",
+  "st",
+  "sub",
+  "sub",
+  "swi",
+  "swi2",
+  "swi3",
+  "sync",
+  "tfr",
+  "tst",
+  "tst"
+};
+
+#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
+
+/** Code generator persistent data.
+ */
+static struct
+{
+  struct
+  {
+//    int last;
+    int pushed;
+    int param_offset;
+    int offset;
+  } stack;
+
+/*
+  struct
+  {
+  } calleeSaves;
+*/
+
+  bool omitFramePtr;
+  int frameId;
+  int receiveOffset;
+  bool flushStatics;
+  bool in_home;
+  const char *lastFunctionName;
+  iCode *current_iCode;
+  bool preserveCarry;
+
+  set *sendSet;
+
+  struct
+  {
+    /** TRUE if the registers have already been saved. */
+    bool saved;
+  } saves;
+
+  struct
+  {
+    allocTrace trace;
+  } lines;
+
+  struct
+  {
+    allocTrace aops;
+  } trace;
+} _G;
+
+bool mc6809_regs_used_as_parms_in_calls_from_current_function[MAX_IDX + 1];
+bool mc6809_symmParm_in_calls_from_current_function;
+bool mc6809_regs_preserved_in_calls_from_current_function[MAX_IDX + 1];
+
+static const char *aopGet (asmop *aop, int offset, bool bit16);
+
+static struct asmop asmop_a, asmop_b, asmop_d, asmop_x, asmop_y, asmop_u;
+static struct asmop *const ASMOP_A = &asmop_a;
+static struct asmop *const ASMOP_B = &asmop_b;
+static struct asmop *const ASMOP_D = &asmop_d;
+static struct asmop *const ASMOP_X = &asmop_x;
+static struct asmop *const ASMOP_Y = &asmop_y;
+static struct asmop *const ASMOP_U = &asmop_u;
+
+static asmop *asmopregs[] = { &asmop_a, &asmop_b, &asmop_d, &asmop_x, &asmop_y, &asmop_u };
+
+void
+mc6809_init_asmops (void)
+{
+  asmop_a.type = AOP_REG;
+  asmop_a.size = 1;
+  asmop_a.aopu.aop_reg[0] = regsMC6809 + A_IDX;
+  memset (asmop_a.regs, -1, MAX_ASMOP_IDX + 1);
+  asmop_a.regs[A_IDX] = 0;
+
+  asmop_b.type = AOP_REG;
+  asmop_b.size = 1;
+  asmop_b.aopu.aop_reg[0] = regsMC6809 + B_IDX;
+  memset (asmop_b.regs, -1, MAX_ASMOP_IDX + 1);
+  asmop_b.regs[B_IDX] = 0;
+
+  asmop_d.type = AOP_REG;
+  asmop_d.size = 2;
+  asmop_d.aopu.aop_reg[0] = regsMC6809 + D_IDX;
+  memset (asmop_d.regs, -1, MAX_ASMOP_IDX + 1);
+  asmop_d.regs[B_IDX] = 0;
+  asmop_d.regs[A_IDX] = 1;
+
+  asmop_x.type = AOP_REG;
+  asmop_x.size = 2;
+  asmop_x.aopu.aop_reg[0] = regsMC6809 + X_IDX;
+  memset (asmop_x.regs, -1, MAX_ASMOP_IDX + 1);
+  asmop_x.regs[XL_IDX] = 0;
+  asmop_x.regs[XH_IDX] = 1;
+
+  asmop_y.type = AOP_REG;
+  asmop_y.size = 2;
+  asmop_y.aopu.aop_reg[0] = regsMC6809 + Y_IDX;
+  memset (asmop_y.regs, -1, MAX_ASMOP_IDX + 1);
+  asmop_y.regs[YL_IDX] = 0;
+  asmop_y.regs[YH_IDX] = 1;
+
+  asmop_u.type = AOP_REG;
+  asmop_u.size = 2;
+  asmop_u.aopu.aop_reg[0] = regsMC6809 + U_IDX;
+  memset (asmop_u.regs, -1, MAX_ASMOP_IDX + 1);
+  asmop_u.regs[UL_IDX] = 0;
+  asmop_u.regs[UH_IDX] = 1;
+}
+
+static bool regalloc_dry_run;
+static unsigned int regalloc_dry_run_cost;
+
+static void
+cost(unsigned int bytes, unsigned int cycles)
+{
+  regalloc_dry_run_cost += bytes;
+}
+
+static void
+cost2(unsigned int bytes, unsigned int cycles_mc6809)
+{
+  regalloc_dry_run_cost += bytes;
+}
+
+/*-----------------------------------------------------------------*/
+/* aopRS - asmop in register or on stack                           */
+/*-----------------------------------------------------------------*/
+static bool
+aopRS (const asmop *aop)
+{
+  return (aop->type == AOP_REG || aop->type == AOP_STK);
+}
+
+/*-----------------------------------------------------------------*/
+/* aopIsLitVal - asmop from offset is val                          */
+/*-----------------------------------------------------------------*/
+static bool
+aopIsLitVal (const asmop *aop, int offset, int size, unsigned long long int val)
+{
+  wassert (size <= sizeof (unsigned long long int)); // Make sure we are not testing outside of argument val.
+
+  for(; size; size--, offset++)
+    {
+      unsigned char b = val & 0xff;
+      val >>= 8;
+
+      // Leading zeroes
+      if (aop->size <= offset && !b && aop->type != AOP_LIT)
+        continue;
+
+      if (aop->type != AOP_LIT)
+        return (false);
+
+      if (byteOfVal (aop->aopu.aop_lit, offset) != b)
+        return (false);
+    }
+
+  return (true);
+}
+
+/*-----------------------------------------------------------------*/
+/* aopInReg - asmop from offset in the register                    */
+/*-----------------------------------------------------------------*/
+static inline bool
+aopInReg (const asmop *aop, int offset, short rIdx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* aopOnStack - asmop from offset on stack in consecutive memory   */
+/*-----------------------------------------------------------------*/
+static bool
+aopOnStack (const asmop *aop, int offset, int size)
+{
+  if (!(aop->type == AOP_STK))
+    return (false);
+
+  if (offset + size > aop->size)
+    return (false);
+
+  return (true);
+}
+
+/* WARNING: This function is dangerous to use. It works literally:
+   It will return true if ic the the last use of op, even if ic might
+   be executed again, e.g. due to a loop. Most of the time you will want
+   to use isPairDead(), or ic->rSurv instead of this function. */
+static bool
+isLastUse (const iCode * ic, operand * op)
+{
+  bitVect *uses = bitVectCopy (OP_USES (op));
+
+  while (!bitVectIsZero (uses))
+    {
+      if (bitVectFirstBit (uses) == ic->key)
+        {
+          if (bitVectnBitsOn (uses) == 1)
+            {
+              return TRUE;
+            }
+          else
+            {
+              return FALSE;
+            }
+        }
+      bitVectUnSetBit (uses, bitVectFirstBit (uses));
+    }
+
+  return FALSE;
+}
+
+static void
+_tidyUp (char *buf)
+{
+  /* Clean up the line so that it is 'prettier' */
+  /* If it is a label - can't do anything */
+  if (!strchr (buf, ':'))
+    {
+      /* Change the first (and probably only) ' ' to a tab so
+         everything lines up.
+       */
+      while (*buf)
+        {
+          if (*buf == ' ')
+            {
+              *buf = '\t';
+              break;
+            }
+          buf++;
+        }
+    }
+}
+
+static void
+_vemit2 (const char *szFormat, va_list ap)
+{
+  struct dbuf_s dbuf;
+  char *buffer, *p, *nextp;
+
+  dbuf_init (&dbuf, INITIAL_INLINEASM);
+
+  dbuf_tvprintf (&dbuf, szFormat, ap);
+
+  buffer = p = dbuf_detach_c_str (&dbuf);
+
+  _tidyUp (p);
+
+  /* Decompose multiline macros */
+  while ((nextp = strchr (p, '\n')))
+    {
+      *nextp = '\0';
+      emit_raw (p);
+      p = nextp + 1;
+    }
+
+  emit_raw (p);
+
+  dbuf_free (buffer);
+}
+
+static void
+emitDebug (const char *szFormat, ...)
+{
+  if (!DISABLE_DEBUG && !regalloc_dry_run && options.verboseAsm)
+    {
+      va_list ap;
+
+      va_start (ap, szFormat);
+      _vemit2 (szFormat, ap);
+      va_end (ap);
+    }
+}
+
+static void
+emit2 (const char *szFormat, ...)
+{
+  if (!regalloc_dry_run)
+    {
+      va_list ap;
+
+      va_start (ap, szFormat);
+      _vemit2 (szFormat, ap);
+      va_end (ap);
+    }
+}
+
+
+/*-----------------------------------------------------------------*/
+/* mc6809_emitDebuggerSymbol - associate the current code location    */
+/*   with a debugger symbol                                        */
+/*-----------------------------------------------------------------*/
+void
+mc6809_emitDebuggerSymbol (const char *debugSym)
+{
+  genLine.lineElement.isDebug = 1;
+  emit2 ("%s !equ .", debugSym);
+  emit2 ("!global", debugSym);
+  genLine.lineElement.isDebug = 0;
+}
+
+// Todo: Handle IY correctly.
+static unsigned char
+ld_cost (const asmop *op1, const asmop *op2)
+{
+  AOP_TYPE op1type = op1->type;
+  AOP_TYPE op2type = op2->type;
+
+  /* Costs are symmetric */
+  if (op2type == AOP_REG || op2type == AOP_DUMMY)
+    {
+      const asmop *tmp = op1;
+      op1 = op2;
+      op2 = tmp;
+      op1type = op1->type;
+      op2type = op2->type;
+    }
+
+  switch (op1type)
+    {
+    case AOP_REG:
+    case AOP_DUMMY:
+      switch (op2type)
+        {
+        case AOP_REG:
+        case AOP_DUMMY:
+          return (1);
+        case AOP_IMMD:
+        case AOP_LIT:
+          return (2);
+        case AOP_STK:
+          return (3);
+        case AOP_IY:
+        default:
+          printf ("ld_cost op1: AOP_REG, op2: %d\n", (int) (op2type));
+          wassert (0);
+        }
+    case AOP_IY:
+      switch (op2type)
+        {
+        case AOP_IMMD:
+        case AOP_LIT:
+          return (8);
+        case AOP_STK:
+          return (10);
+        case AOP_IY:
+          return (16);
+        default:
+          printf ("ld_cost op1: AOP_IY, op2: %d\n", (int) (op2type));
+          wassert (0);
+        }
+    case AOP_STK:
+      switch (op2type)
+        {
+        case AOP_IMMD:
+        case AOP_LIT:
+          return (4);
+        case AOP_STK:
+          return (6);
+        case AOP_IY:
+          return (10);
+        default:
+          printf ("ld_cost op1: AOP_STK, op2: %d\n", (int) (op2type));
+          wassert (0);
+        }
+    case AOP_LIT:
+    case AOP_IMMD:
+      wassertl (0, "Trying to assign a value to a literal");
+      break;
+    default:
+      printf ("ld_cost op1: %d\n", (int) (op1type));
+      wassert (0);
+    }
+  return (8);                   // Fallback
+}
+
+static unsigned char
+op8_cost (const asmop * op2)
+{
+  switch (op2->type)
+    {
+    case AOP_REG:
+    case AOP_DUMMY:
+      return (1);
+    case AOP_IMMD:
+    case AOP_LIT:
+      return (2);
+    case AOP_STK:
+      return (3);
+    case AOP_IY:
+      return (7);
+    default:
+      printf ("op8_cost op2: %d\n", (int) (op2->type));
+      wassert (0);
+    }
+  return (8);                   // Fallback
+}
+
+static unsigned char
+bit8_cost (const asmop * op1)
+{
+  switch (op1->type)
+    {
+    case AOP_REG:
+    case AOP_DUMMY:
+      return (2);
+    case AOP_STK:
+      return (4);
+    case AOP_IY:
+      return (8);
+    default:
+      printf ("bit8_cost op1: %d\n", (int) (op1->type));
+      wassert (0);
+    }
+  return (8);                   //Fallback
+}
+
+static unsigned char
+emit3Cost (enum asminst inst, const asmop *op1, int offset1, const asmop *op2, int offset2)
+{}
+
+static void
+emit3_o (enum asminst inst, asmop *op1, int offset1, asmop *op2, int offset2)
+{
+  BUILD_BUG_ON((A_MAX+1)-(sizeof(asminstnames)/sizeof(asminstnames[0])));
+
+  unsigned char cost;
+
+  regalloc_dry_run_cost += emit3Cost (inst, op1, offset1, op2, offset2);
+  if (regalloc_dry_run)
+    return;
+
+  cost = regalloc_dry_run_cost;
+  if (!op1)
+    emit2 ("%s", asminstnames[inst]);
+  else if (!op2)
+    emit2 ("%s %s", asminstnames[inst], aopGet (op1, offset1, FALSE));
+  else
+    {
+      char *l = Safe_strdup (aopGet (op1, offset1, FALSE));
+      //emit2("%s %s, %s", asminstnames[inst], aopGet(op1, offset1, FALSE), aopGet(op2, offset2, FALSE));
+      emit2 ("%s %s, %s", asminstnames[inst], l, aopGet (op2, offset2, FALSE));
+      Safe_free (l);
+    }
+
+  regalloc_dry_run_cost = cost;
+  //emitDebug(";emit3_o cost: %d total so far: %d", (int)emit3Cost(inst, op1, offset1, op2, offset2), (int)cost);
+}
+
+static void
+emit3 (enum asminst inst, asmop *op1, asmop *op2)
+{
+  emit3_o (inst, op1, 0, op2, 0);
+}
+
+static void
+_emitMove (const char *to, const char *from)
+{
+}
+
+static void
+_emitMove3 (asmop *to, int to_offset, asmop *from, int from_offset)
+{}
+
+static void
+_moveA (const char *moveFrom)
+{
+  _emitMove ("a", moveFrom);
+}
+
+/* Load aop into A */
+static void
+_moveA3 (asmop * from, int offset)
+{
+  _emitMove3 (ASMOP_A, 0, from, offset);
+}
+
+/*-----------------------------------------------------------------*/
+/* newAsmop - creates a new asmOp                                  */
+/*-----------------------------------------------------------------*/
+static asmop *
+newAsmop (short type)
+{
+  asmop *aop;
+
+  aop = traceAlloc (&_G.trace.aops, Safe_alloc (sizeof (asmop)));
+  aop->type = type;
+  memset (aop->regs, -1, MAX_ASMOP_IDX + 1);
+  return aop;
+}
+
+/*-----------------------------------------------------------------*/
+/* aopForSym - for a true symbol                                   */
+/*-----------------------------------------------------------------*/
+static asmop *
+aopForSym (const iCode * ic, symbol * sym, bool requires_a)
+{
+  asmop *aop;
+  memmap *space;
+
+  wassert (ic);
+  wassert (sym);
+  wassert (sym->etype);
+
+  space = SPEC_OCLS (sym->etype);
+
+  /* if already has one */
+  if (sym->aop)
+    {
+      return sym->aop;
+    }
+
+  /* Assign depending on the storage class */
+  if (sym->onStack || sym->iaccess)
+    {
+        {
+          emitDebug ("; AOP_STK for %s", sym->rname);
+          sym->aop = aop = newAsmop (AOP_STK);
+        }
+
+      aop->size = getSize (sym->type);
+      aop->aopu.aop_stk = sym->stack;
+      return aop;
+    }
+
+  /* special case for a function */
+  if (IS_FUNC (sym->type))
+    {
+      sym->aop = aop = newAsmop (AOP_IMMD);
+      aop->aopu.aop_immd = traceAlloc (&_G.trace.aops, Safe_strdup (sym->rname));
+      aop->size = 2;
+      return aop;
+    }
+
+  /* only remaining is far space */
+  /* in which case DPTR gets the address */
+  if (IY_RESERVED)
+    {
+    }
+  else
+    sym->aop = aop = newAsmop (AOP_IY);
+
+  aop->size = getSize (sym->type);
+  aop->aopu.aop_dir = sym->rname;
+
+  /* if it is in code space */
+  if (IN_CODESPACE (space))
+    aop->code = 1;
+
+  return aop;
+}
+
+/*-----------------------------------------------------------------*/
+/* aopForRemat - rematerializes an object                          */
+/*-----------------------------------------------------------------*/
+static asmop *
+aopForRemat (symbol *sym)
+{
+  iCode *ic = sym->rematiCode;
+  asmop *aop = newAsmop (AOP_IMMD);
+  int val = 0;
+  struct dbuf_s dbuf;
+
+  wassert(ic);
+
+  for (;;)
+    {
+      if (ic->op == '+')
+        {
+          if (isOperandLiteral (IC_RIGHT (ic)))
+            {
+              val += (int) operandLitValue (IC_RIGHT (ic));
+              ic = OP_SYMBOL (IC_LEFT (ic))->rematiCode;
+            }
+          else
+            {
+              val += (int) operandLitValue (IC_LEFT (ic));
+              ic = OP_SYMBOL (IC_RIGHT (ic))->rematiCode;
+            }
+        }
+      else if (ic->op == '-')
+        {
+          val -= (int) operandLitValue (IC_RIGHT (ic));
+          ic = OP_SYMBOL (IC_LEFT (ic))->rematiCode;
+        }
+      else if (IS_CAST_ICODE (ic))
+        {
+          ic = OP_SYMBOL (IC_RIGHT (ic))->rematiCode;
+        }
+      else if (ic->op == ADDRESS_OF)
+        {
+          val += (int) operandLitValue (IC_RIGHT (ic));
+          break;
+        }
+      else
+        break;
+    }
+
+  dbuf_init (&dbuf, 128);
+  if (val)
+    {
+      dbuf_printf (&dbuf, "(%s %c 0x%04x)", OP_SYMBOL (IC_LEFT (ic))->rname, val >= 0 ? '+' : '-', abs (val) & 0xffff);
+    }
+  else
+    {
+      dbuf_append_str (&dbuf, OP_SYMBOL (IC_LEFT (ic))->rname);
+    }
+
+  aop->aopu.aop_immd = traceAlloc (&_G.trace.aops, dbuf_detach_c_str (&dbuf));
+  return aop;
+}
+
+/*-----------------------------------------------------------------*/
+/* regsInCommon - two operands have some registers in common       */
+/*-----------------------------------------------------------------*/
+static bool
+regsInCommon (operand * op1, operand * op2)
+{
+  symbol *sym1, *sym2;
+  int i;
+
+  /* if they have registers in common */
+  if (!IS_SYMOP (op1) || !IS_SYMOP (op2))
+    return FALSE;
+
+  sym1 = OP_SYMBOL (op1);
+  sym2 = OP_SYMBOL (op2);
+
+  if (sym1->nRegs == 0 || sym2->nRegs == 0)
+    return FALSE;
+
+  for (i = 0; i < sym1->nRegs; i++)
+    {
+      int j;
+      if (!sym1->regs[i])
+        continue;
+
+      for (j = 0; j < sym2->nRegs; j++)
+        {
+          if (!sym2->regs[j])
+            continue;
+
+          if (sym2->regs[j] == sym1->regs[i])
+            return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+/*-----------------------------------------------------------------*/
+/* operandsEqu - equivalent                                        */
+/*-----------------------------------------------------------------*/
+static bool
+operandsEqu (operand * op1, operand * op2)
+{
+  symbol *sym1, *sym2;
+
+  /* if they not symbols */
+  if (!IS_SYMOP (op1) || !IS_SYMOP (op2))
+    return FALSE;
+
+  sym1 = OP_SYMBOL (op1);
+  sym2 = OP_SYMBOL (op2);
+
+  /* if both are itemps & one is spilt
+     and the other is not then false */
+  if (IS_ITEMP (op1) && IS_ITEMP (op2) && sym1->isspilt != sym2->isspilt)
+    return FALSE;
+
+  /* if they are the same */
+  if (sym1 == sym2)
+    return 1;
+
+  if (sym1->rname[0] && sym2->rname[0] && strcmp (sym1->rname, sym2->rname) == 0)
+    return 2;
+
+  /* if left is a tmp & right is not */
+  if (IS_ITEMP (op1) && !IS_ITEMP (op2) && sym1->isspilt && (sym1->usl.spillLoc == sym2))
+    return 3;
+
+  if (IS_ITEMP (op2) && !IS_ITEMP (op1) && sym2->isspilt && sym1->level > 0 && (sym2->usl.spillLoc == sym1))
+    return 4;
+
+  return FALSE;
+}
+
+/*-----------------------------------------------------------------*/
+/* sameRegs - two asmops have the same registers                   */
+/*-----------------------------------------------------------------*/
+static bool
+sameRegs (asmop * aop1, asmop * aop2)
+{}
+
+/*-----------------------------------------------------------------*/
+/* aopOp - allocates an asmop for an operand  :                    */
+/*-----------------------------------------------------------------*/
+static void
+aopOp (operand *op, const iCode *ic, bool result, bool requires_a)
+{}
+
+/*-----------------------------------------------------------------*/
+/* freeAsmop - free up the asmop given to an operand               */
+/*----------------------------------------------------------------*/
+static void
+freeAsmop (operand * op, asmop *aaop)
+{
+  asmop *aop;
+
+  if (!op)
+    aop = aaop;
+  else
+    aop = op->aop;
+
+  if (!aop)
+    return;
+
+  if (aop->freed)
+    goto dealloc;
+
+  aop->freed = 1;
+
+dealloc:
+  /* all other cases just dealloc */
+  if (op)
+    {
+      op->aop = NULL;
+      if (IS_SYMOP (op))
+        {
+          OP_SYMBOL (op)->aop = NULL;
+          /* if the symbol has a spill */
+          if (SPIL_LOC (op))
+            SPIL_LOC (op)->aop = NULL;
+        }
+    }
+
+}
+
+static bool
+isLitWord (const asmop *aop)
+{
+  switch (aop->type)
+    {
+    case AOP_IMMD:
+    case AOP_LIT:
+      return TRUE;
+    default:
+      return FALSE;
+    }
+}
+
+static const char *
+aopGetLitWordLong (const asmop *aop, int offset, bool with_hash)
+{
+  static struct dbuf_s dbuf = { 0 };
+
+  if (dbuf_is_initialized (&dbuf))
+    {
+      dbuf_set_length (&dbuf, 0);
+    }
+  else
+    {
+      dbuf_init (&dbuf, 128);
+    }
+
+  /* depending on type */
+  switch (aop->type)
+    {
+    case AOP_IY:
+    case AOP_IMMD:
+      /* PENDING: for re-target */
+      if (with_hash)
+        {
+          dbuf_tprintf (&dbuf, "!hashedstr + %d", aop->aopu.aop_immd, offset);
+        }
+      else if (offset == 0)
+        {
+          dbuf_tprintf (&dbuf, "%s", aop->aopu.aop_immd);
+        }
+      else
+        {
+          dbuf_tprintf (&dbuf, "%s + %d", aop->aopu.aop_immd, offset);
+        }
+      break;
+
+    case AOP_LIT:
+    {
+      value *val = aop->aopu.aop_lit;
+      /* if it is a float then it gets tricky */
+      /* otherwise it is fairly simple */
+      if (!IS_FLOAT (val->type))
+        {
+          unsigned long long v = ullFromVal (val);
+
+          v >>= (offset * 8);
+
+          dbuf_tprintf (&dbuf, with_hash ? "!immedword" : "!constword", (unsigned long) (v & 0xffffull));
+        }
+      else
+        {
+          union
+          {
+            float f;
+            unsigned char c[4];
+          }
+          fl;
+          unsigned int i;
+
+          /* it is type float */
+          fl.f = (float) floatFromVal (val);
+
+#ifdef WORDS_BIGENDIAN
+          i = fl.c[3 - offset] | (fl.c[3 - offset - 1] << 8);
+#else
+          i = fl.c[offset] | (fl.c[offset + 1] << 8);
+#endif
+          dbuf_tprintf (&dbuf, with_hash ? "!immedword" : "!constword", i);
+        }
+    }
+    break;
+
+    case AOP_REG:
+    case AOP_STK:
+    case AOP_DIR:
+    case AOP_STR:
+    case AOP_COND:
+    case AOP_DUMMY:
+      break;
+
+    default:
+      dbuf_destroy (&dbuf);
+      fprintf (stderr, "aop->type: %d\n", aop->type);
+      wassertl (0, "aopGetLitWordLong got unsupported aop->type");
+      exit (0);
+    }
+  return dbuf_c_str (&dbuf);
+}
+
+static bool
+isPtr (const char *s)
+{
+  if (!strcmp (s, "x"))
+    return TRUE;
+  if (!strcmp (s, "y"))
+    return TRUE;
+  if (!strcmp (s, "u"))
+    return TRUE;
+  return FALSE;
+}
+
+static void
+spillCached (void)
+{
+}
+
+/*----------------------------------------------------------*/
+/* strtoul_asm: a wrapper to strtoul, which can also handle */
+/* hex numbers with a $ prefix.                             */
+/*----------------------------------------------------------*/
+static unsigned long int
+strtoul_asm (const char *nptr, char **endptr, int base)
+{
+  char *p = NULL;
+  int i, flag = 0, len;
+  unsigned long ret;
+
+  if (nptr != NULL && (p = malloc ((len = strlen (nptr)) + 1 + 1)) != NULL)
+    {
+      memset (p, 0, len + 2);
+      for (i = 0; i < len; i++)
+        {
+          if (!flag)
+            if (isspace (nptr[i]))
+              p[i] = nptr[i];
+            else if (nptr[i] == '$')
+              {
+                p[i] = '0';
+                p[i + 1] = 'x';
+                flag = 1;
+              }
+            else
+              break;
+          else
+            p[i + 1] = nptr[i];
+        }
+    }
+
+  if (flag)
+    ret = strtoul (p, endptr, base);
+  else
+    ret = strtoul (nptr, endptr, base);
+
+  if (p)
+    free (p);
+  return ret;
+}
+
+static void
+emitLabelSpill (symbol *tlbl)
+{
+  emitLabel (tlbl);
+  spillCached ();
+}
+
+/*-----------------------------------------------------------------*/
+/* aopGet - for fetching value of the aop                          */
+/*-----------------------------------------------------------------*/
+static const char *
+aopGet (asmop *aop, int offset, bool bit16)
+{
+  static struct dbuf_s dbuf = { 0 };
+
+  wassert_bt (!regalloc_dry_run);
+
+  if (dbuf_is_initialized (&dbuf))
+    {
+      /* reuse the dynamically allocated buffer */
+      dbuf_set_length (&dbuf, 0);
+    }
+  else
+    {
+      /* first time: initialize the dynamically allocated buffer */
+      dbuf_init (&dbuf, 128);
+    }
+
+  /* offset is greater than size then zero */
+  /* PENDING: this seems a bit screwed in some pointer cases. */
+  if (offset > (aop->size - 1) && aop->type != AOP_LIT)
+    {
+      dbuf_tprintf (&dbuf, "!zero");
+    }
+  else
+    {
+      /* depending on type */
+      switch (aop->type)
+        {
+        case AOP_DUMMY:
+          dbuf_append_char (&dbuf, 'a');
+          break;
+
+        case AOP_IMMD:
+          /* PENDING: re-target */
+          if (bit16)
+            dbuf_tprintf (&dbuf, "!immedword", aop->aopu.aop_immd);
+          else
+            {
+              switch (offset)
+                {
+                case 2:
+                  // dbuf_tprintf (&dbuf, "!bankimmeds", aop->aopu.aop_immd); Bank support not fully implemented yet.
+                  dbuf_tprintf (&dbuf, "#0x00");
+                  break;
+
+                case 1:
+                  dbuf_tprintf (&dbuf, "!msbimmeds", aop->aopu.aop_immd);
+                  break;
+
+                case 0:
+                  dbuf_tprintf (&dbuf, "!lsbimmeds", aop->aopu.aop_immd);
+                  break;
+
+                default:
+                  dbuf_tprintf (&dbuf, "#0x00");
+                }
+            }
+          break;
+
+        case AOP_DIR:
+          break;
+
+        case AOP_REG:
+          break;
+
+        case AOP_IY:
+          dbuf_tprintf (&dbuf, "!*iyx", offset);
+          break;
+
+        case AOP_STK:
+          if (_G.omitFramePtr)
+            {
+              if (aop->aopu.aop_stk >= 0)
+                offset += _G.stack.param_offset;
+              dbuf_tprintf (&dbuf, "!*ixx", offset);
+            }
+          else
+            {
+              if (aop->aopu.aop_stk >= 0)
+                offset += _G.stack.param_offset;
+              dbuf_tprintf (&dbuf, "!*ixx", aop->aopu.aop_stk + offset);
+            }
+          break;
+
+        case AOP_COND:
+          wassertl (0, "Tried to fetch from a bit variable");
+          break;
+
+        case AOP_LIT:
+          dbuf_append_str (&dbuf, aopLiteral (aop->aopu.aop_lit, offset));
+          break;
+
+        case AOP_STR:
+          aop->coff = offset;
+          dbuf_append_str (&dbuf, aop->aopu.aop_str[offset]);
+          break;
+
+        default:
+          dbuf_destroy (&dbuf);
+          fprintf (stderr, "aop->type: %d\n", aop->type);
+          wassertl (0, "aopGet got unsupported aop->type");
+          exit (0);
+        }
+    }
+  return dbuf_c_str (&dbuf);
+}
+
+static bool
+isRegString (const char *s)
+{
+  if (!strcmp (s, "a") || !strcmp (s, "b") || !strcmp (s, "d"))
+    return TRUE;
+  return FALSE;
+}
+
+static bool
+isConstantString (const char *s)
+{
+  /* This is a bit of a hack... */
+  return (*s == '#' || *s == '$');
+}
+
+#define AOP(op) op->aop
+#define AOP_TYPE(op) AOP(op)->type
+#define AOP_SIZE(op) AOP(op)->size
+
+static bool
+canAssignToPtr (const char *s)
+{
+  if (isRegString (s))
+    return TRUE;
+  if (isConstantString (s))
+    return TRUE;
+  return FALSE;
+}
+
+static bool
+canAssignToPtr3 (const asmop *aop)
+{
+  if (aop->type == AOP_REG)
+    return (TRUE);
+  if (aop->type == AOP_IMMD || aop->type == AOP_LIT)
+    return (TRUE);
+  return (FALSE);
+}
+
+/*-----------------------------------------------------------------*/
+/* aopPut - puts a string for a aop                                */
+/*-----------------------------------------------------------------*/
+static void
+aopPut (asmop *aop, const char *s, int offset)
+{
+  struct dbuf_s dbuf;
+
+  wassert (!regalloc_dry_run);
+
+  if (aop->size && offset > (aop->size - 1))
+    {
+      werror_bt (E_INTERNAL_ERROR, __FILE__, __LINE__, "aopPut got offset > aop->size");
+      exit (0);
+    }
+
+  // PENDING
+  dbuf_init (&dbuf, 128);
+  dbuf_tprintf (&dbuf, s);
+  s = dbuf_c_str (&dbuf);
+
+  /* will assign value to value */
+  /* depending on where it is of course */
+  switch (aop->type)
+    {
+    case AOP_DUMMY:
+      _moveA (s);               /* in case s is volatile */
+      break;
+
+    case AOP_DIR:
+      break;
+
+    case AOP_REG:
+      break;
+
+    case AOP_IY:
+      break;
+
+    case AOP_STK:
+      break;
+
+    case AOP_COND:
+      /* if bit variable */
+        {
+          /* In bit space but not in C - cant happen */
+          wassertl (0, "Tried to write into a bit variable");
+        }
+      break;
+
+    case AOP_STR:
+      break;
+
+    default:
+      dbuf_destroy (&dbuf); fprintf (stderr, "AOP_DIR: %d\n",AOP_DIR);
+      fprintf (stderr, "aop->type: %d\n", aop->type);
+      werror (E_INTERNAL_ERROR, __FILE__, __LINE__, "aopPut got unsupported aop->type");
+      exit (0);
+    }
+  dbuf_destroy (&dbuf);
+}
+
+// Move, but try not to. Cannot use xor to zero, since xor resets the carry flag.
+static void
+cheapMove (asmop *to, int to_offset, asmop *from, int from_offset, bool a_dead)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genCopyStack - Copy the value - stack to stack only             */
+/*-----------------------------------------------------------------*/
+static void
+genCopyStack (asmop *result, int roffset, asmop *source, int soffset, int n, bool *assigned, int *size, bool a_free, bool hl_free, bool really_do_it_now)
+{
+  for (int i = 0; i < n;)
+    {
+      if (assigned[i])
+        {
+          i++;
+          continue;
+        }
+
+      if (!aopOnStack (result, roffset + i, 1) || !aopOnStack (source, soffset + i, 1))
+        {
+          i++;
+          continue;
+        }
+
+      if (a_free || really_do_it_now)
+        {
+          cheapMove (result, roffset + i, source, soffset + i, a_free);
+          assigned[i] = true;
+          (*size)--;
+          i++;
+          continue;
+        }
+
+       i++;
+    }
+
+  wassertl_bt (*size >= 0, "genCopyStack() copied more than there is to be copied.");
+}
+
+/*-----------------------------------------------------------------*/
+/* genCopy - Copy the value from one reg/stk asmop to another      */
+/*-----------------------------------------------------------------*/
+static void
+genCopy (asmop *result, int roffset, asmop *source, int soffset, int sizex, bool a_dead, bool hl_dead)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genMove_o - Copy part of one asmop to another                   */
+/*-----------------------------------------------------------------*/
+static void
+genMove_o (asmop *result, int roffset, asmop *source, int soffset, int size, bool a_dead_global, bool hl_dead_global)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genMove - Copy the value from one asmop to another              */
+/*-----------------------------------------------------------------*/
+static void
+genMove (asmop *result, asmop *source, bool a_dead, bool hl_dead)
+{
+  genMove_o (result, 0, source, 0, result->size, a_dead, hl_dead);
+}
+
+/*-----------------------------------------------------------------*/
+/* getDataSize - get the operand data size                         */
+/*-----------------------------------------------------------------*/
+static int
+getDataSize (operand * op)
+{
+  int size;
+  size = AOP_SIZE (op);
+  if (size == 3)
+    {
+      /* pointer */
+      wassertl (0, "Somehow got a three byte data pointer");
+    }
+  return size;
+}
+
+/*--------------------------------------------------------------------------*/
+/* adjustStack - Adjust the stack pointer by n bytes.                       */
+/*--------------------------------------------------------------------------*/
+static void
+adjustStack (int n, bool af_free, bool bc_free, bool hl_free, bool iy_free)
+{}
+
+/*-----------------------------------------------------------------*/
+/* movLeft2Result - move byte from left to result                  */
+/*-----------------------------------------------------------------*/
+static void
+movLeft2Result (operand *left, int offl, operand *result, int offr, int sign)
+{
+  if (!sameRegs (AOP (left), AOP (result)) || (offl != offr))
+    {
+      if (!sign)
+        cheapMove (AOP (result), offr, AOP (left), offl, true);
+      else
+        {
+          if (getDataSize (left) == offl + 1)
+            {
+              cheapMove (ASMOP_A, 0, AOP (left), offl, true);
+              cheapMove (AOP (result), offr, ASMOP_A, 0, true);
+            }
+        }
+    }
+}
+
+/** Put Acc into a register set
+ */
+static void
+outAcc (operand * result)
+{}
+
+/** Take the value in carry and put it into a register
+ */
+static void
+outBitC (operand * result)
+{}
+
+/*-----------------------------------------------------------------*/
+/* toBoolean - emit code for or a,operator(sizeop)                 */
+/*-----------------------------------------------------------------*/
+static void
+_toBoolean (const operand *oper, bool needflag)
+{}
+
+/*-----------------------------------------------------------------*/
+/* castBoolean - emit code for casting operand to boolean in a     */
+/*-----------------------------------------------------------------*/
+static void
+_castBoolean (const operand *right)
+{}
+
+/* Shuffle src reg array into dst reg array. */
+static void
+regMove (const short *dst, const short *src, size_t n, bool preserve_a)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genNot - generate code for ! operation                          */
+/*-----------------------------------------------------------------*/
+static void
+genNot (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genCpl - generate code for complement                           */
+/*-----------------------------------------------------------------*/
+static void
+genCpl (const iCode *ic)
+{}
+
+static void
+_mc6809_emitAddSubLongLong (const iCode * ic, asmop * left, asmop * right, bool isAdd)
+{}
+
+static void
+_mc6809_emitAddSubLong (const iCode * ic, bool isAdd)
+{
+  _mc6809_emitAddSubLongLong (ic, AOP (IC_LEFT (ic)), AOP (IC_RIGHT (ic)), isAdd);
+}
+
+/*-----------------------------------------------------------------*/
+/* assignResultValue -               */
+/*-----------------------------------------------------------------*/
+static void
+assignResultValue (operand * oper)
+{}
+
+/* Pop saved regs from stack, taking care not to destroy result */
+static void
+restoreRegs (bool iy, bool de, bool bc, bool hl, const operand *result)
+{}
+
+static void
+_saveRegsForCall (const iCode * ic, bool dontsaveIY)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genIpush - genrate code for pushing this gets a little complex  */
+/*-----------------------------------------------------------------*/
+static void
+genIpush (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genIpop - recover the registers: can happen only for spilling   */
+/*-----------------------------------------------------------------*/
+static void
+genIpop (const iCode * ic)
+{}
+
+/* This is quite unfortunate */
+static void
+setArea (int inHome)
+{
+  /*
+     static int lastArea = 0;
+
+     if (_G.in_home != inHome) {
+     if (inHome) {
+     const char *sz = port->mem.code_name;
+     port->mem.code_name = "HOME";
+     emit2("!area", CODE_NAME);
+     port->mem.code_name = sz;
+     }
+     else
+     emit2("!area", CODE_NAME); */
+  _G.in_home = inHome;
+  //    }
+}
+
+static bool
+isInHome (void)
+{
+  return _G.in_home;
+}
+
+/** Emit the code for a register parameter
+ */
+static void genSend (const iCode *ic)
+{}
+
+/** Emit the code for a call statement
+ */
+static void
+genCall (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* resultRemat - result  is rematerializable                       */
+/*-----------------------------------------------------------------*/
+static int
+resultRemat (const iCode * ic)
+{
+  if (SKIP_IC (ic) || ic->op == IFX)
+    return 0;
+
+  if (IC_RESULT (ic) && IS_ITEMP (IC_RESULT (ic)))
+    {
+      const symbol *sym = OP_SYMBOL_CONST (IC_RESULT (ic));
+      if (sym->remat && !POINTER_SET (ic) && sym->isspilt)
+        return 1;
+    }
+
+  return 0;
+}
+
+/*-----------------------------------------------------------------*/
+/* genFunction - generated code for function entry                 */
+/*-----------------------------------------------------------------*/
+static void
+genFunction (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genEndFunction - generates epilogue for functions               */
+/*-----------------------------------------------------------------*/
+static void
+genEndFunction (iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genRet - generate code for return statement                     */
+/*-----------------------------------------------------------------*/
+static void
+genRet (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genLabel - generates a label                                    */
+/*-----------------------------------------------------------------*/
+static void
+genLabel (const iCode * ic)
+{
+  /* special case never generate */
+  if (IC_LABEL (ic) == entryLabel)
+    return;
+
+  emitLabelSpill (IC_LABEL (ic));
+}
+
+/*-----------------------------------------------------------------*/
+/* genGoto - generates a ljmp                                      */
+/*-----------------------------------------------------------------*/
+static void
+genGoto (const iCode * ic)
+{}
+
+
+/*-----------------------------------------------------------------*/
+/* genPlusIncr :- does addition with increment if possible         */
+/*-----------------------------------------------------------------*/
+static bool
+genPlusIncr (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* outBitAcc - output a bit in acc                                 */
+/*-----------------------------------------------------------------*/
+static void
+outBitAcc (operand * result)
+{
+  symbol *tlbl = regalloc_dry_run ? 0 : newiTempLabel (0);
+  /* if the result is a bit */
+  if (AOP_TYPE (result) == AOP_COND)
+    {
+      wassertl (0, "Tried to write A into a bit");
+    }
+  else
+    {
+    }
+}
+
+static bool
+couldDestroyCarry (const asmop *aop)
+{
+  if (aop)
+    {
+      if (aop->type == AOP_IY)
+        {
+          return TRUE;
+        }
+    }
+  return FALSE;
+}
+
+static void
+setupToPreserveCarry (asmop *result, asmop *left, asmop *right)
+{
+  wassert (left && right);
+
+    {
+      if (couldDestroyCarry (right) && couldDestroyCarry (result))
+        {
+          /* check result again, in case right == result */
+          if (couldDestroyCarry (result))
+            {
+            }
+        }
+      else if (couldDestroyCarry (right))
+        {
+        }
+      else if (couldDestroyCarry (result))
+        {
+        }
+    }
+}
+
+/*-----------------------------------------------------------------*/
+/* genPlus - generates code for addition                           */
+/*-----------------------------------------------------------------*/
+static void
+genPlus (iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genSubDec :- does subtraction with decrement if possible        */
+/*-----------------------------------------------------------------*/
+static bool
+genMinusDec (const iCode *ic, asmop *result, asmop *left, asmop *right)
+{
+  unsigned int icount;
+  unsigned int size = getDataSize (IC_RESULT (ic));
+
+  /* will try to generate a decrement */
+  /* if the right side is not a literal we cannot */
+  if (right->type != AOP_LIT)
+    return false;
+
+  /* if the literal value of the right hand side
+     is greater than 4 then it is not worth it */
+  if ((icount = (unsigned int) ulFromVal (right->aopu.aop_lit)) > 2)
+    return false;
+
+  size = getDataSize (IC_RESULT (ic));
+
+  /* if the sizes are greater than 1 then we cannot */
+  if (result->size > 1 || left->size > 1)
+    return false;
+
+  /* we can if the aops of the left & result match or if they are in
+     registers and the registers are the same */
+  if (sameRegs (left, result))
+    {
+      while (icount--)
+        emit3 (A_DEC, result, 0);
+      return true;
+    }
+
+  if (result->type == AOP_REG)
+    {
+      cheapMove (result, 0, left, 0, true);
+      while (icount--)
+        emit3 (A_DEC, result, 0);
+      return true;
+    }
+
+  return false;
+}
+
+/*-----------------------------------------------------------------*/
+/* genSub - generates code for subtraction                       */
+/*-----------------------------------------------------------------*/
+static void
+genSub (const iCode *ic, asmop *result, asmop *left, asmop *right)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genMinus - generates code for subtraction                       */
+/*-----------------------------------------------------------------*/
+static void
+genMinus (const iCode *ic)
+{
+  aopOp (IC_LEFT (ic), ic, FALSE, FALSE);
+  aopOp (IC_RIGHT (ic), ic, FALSE, FALSE);
+  aopOp (IC_RESULT (ic), ic, TRUE, FALSE);
+
+  genSub (ic, AOP (IC_RESULT (ic)), AOP (IC_LEFT (ic)), AOP (IC_RIGHT (ic)));
+
+  _G.preserveCarry = FALSE;
+  freeAsmop (IC_LEFT (ic), NULL);
+  freeAsmop (IC_RIGHT (ic), NULL);
+  freeAsmop (IC_RESULT (ic), NULL);
+}
+
+/*-----------------------------------------------------------------*/
+/* genUminusFloat - unary minus for floating points                */
+/*-----------------------------------------------------------------*/
+static void
+genUminusFloat (operand *op, operand *result)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genUminus - unary minus code generation                         */
+/*-----------------------------------------------------------------*/
+static void
+genUminus (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genMultOneChar - generates code for unsigned 8x8 multiplication */
+/*-----------------------------------------------------------------*/
+static void
+genMultOneChar (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genMult - generates code for multiplication                     */
+/*-----------------------------------------------------------------*/
+static void
+genMult (iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genDiv - generates code for division                            */
+/*-----------------------------------------------------------------*/
+static void
+genDiv (const iCode * ic)
+{
+  /* Shouldn't occur - all done through function calls */
+  wassertl (0, "Division is handled through support function calls");
+}
+
+/*-----------------------------------------------------------------*/
+/* genMod - generates code for division                            */
+/*-----------------------------------------------------------------*/
+static void
+genMod (const iCode * ic)
+{
+  /* Shouldn't occur - all done through function calls */
+  wassert (0);
+}
+
+/*-----------------------------------------------------------------*/
+/* genIfxJump :- will create a jump depending on the ifx           */
+/*-----------------------------------------------------------------*/
+static void
+genIfxJump (iCode * ic, char *jval)
+{}
+
+/** Generic compare for > or <
+ */
+static void
+genCmp (operand * left, operand * right, operand * result, iCode * ifx, int sign, const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genCmpGt :- greater than comparison                             */
+/*-----------------------------------------------------------------*/
+static void
+genCmpGt (iCode * ic, iCode * ifx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genCmpLt - less than comparisons                                */
+/*-----------------------------------------------------------------*/
+static void
+genCmpLt (iCode * ic, iCode * ifx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* gencjne - compare and jump if not equal                         */
+/*-----------------------------------------------------------------*/
+static void
+gencjne (operand * left, operand * right, symbol * lbl, const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genCmpEq - generates code for equal to                          */
+/*-----------------------------------------------------------------*/
+static void
+genCmpEq (iCode * ic, iCode * ifx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genAndOp - for && operation                                     */
+/*-----------------------------------------------------------------*/
+static void
+genAndOp (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genOrOp - for || operation                                      */
+/*-----------------------------------------------------------------*/
+static void
+genOrOp (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* isLiteralBit - test if lit == 2^n                               */
+/*-----------------------------------------------------------------*/
+static int
+isLiteralBit (unsigned long lit)
+{
+  unsigned long pw[32] =
+  {
+    1L, 2L, 4L, 8L, 16L, 32L, 64L, 128L,
+    0x100L, 0x200L, 0x400L, 0x800L,
+    0x1000L, 0x2000L, 0x4000L, 0x8000L,
+    0x10000L, 0x20000L, 0x40000L, 0x80000L,
+    0x100000L, 0x200000L, 0x400000L, 0x800000L,
+    0x1000000L, 0x2000000L, 0x4000000L, 0x8000000L,
+    0x10000000L, 0x20000000L, 0x40000000L, 0x80000000L
+  };
+  int idx;
+
+  for (idx = 0; idx < 32; idx++)
+    if (lit == pw[idx])
+      return idx;
+  return -1;
+}
+
+/*-----------------------------------------------------------------*/
+/* jmpTrueOrFalse -                                                */
+/*-----------------------------------------------------------------*/
+static void
+jmpTrueOrFalse (iCode * ic, symbol * tlbl)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genAnd  - code for and                                          */
+/*-----------------------------------------------------------------*/
+static void
+genAnd (const iCode * ic, iCode * ifx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genOr  - code for or                                            */
+/*-----------------------------------------------------------------*/
+static void
+genOr (const iCode * ic, iCode * ifx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genXor - code for xclusive or                                   */
+/*-----------------------------------------------------------------*/
+static void
+genXor (const iCode *ic, iCode *ifx)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genRRC - rotate right with carry                                */
+/*-----------------------------------------------------------------*/
+static void
+genRRC (const iCode * ic)
+{
+  wassert (0);
+}
+
+/*-----------------------------------------------------------------*/
+/* genRLC - generate code for rotate left with carry               */
+/*-----------------------------------------------------------------*/
+static void
+genRLC (const iCode * ic)
+{
+  wassert (0);
+}
+
+/*-----------------------------------------------------------------*/
+/* genGetHbit - generates code get highest order bit               */
+/*-----------------------------------------------------------------*/
+static void
+genGetHbit (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genGetAbit - generates code get a single bit                    */
+/*-----------------------------------------------------------------*/
+static void
+genGetAbit (const iCode * ic)
+{
+  wassert (0);
+}
+
+static void
+emitRsh2 (asmop * aop, int size, int is_signed)
+{}
+
+/*-----------------------------------------------------------------*/
+/* shiftR2Left2Result - shift right two bytes from left to result  */
+/*-----------------------------------------------------------------*/
+static void
+shiftR2Left2Result (const iCode *ic, operand *left, int offl, operand *result, int offr, int shCount, int is_signed)
+{}
+
+/*-----------------------------------------------------------------*/
+/* shiftL2Left2Result - shift left two bytes from left to result   */
+/*-----------------------------------------------------------------*/
+static void
+shiftL2Left2Result (operand *left, operand *result, int shCount, const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* AccRol - rotate left accumulator by known count                 */
+/*-----------------------------------------------------------------*/
+static void
+AccRol (int shCount)
+{}
+
+/*-----------------------------------------------------------------*/
+/* AccLsh - left shift accumulator by known count                  */
+/*-----------------------------------------------------------------*/
+static void
+AccLsh (unsigned int shCount)
+{}
+
+/*-----------------------------------------------------------------*/
+/* shiftL1Left2Result - shift left one byte from left to result    */
+/*-----------------------------------------------------------------*/
+static void
+shiftL1Left2Result (operand *left, int offl, operand *result, int offr, unsigned int shCount, const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genlshTwo - left shift two bytes by known amount                */
+/*-----------------------------------------------------------------*/
+static void
+genlshTwo (operand *result, operand *left, unsigned int shCount, const iCode *ic)
+{}
+
+/*------------------------------------------------------------------*/
+/* genLeftShiftLiteral - left shifting by known count for size <= 2 */
+/*------------------------------------------------------------------*/
+static void
+genLeftShiftLiteral (operand *left, operand *right, operand *result, const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genLeftShift - generates code for left shifting                 */
+/*-----------------------------------------------------------------*/
+static void
+genLeftShift (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* AccRsh - right shift accumulator by known count                 */
+/*-----------------------------------------------------------------*/
+static void
+AccRsh (int shCount)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genrshOne - right shift one byte by known amount                */
+/*-----------------------------------------------------------------*/
+static void
+genrshOne (operand *result, operand *left, int shCount, int is_signed, const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* shiftR1Left2Result - shift right one byte from left to result   */
+/*-----------------------------------------------------------------*/
+static void
+shiftR1Left2Result (operand *left, int offl, operand *result, int offr, int shCount, int sign)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genrshTwo - right shift two bytes by known amount               */
+/*-----------------------------------------------------------------*/
+static void
+genrshTwo (const iCode * ic, operand * result, operand * left, int shCount, int sign)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genRightShiftLiteral - right shifting by known count              */
+/*-----------------------------------------------------------------*/
+static void
+genRightShiftLiteral (operand * left, operand * right, operand * result, const iCode *ic, int sign)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genRightShift - generate code for right shifting                */
+/*-----------------------------------------------------------------*/
+static void
+genRightShift (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* unpackMaskA - generate masking code for unpacking last byte     */
+/* of bitfiled. And mask for unsigned, sign extension for signed.  */
+/*-----------------------------------------------------------------*/
+static void
+unpackMaskA(sym_link *type, int len)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genUnpackBits - generates code for unpacking bits               */
+/*-----------------------------------------------------------------*/
+static void
+genUnpackBits (operand * result, int pair, const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genPointerGet - generate code for pointer get                   */
+/*-----------------------------------------------------------------*/
+static void
+genPointerGet (const iCode *ic)
+{}
+
+static bool
+isRegOrLit (asmop * aop)
+{
+  if (aop->type == AOP_REG || aop->type == AOP_LIT || aop->type == AOP_IMMD)
+    return true;
+  return false;
+}
+
+
+/*-----------------------------------------------------------------*/
+/* genPackBits - generates code for packed bit storage             */
+/*-----------------------------------------------------------------*/
+static void
+genPackBits (sym_link * etype, operand * right, int pair, const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genPointerSet - stores the value into a pointer location        */
+/*-----------------------------------------------------------------*/
+static void
+genPointerSet (iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genIfx - generate code for Ifx statement                        */
+/*-----------------------------------------------------------------*/
+static void
+genIfx (iCode *ic, iCode *popIc)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genAddrOf - generates code for address of                       */
+/*-----------------------------------------------------------------*/
+static void
+genAddrOf (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genAssign - generate code for assignment                        */
+/*-----------------------------------------------------------------*/
+static void
+genAssign (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genJumpTab - generate code for jump table                       */
+/*-----------------------------------------------------------------*/
+static void
+genJumpTab (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genCast - gen code for casting                                  */
+/*-----------------------------------------------------------------*/
+static void
+genCast (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genReceive - generate code for a receive iCode                  */
+/*-----------------------------------------------------------------*/
+static void
+genReceive (const iCode *ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genDummyRead - generate code for dummy read of volatiles        */
+/*-----------------------------------------------------------------*/
+static void
+genDummyRead (const iCode * ic)
+{
+  operand *op;
+  int size, offset;
+
+  op = IC_RIGHT (ic);
+  if (op && IS_SYMOP (op))
+    {
+      aopOp (op, ic, FALSE, FALSE);
+
+      /* general case */
+      size = AOP_SIZE (op);
+      offset = 0;
+
+      while (size--)
+        {
+          _moveA3 (AOP (op), offset);
+          offset++;
+        }
+
+      freeAsmop (op, NULL);
+    }
+
+  op = IC_LEFT (ic);
+  if (op && IS_SYMOP (op))
+    {
+      aopOp (op, ic, FALSE, FALSE);
+
+      /* general case */
+      size = AOP_SIZE (op);
+      offset = 0;
+
+      while (size--)
+        {
+          _moveA3 (AOP (op), offset);
+          offset++;
+        }
+
+      freeAsmop (op, NULL);
+    }
+}
+
+/*-----------------------------------------------------------------*/
+/* genCritical - generate code for start of a critical sequence    */
+/*-----------------------------------------------------------------*/
+static void
+genCritical (const iCode * ic)
+{}
+
+/*-----------------------------------------------------------------*/
+/* genEndCritical - generate code for end of a critical sequence   */
+/*-----------------------------------------------------------------*/
+static void
+genEndCritical (const iCode * ic)
+{}
+
+static void
+setupForMemcpy (const iCode *ic, const operand *to, const operand *from, const operand *count)
+{}
+
+static void
+setupForMemset (const iCode *ic, const operand *dst, const operand *c, bool direct_c)
+{}
+
+
+/*--------------------------------------------------------------------------------------------*/
+/* genMC6809iCode - generate code for MC6809 based controllers for a single iCode instruction */
+/*--------------------------------------------------------------------------------------------*/
+static void
+genMC6809iCode (iCode * ic)
+{
+  genLine.lineElement.ic = ic;
+
+  /* if the result is marked as
+     spilt and rematerializable or code for
+     this has already been generated then
+     do nothing */
+  if (resultRemat (ic) || ic->generated)
+    return;
+
+  /* depending on the operation */
+  switch (ic->op)
+    {
+    case '!':
+      emitDebug ("; genNot");
+      genNot (ic);
+      break;
+
+    case '~':
+      emitDebug ("; genCpl");
+      genCpl (ic);
+      break;
+
+    case UNARYMINUS:
+      emitDebug ("; genUminus");
+      genUminus (ic);
+      break;
+
+    case IPUSH:
+      emitDebug ("; genIpush");
+      genIpush (ic);
+      break;
+
+    case IPOP:
+      /* IPOP happens only when trying to restore a
+         spilt live range, if there is an ifx statement
+         following this pop then the if statement might
+         be using some of the registers being popped which
+         would destroy the contents of the register so
+         we need to check for this condition and handle it */
+      if (ic->next && ic->next->op == IFX && regsInCommon (IC_LEFT (ic), IC_COND (ic->next)))
+        {
+          emitDebug ("; genIfx");
+          genIfx (ic->next, ic);
+        }
+      else
+        {
+          emitDebug ("; genIpop");
+          genIpop (ic);
+        }
+      break;
+
+    case CALL:
+    case PCALL:
+      emitDebug ("; genCall");
+      genCall (ic);
+      break;
+
+    case FUNCTION:
+      emitDebug ("; genFunction");
+      genFunction (ic);
+      break;
+
+    case ENDFUNCTION:
+      emitDebug ("; genEndFunction");
+      genEndFunction (ic);
+      break;
+
+    case RETURN:
+      emitDebug ("; genRet");
+      genRet (ic);
+      break;
+
+    case LABEL:
+      emitDebug ("; genLabel");
+      genLabel (ic);
+      break;
+
+    case GOTO:
+      emitDebug ("; genGoto");
+      genGoto (ic);
+      break;
+
+    case '+':
+      emitDebug ("; genPlus");
+      genPlus (ic);
+      break;
+
+    case '-':
+      emitDebug ("; genMinus");
+      genMinus (ic);
+      break;
+
+    case '*':
+      emitDebug ("; genMult");
+      genMult (ic);
+      break;
+
+    case '/':
+      emitDebug ("; genDiv");
+      genDiv (ic);
+      break;
+
+    case '%':
+      emitDebug ("; genMod");
+      genMod (ic);
+      break;
+
+    case '>':
+      emitDebug ("; genCmpGt");
+      genCmpGt (ic, ifxForOp (IC_RESULT (ic), ic));
+      break;
+
+    case '<':
+      emitDebug ("; genCmpLt");
+      genCmpLt (ic, ifxForOp (IC_RESULT (ic), ic));
+      break;
+
+    case LE_OP:
+    case GE_OP:
+    case NE_OP:
+
+      /* note these two are xlated by algebraic equivalence
+         during parsing SDCC.y */
+      werror (E_INTERNAL_ERROR, __FILE__, __LINE__, "got '>=' or '<=' shouldn't have come here");
+      break;
+
+    case EQ_OP:
+      emitDebug ("; genCmpEq");
+      genCmpEq (ic, ifxForOp (IC_RESULT (ic), ic));
+      break;
+
+    case AND_OP:
+      emitDebug ("; genAndOp");
+      genAndOp (ic);
+      break;
+
+    case OR_OP:
+      emitDebug ("; genOrOp");
+      genOrOp (ic);
+      break;
+
+    case '^':
+      emitDebug ("; genXor");
+      genXor (ic, ifxForOp (IC_RESULT (ic), ic));
+      break;
+
+    case '|':
+      emitDebug ("; genOr");
+      genOr (ic, ifxForOp (IC_RESULT (ic), ic));
+      break;
+
+    case BITWISEAND:
+      emitDebug ("; genAnd");
+      genAnd (ic, ifxForOp (IC_RESULT (ic), ic));
+      break;
+
+    case INLINEASM:
+      emitDebug ("; genInline");
+      genInline (ic);
+      break;
+
+    case RRC:
+      emitDebug ("; genRRC");
+      genRRC (ic);
+      break;
+
+    case RLC:
+      emitDebug ("; genRLC");
+      genRLC (ic);
+      break;
+
+    case GETHBIT:
+      emitDebug ("; genGetHbit");
+      genGetHbit (ic);
+      break;
+
+    case GETABIT:
+      emitDebug ("; genGetAbit");
+      genGetAbit (ic);
+      break;
+
+    case LEFT_OP:
+      emitDebug ("; genLeftShift");
+      genLeftShift (ic);
+      break;
+
+    case RIGHT_OP:
+      emitDebug ("; genRightShift");
+      genRightShift (ic);
+      break;
+
+    case GET_VALUE_AT_ADDRESS:
+      emitDebug ("; genPointerGet");
+      genPointerGet (ic);
+      break;
+
+    case '=':
+
+      if (POINTER_SET (ic))
+        {
+          emitDebug ("; genAssign (pointer)");
+          genPointerSet (ic);
+        }
+      else
+        {
+          emitDebug ("; genAssign");
+          genAssign (ic);
+        }
+      break;
+
+    case IFX:
+      emitDebug ("; genIfx");
+      genIfx (ic, NULL);
+      break;
+
+    case ADDRESS_OF:
+      emitDebug ("; genAddrOf");
+      genAddrOf (ic);
+      break;
+
+    case JUMPTABLE:
+      emitDebug ("; genJumpTab");
+      genJumpTab (ic);
+      break;
+
+    case CAST:
+      emitDebug ("; genCast");
+      genCast (ic);
+      break;
+
+    case RECEIVE:
+      emitDebug ("; genReceive");
+      genReceive (ic);
+      break;
+
+    case SEND:
+        {
+          emitDebug ("; genSend");
+          genSend (ic);
+        }
+      break;
+
+    case DUMMY_READ_VOLATILE:
+      emitDebug ("; genDummyRead");
+      genDummyRead (ic);
+      break;
+
+    case CRITICAL:
+      emitDebug ("; genCritical");
+      genCritical (ic);
+      break;
+
+    case ENDCRITICAL:
+      emitDebug ("; genEndCritical");
+      genEndCritical (ic);
+      break;
+
+    default:
+      ;
+    }
+}
+
+unsigned char
+dryMC6809iCode (iCode * ic)
+{}
+
+#ifdef DEBUG_DRY_COST
+static void
+dryMC6809Code (iCode * lic)
+{
+  iCode *ic;
+
+  for (ic = lic; ic; ic = ic->next)
+    if (ic->op != FUNCTION && ic->op != ENDFUNCTION && ic->op != LABEL && ic->op != GOTO && ic->op != INLINEASM)
+      printf ("; iCode %d total cost: %d\n", ic->key, (int) (dryMC6809iCode (ic)));
+}
+#endif
+
+/*---------------------------------------------------------------------------------------*/
+/* genMC6809Code - generate code for MC6809 based controllers for a block of intructions */
+/*---------------------------------------------------------------------------------------*/
+void
+genMC6809Code (iCode * lic)
+{}
diff --git a/sdcc/src/mc6809/gen.h b/sdcc/src/mc6809/gen.h
new file mode 100644
index 000000000..7744749a9
--- /dev/null
+++ b/sdcc/src/mc6809/gen.h
@@ -0,0 +1,84 @@
+/*-------------------------------------------------------------------------
+  mc6809/gen.h - header file for code generation for MC6809
+
+             Written By -  Sandeep Dutta . sandeep.dutta@usa.net (1998)
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+-------------------------------------------------------------------------*/
+
+#ifndef MC6809GEN_H
+#define MC6809GEN_H
+
+typedef enum
+{
+  AOP_INVALID,
+  /* Is a literal */
+  AOP_LIT = 1,
+  /* Is in a register */
+  AOP_REG,
+  /* Is in direct space */
+  AOP_DIR,
+  /* Is on the stack */
+  AOP_STK,
+  /* Is an immediate value */
+  AOP_IMMD,
+  /* Is a string (?) */
+  AOP_STR,
+  /* Is in the condition register */
+  AOP_COND,
+  /* Is pointed to by index register X */
+  AOP_IX,
+  /* Is pointed to by index register Y */
+  AOP_IY,
+  /* Is pointed to by index register U */
+  AOP_IU,
+  /* Read undefined, discard writes */
+  AOP_DUMMY
+}
+AOP_TYPE;
+
+/* type asmop : a homogenised type for 
+   all the different spaces an operand can be
+   in */
+typedef struct asmop
+{
+  AOP_TYPE type;
+  short coff;                   /* current offset */
+  short size;                   /* total size */
+  unsigned code:1;              /* is in Code space */
+  unsigned paged:1;             /* in paged memory  */
+  unsigned freed:1;             /* already freed    */
+  union
+  {
+    value *aop_lit;             /* if literal */
+    reg_info *aop_reg[4];       /* array of registers */
+    char *aop_dir;              /* if direct  */
+    char *aop_immd;             /* if immediate others are implied */
+    int aop_stk;                /* stack offset when AOP_STK */
+    const char *aop_str[4];     /* just a string array containing the location */
+  }
+  aopu;
+  signed char regs[MAX_ASMOP_IDX + 1]; // Byte of this aop that is in the register. -1 if no byte of this aop is in the reg.
+}
+asmop;
+
+void genMC6809Code (iCode *);
+void mc6809_emitDebuggerSymbol (const char *);
+
+extern bool mc6809_assignment_optimal;
+extern bool mc6809_should_omit_frame_ptr;
+
+#endif
+
diff --git a/sdcc/src/mc6809/m6809.h b/sdcc/src/mc6809/m6809.h
new file mode 100644
index 000000000..8c98f5083
--- /dev/null
+++ b/sdcc/src/mc6809/m6809.h
@@ -0,0 +1,40 @@
+/** @file mc6809/m6809.h
+    Common definitions between the MC6809 and HD6309 CPUs.
+*/
+#include "common.h"
+#include "ralloc.h"
+#include "gen.h"
+#include "peep.h"
+#include "support.h"
+
+typedef enum
+  {
+    SUB_MC6809,
+    SUB_HD6309
+  }
+MC6809_SUB_PORT;
+
+typedef struct
+  {
+    MC6809_SUB_PORT sub;
+    int port_mode;
+    int port_back;
+    int reserveIY;
+    int noOmitFramePtr;
+  }
+MC6809_OPTS;
+
+extern MC6809_OPTS mc6809_opts;
+
+#define IS_MC6809 (mc6809_opts.sub == SUB_MC6809)
+
+#define IY_RESERVED (mc6809_opts.reserveIY)
+
+#define OPTRALLOC_IY !(IY_RESERVED)
+
+enum
+  {
+    ACCUSE_A = 1,
+    ACCUSE_SCRATCH,
+    ACCUSE_IY
+  };
diff --git a/sdcc/src/mc6809/main.c b/sdcc/src/mc6809/main.c
new file mode 100644
index 000000000..97877c41e
--- /dev/null
+++ b/sdcc/src/mc6809/main.c
@@ -0,0 +1,664 @@
+/*-------------------------------------------------------------------------
+  main.c - m6809 specific definitions.
+
+  Michael Hope <michaelh@juju.net.nz> 2001
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   In other words, you are welcome to use, share and improve this program.
+   You are forbidden to forbid anyone else to use, share and improve
+   what you give them.   Help stamp out software-hoarding!
+-------------------------------------------------------------------------*/
+
+#include <sys/stat.h>
+#include "m6809.h"
+#include "SDCCsystem.h"
+#include "SDCCutil.h"
+#include "SDCCargs.h"
+#include "dbuf_string.h"
+
+static char _m6809_defaultRules[] = {
+#include "peeph.rul"
+};
+
+#define OPTION_SMALL_MODEL          "--model-small"
+#define OPTION_LARGE_MODEL          "--model-large"
+
+static OPTION _mc6809_options[] =
+  {
+    {0, OPTION_SMALL_MODEL, NULL, "8-bit address space for data"},
+    {0, OPTION_LARGE_MODEL, NULL, "16-bit address space for data (default)"},
+    {0, "--out-fmt-elf", NULL, "Output executable in ELF format" },
+    {0, NULL }
+  };
+
+MC6809_OPTS mc6809_opts;
+
+typedef enum
+{
+  /* Must be first */
+  ASM_TYPE_ASXXXX,
+  ASM_TYPE_MC6809ASM,
+}
+ASM_TYPE;
+
+static struct
+{
+  ASM_TYPE asmType;
+  /* determine if we can register a parameter */
+  int regParams;
+}
+_G;
+
+static char *_keywords[] = {
+  "sfr",
+  "nonbanked",
+  "banked",
+  "at",
+  "_naked",
+  "critical",
+  "interrupt",
+  "smallc",
+  NULL
+};
+
+extern PORT mc6809_port;
+
+#include "mappings.i"
+
+static void
+_mc6809_init (void)
+{
+  mc6809_opts.sub = SUB_MC6809;
+  switch (_G.asmType)
+    {
+    default:
+      asm_addTree (&_asxxxx_mc6809);
+      break;
+    }
+}
+
+static void
+_reset_regparm (struct sym_link *funcType)
+{
+  _G.regParams = 0;
+}
+
+static int
+_reg_parm (sym_link *l, bool reentrant)
+{
+ return FALSE;
+}
+
+enum
+{
+  P_BANK = 1,
+  P_PORTMODE,
+  P_CODESEG,
+  P_CONSTSEG,
+};
+
+static int
+do_pragma (int id, const char *name, const char *cp)
+{
+  struct pragma_token_s token;
+  int err = 0;
+  int processed = 1;
+
+  init_pragma_token (&token);
+
+  switch (id)
+    {
+    case P_BANK:
+      {
+        struct dbuf_s buffer;
+
+        dbuf_init (&buffer, 128);
+
+        cp = get_pragma_token (cp, &token);
+
+        switch (token.type)
+          {
+          case TOKEN_EOL:
+            err = 1;
+            break;
+
+          case TOKEN_INT:
+            switch (_G.asmType)
+              {
+              case ASM_TYPE_ASXXXX:
+                dbuf_printf (&buffer, "CODE_%d", token.val.int_val);
+                break;
+
+              default:
+                wassert (0);
+              }
+            break;
+
+          default:
+            {
+              const char *str = get_pragma_string (&token);
+
+              dbuf_append_str (&buffer, (0 == strcmp ("BASE", str)) ? "HOME" : str);
+            }
+            break;
+          }
+
+        cp = get_pragma_token (cp, &token);
+        if (TOKEN_EOL != token.type)
+          {
+            err = 1;
+            break;
+          }
+
+        dbuf_c_str (&buffer);
+        options.code_seg = (char *) dbuf_detach (&buffer);
+      }
+      break;
+
+    case P_PORTMODE:
+      {                         
+        const char *str;
+
+        cp = get_pragma_token (cp, &token);
+
+        if (TOKEN_EOL == token.type)
+          {
+            err = 1;
+            break;
+          }
+
+        str = get_pragma_string (&token);
+
+        cp = get_pragma_token (cp, &token);
+        if (TOKEN_EOL != token.type)
+          {
+            err = 1;
+            break;
+          }
+
+        if (!strcmp (str, "mc6809"))
+          {
+            mc6809_opts.port_mode = 6809;
+          }
+        else if (!strcmp (str, "hd6309"))
+          {
+            mc6809_opts.port_mode = 6309;
+          }
+        else if (!strcmp (str, "save"))
+          {
+            mc6809_opts.port_back = mc6809_opts.port_mode;
+          }
+        else if (!strcmp (str, "restore"))
+          {
+            mc6809_opts.port_mode = mc6809_opts.port_back;
+          }
+        else
+          err = 1;
+      }
+      break;
+
+    case P_CODESEG:
+    case P_CONSTSEG:
+      {
+        char *segname;
+
+        cp = get_pragma_token (cp, &token);
+        if (token.type == TOKEN_EOL)
+          {
+            err = 1;
+            break;
+          }
+
+        segname = Safe_strdup (get_pragma_string (&token));
+
+        cp = get_pragma_token (cp, &token);
+        if (token.type != TOKEN_EOL)
+          {
+            Safe_free (segname);
+            err = 1;
+            break;
+          }
+
+        if (id == P_CODESEG)
+          {
+            if (options.code_seg)
+              Safe_free (options.code_seg);
+            options.code_seg = segname;
+          }
+        else
+          {
+            if (options.const_seg)
+              Safe_free (options.const_seg);
+            options.const_seg = segname;
+          }
+      }
+      break;
+
+    default:
+      processed = 0;
+      break;
+    }
+
+  get_pragma_token (cp, &token);
+
+  if (1 == err)
+    werror (W_BAD_PRAGMA_ARGUMENTS, name);
+
+  free_pragma_token (&token);
+  return processed;
+}
+
+static struct pragma_s pragma_tbl[] = {
+  {"bank", P_BANK, 0, do_pragma},
+  {"portmode", P_PORTMODE, 0, do_pragma},
+  {"codeseg", P_CODESEG, 0, do_pragma},
+  {"constseg", P_CONSTSEG, 0, do_pragma},
+  {NULL, 0, 0, NULL},
+};
+
+static int
+_process_pragma (const char *s)
+{
+  return process_pragma_tbl (pragma_tbl, s);
+}
+
+static bool
+_parseOptions (int *pargc, char **argv, int *i)
+{
+  if (argv[*i][0] == '-')
+    {
+    }
+  return FALSE;
+}
+
+static void
+_setValues (void)
+{
+  const char *s;
+  struct dbuf_s dbuf;
+
+  if (options.nostdlib == FALSE)
+    {
+      const char *s;
+      char *path;
+      struct dbuf_s dbuf;
+
+      dbuf_init (&dbuf, PATH_MAX);
+
+      for (s = setFirstItem (libDirsSet); s != NULL; s = setNextItem (libDirsSet))
+        {
+          path = buildCmdLine2 ("-k\"%s" DIR_SEPARATOR_STRING "{port}\" ", s);
+          dbuf_append_str (&dbuf, path);
+          Safe_free (path);
+        }
+      path = buildCmdLine2 ("-l\"{port}.lib\"", s);
+      dbuf_append_str (&dbuf, path);
+      Safe_free (path);
+
+      setMainValue ("mc6809libspec", dbuf_c_str (&dbuf));
+      dbuf_destroy (&dbuf);
+
+      for (s = setFirstItem (libDirsSet); s != NULL; s = setNextItem (libDirsSet))
+        {
+          struct stat stat_buf;
+
+          path = buildCmdLine2 ("%s" DIR_SEPARATOR_STRING "{port}" DIR_SEPARATOR_STRING "crt0{objext}", s);
+          if (stat (path, &stat_buf) == 0)
+            {
+              Safe_free (path);
+              break;
+            }
+          else
+            Safe_free (path);
+        }
+
+      if (s == NULL)
+        setMainValue ("mc6809crt0", "\"crt0{objext}\"");
+      else
+        {
+          struct dbuf_s dbuf;
+
+          dbuf_init (&dbuf, 128);
+          dbuf_printf (&dbuf, "\"%s\"", path);
+          setMainValue ("mc6809crt0", dbuf_c_str (&dbuf));
+          dbuf_destroy (&dbuf);
+        }
+    }
+  else
+    {
+      setMainValue ("mc6809libspec", "");
+      setMainValue ("mc6809crt0", "");
+    }
+
+  setMainValue ("mc6809extralibfiles", (s = joinStrSet (libFilesSet)));
+  Safe_free ((void *) s);
+  setMainValue ("mc6809extralibpaths", (s = joinStrSet (libPathsSet)));
+  Safe_free ((void *) s);
+
+    {
+      setMainValue ("mc6809outputtypeflag", "-i");
+      setMainValue ("mc6809outext", ".ihx");
+    }
+
+  setMainValue ("stdobjdstfilename", "{dstfilename}{objext}");
+  setMainValue ("stdlinkdstfilename", "{dstfilename}{mc6809outext}");
+
+  setMainValue ("mc6809extraobj", (s = joinStrSet (relFilesSet)));
+  Safe_free ((void *) s);
+
+  dbuf_init (&dbuf, 128);
+  dbuf_printf (&dbuf, "-b_CODE=0x%04X -b_DATA=0x%04X", options.code_loc, options.data_loc);
+  setMainValue ("mc6809bases", dbuf_c_str (&dbuf));
+  dbuf_destroy (&dbuf);
+
+  /* For the old register allocator (with the new one we decide to omit the frame pointer for each function individually) */
+  if (options.omitFramePtr)
+    port->stack.call_overhead = 2;
+}
+
+static void
+_finaliseOptions (void)
+{
+  port->mem.default_local_map = data;
+  port->mem.default_globl_map = data;
+
+  if (IY_RESERVED)
+    port->num_regs -= 2;
+
+  _setValues ();
+}
+
+static void
+_setDefaultOptions (void)
+{
+  options.nopeep = 0;
+  options.stackAuto = 1;
+  /* first the options part */
+  options.intlong_rent = 1;
+  options.float_rent = 1;
+  options.noRegParams = 0;
+  /* Default code and data locations. */
+  options.code_loc = 0x200;
+
+  options.data_loc = 0x8000;
+  options.out_fmt = 'i';        /* Default output format is ihx */
+}
+
+#if 0
+/* Mangling format:
+    _fun_policy_params
+    where:
+      policy is the function policy
+      params is the parameter format
+
+   policy format:
+    rsp
+    where:
+      r is 'r' for reentrant, 's' for static functions
+      s is 'c' for callee saves, 'r' for caller saves
+      f is 'f' for profiling on, 'x' for profiling off
+    examples:
+      rr - reentrant, caller saves
+   params format:
+    A combination of register short names and s to signify stack variables.
+    examples:
+      bds - first two args appear in BC and DE, the rest on the stack
+      s - all arguments are on the stack.
+*/
+static const char *
+_mangleSupportFunctionName (const char *original)
+{
+  struct dbuf_s dbuf;
+
+  if (strstr (original, "longlong"))
+    return (original);
+
+  dbuf_init (&dbuf, 128);
+  dbuf_printf (&dbuf, "%s_rr%s_%s", original, options.profile ? "f" : "x", options.noRegParams ? "s" : "bds"    /* MB: but the library only has hds variants ??? */
+    );
+
+  return dbuf_detach_c_str (&dbuf);
+}
+#endif
+
+static const char *
+_getRegName (const struct reg_info *reg)
+{
+  if (reg)
+    {
+      return reg->name;
+    }
+  /*  assert (0); */
+  return "err";
+}
+
+static int
+_getRegByName (const char *name)
+{
+  if (!strcmp (name, "a"))
+    return A_IDX;
+  if (!strcmp (name, "b"))
+    return B_IDX;
+  if (!strcmp (name, "d"))
+    return D_IDX;
+  if (!strcmp (name, "x"))
+    return X_IDX;
+  if (!strcmp (name, "y"))
+    return Y_IDX;
+  if (!strcmp (name, "u"))
+    return U_IDX;
+  return -1;
+}
+
+static bool
+_hasNativeMulFor (iCode *ic, sym_link *left, sym_link *right)
+{
+  sym_link *test = NULL;
+  int result_size = IS_SYMOP (IC_RESULT(ic)) ? getSize (OP_SYM_TYPE (IC_RESULT(ic))) : 4;
+
+  if (ic->op != '*')
+    {
+      return FALSE;
+    }
+
+  if (IS_LITERAL (left))
+    test = left;
+  else if (IS_LITERAL (right))
+    test = right;
+  /* 8x8 unsigned multiplication code is shorter than
+     call overhead for the multiplication routine. */
+  else if (IS_CHAR (right) && IS_UNSIGNED (right) && IS_CHAR (left) && IS_UNSIGNED (left))
+    {
+      return TRUE;
+    }
+  /* Same for any multiplication with 8 bit result. */
+  else if (result_size == 1)
+    {
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
+
+  if (getSize (test) <= 2)
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+/* Indicate which extended bit operations this port supports */
+static bool
+hasExtBitOp (int op, int size)
+{
+  if (op == GETHBIT)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+/* Indicate the expense of an access to an output storage class */
+static int
+oclsExpense (struct memmap *oclass)
+{
+  if (IN_FARSPACE (oclass))
+    return 1;
+
+  return 0;
+}
+
+static const char *_mc6809LinkCmd[] = {
+  "sdld6809", "-nf", "$1", NULL
+};
+
+/* $3 is replaced by assembler.debug_opts resp. port->assembler.plain_opts */
+static const char *_mc6809AsmCmd[] = {
+  "sdas6809", "$l", "$3", "$2", "$1.asm", NULL
+};
+
+static const char *const _crt[] = { "crt0.rel", NULL, };
+static const char *const _libs_mc6809[] = { "mc6809", NULL, };
+
+/* Globals */
+PORT mc6809_port =
+{
+  TARGET_ID_MC6809,
+  "mc6809",
+  "Motorola MC6809",            /* Target name */
+  NULL,                         /* Processor name */
+  {
+    glue,
+    FALSE,
+    NO_MODEL,
+    NO_MODEL,
+    NULL,                       /* model == target */
+  },
+  {                             /* Assembler */
+    _mc6809AsmCmd,
+    NULL,
+    "-plosgffwy",               /* Options with debug */
+    "-plosgffw",                /* Options without debug */
+    0,
+    ".asm"
+  },
+  {                             /* Linker */
+    _mc6809LinkCmd,                //NULL,
+    NULL,                       //LINKCMD,
+    NULL,
+    ".rel",
+    1,                          /* needLinkerScript */
+    _crt,                       /* crt */
+    _libs_mc6809,                  /* libs */
+  },
+  {                             /* Peephole optimizer */
+    _m6809_defaultRules,
+    mc6809instructionSize,
+    NULL,
+    NULL,
+    NULL,
+    mc6809notUsed,
+    mc6809canAssign,
+    mc6809notUsedFrom,
+    NULL,
+    NULL,
+    NULL,
+  },
+  /* Sizes: char, short, int, long, long long, near ptr, far ptr, gptr, func ptr, banked func ptr, bit, float */
+  { 1, 2, 2, 4, 8, 2, 2, 2, 2, 2, 1, 4 },
+  /* tags for generic pointers */
+  { 0x00, 0x40, 0x60, 0x80 },   /* far, near, xstack, code */
+  {
+    "XSEG",
+    "STACK",
+    "CODE",
+    "DATA",
+    NULL,                       /* idata */
+    NULL,                       /* pdata */
+    NULL,                       /* xdata */
+    NULL,                       /* bit */
+    "RSEG (ABS)",
+    "GSINIT",                   /* static initialization */
+    NULL,                       /* overlay */
+    "GSFINAL",
+    "HOME",
+    NULL,                       /* xidata */
+    NULL,                       /* xinit */
+    NULL,                       /* const_name */
+    "CABS (ABS)",               /* cabs_name */
+    "DABS (ABS)",               /* xabs_name */
+    NULL,                       /* iabs_name */
+    "INITIALIZED",              /* name of segment for initialized variables */
+    "INITIALIZER",              /* name of segment for copies of initialized variables in code space */
+    NULL,
+    NULL,
+    1,                          /* CODE  is read-only */
+    1                           /* No fancy alignments supported. */
+  },
+  { NULL, NULL },
+  { -1, 0, 0, 4, 0, 3, 0 },
+  { -1, FALSE },
+  { mc6809_emitDebuggerSymbol },
+  {
+    256,                        /* maxCount */
+    3,                          /* sizeofElement */
+    {6, 7, 8},                  /* sizeofMatchJump[] - Assumes operand allocated to registers */
+    {6, 9, 15},                 /* sizeofRangeCompare[] - Assumes operand allocated to registers*/
+    1,                          /* sizeofSubtract - Assumes use of a single inc or dec */
+    9,                          /* sizeofDispatch - Assumes operand allocated to register e or c*/
+  },
+  "_",
+  _mc6809_init,
+  _parseOptions,
+  _mc6809_options,
+  NULL,
+  _finaliseOptions,
+  _setDefaultOptions,
+  mc6809_assignRegisters,
+  _getRegName,
+  _getRegByName,
+  NULL,
+  _keywords,
+  0,                            /* no assembler preamble */
+  NULL,                         /* no genAssemblerEnd */
+  0,                            /* no local IVT generation code */
+  0,                            /* no genXINIT code */
+  NULL,                         /* genInitStartup */
+  _reset_regparm,
+  _reg_parm,
+  _process_pragma,
+  NULL,
+  _hasNativeMulFor,
+  hasExtBitOp,                  /* hasExtBitOp */
+  oclsExpense,                  /* oclsExpense */
+  TRUE,
+  TRUE,                         /* little endian */
+  0,                            /* leave lt */
+  0,                            /* leave gt */
+  1,                            /* transform <= to ! > */
+  1,                            /* transform >= to ! < */
+  1,                            /* transform != to !(a == b) */
+  0,                            /* leave == */
+  FALSE,                        /* Array initializer support. */
+  0,                            /* no CSE cost estimation yet */
+  NULL,                         /* no builtin functions */
+  GPOINTER,                     /* treat unqualified pointers as "generic" pointers */
+  1,                            /* reset labelKey to 1 */
+  1,                            /* globals & local statics allowed */
+  MAX_ASMOP_IDX + 1,            /* Number of registers handled in the tree-decomposition-based register allocator in SDCCralloc.hpp */
+  PORT_MAGIC
+};
diff --git a/sdcc/src/mc6809/mappings.i b/sdcc/src/mc6809/mappings.i
new file mode 100644
index 000000000..5b30c7e0e
--- /dev/null
+++ b/sdcc/src/mc6809/mappings.i
@@ -0,0 +1,167 @@
+static const ASM_MAPPING _asxxxx_mc6809_mapping[] = {
+    /* We want to prepend the _ */
+    { "area", ".area _%s" },
+    { "areacode", ".area _%s" },
+    { "areadata", ".area _%s" },
+    { "areahome", ".area _%s" },
+    { "*ixx", "%d (ix)" },
+    { "*iyx", "%d (iy)" },
+    { "*hl", "(hl)" },
+    { "jphl", "jp (hl)" },
+    { "di", "di" },
+    { "ei", "ei" },
+    { "ldahli",
+      "ld a, (hl)\n"
+      "inc\thl" },
+    { "ldahlsp",
+      "ld hl, #%d\n"
+      "add\thl, sp" },
+    { "ldaspsp",
+      "ld iy,#%d\n"
+      "add\tiy,sp\n"
+      "ld\tsp,iy" },
+    { "*pair", "(%s)" },
+    { "enter",
+      "push\tix\n"
+      "ld\tix,#0\n"
+      "add\tix,sp" },
+    { "enters",
+      "call\t___sdcc_enter_ix\n" },
+    { "pusha",
+      "push af\n"
+      "push\tbc\n"
+      "push\tde\n"
+      "push\thl\n"
+      "push\tiy"
+    },
+    { "popa",
+      "pop iy\n"
+      "pop\thl\n"
+      "pop\tde\n"
+      "pop\tbc\n"
+      "pop\taf"
+    },
+    { "adjustsp", "lda sp,-%d(sp)" },
+    { "profileenter",
+      "ld a,#3\n"
+      "rst\t0x08"
+    },
+    { "profileexit",
+      "ld a,#4\n"
+      "rst\t0x08"
+    },
+    { NULL, NULL }
+};
+
+static const ASM_MAPPING _mc6809asm_mapping[] = {
+    { "global", "XDEF %s" },
+    { "extern", "XREF %s" },
+    { "slabeldef", "\n.%s" },
+    { "labeldef", "\n.%s" },
+    { "tlabeldef", "\n.l%N%05d" },
+    { "tlabel", "l%N%05d" },
+    { "fileprelude",
+      "; Generated using the z80asm/z88 tokens.\n"
+      "\tXREF __muluchar_rrx_s\n"
+      "\tXREF __mulschar_rrx_s\n"
+      "\tXREF __mulint_rrx_s\n"
+      "\tXREF __mullong_rrx_s\n"
+      "\tXREF __divuchar_rrx_s\n"
+      "\tXREF __divschar_rrx_s\n"
+      "\tXREF __divsint_rrx_s\n"
+      "\tXREF __divuint_rrx_s\n"
+      "\tXREF __divulong_rrx_s\n"
+      "\tXREF __divslong_rrx_s\n"
+      "\tXREF __rrulong_rrx_s\n"
+      "\tXREF __rrslong_rrx_s\n"
+      "\tXREF __rlulong_rrx_s\n"
+      "\tXREF __rlslong_rrx_s\n"
+    },
+    { "functionheader",
+      "; ---------------------------------\n"
+      "; Function %s\n"
+      "; ---------------------------------"
+    },
+    { "functionlabeldef", ".%s" },
+    { "globalfunctionlabeldef", ".%s" },
+    { "zero", "$00" },
+    { "one", "$01" },
+    { "ascii", "DEFM \"%s\"" },
+    { "ds", "DEFS %d" },
+    { "db", "DEFB" },
+    { "dbs", "DEFB %s" },
+    { "dw", "DEFW" },
+    { "dws", "DEFB %s" },
+    { "immed", "" },
+    { "constbyte", "$%02X" },
+    { "constword", "$%04X" },
+    { "immedword", "$%04X" },
+    { "immedbyte", "$%02X" },
+    { "hashedstr", "%s" },
+    { "lsbimmeds", "%s ~ $FF" },
+    { "msbimmeds", "%s / 256" },
+
+    { "bankimmeds", "BANK(%s)" },
+    { "hashedbankimmeds", "BANK(%s)" },
+    { "module", "MODULE %s" },
+    { "area", "; Area  %s" },
+    { "areadata", "; Aread BSS" },
+    { "areacode", "; Area CODE" },
+    { "areahome", "; Area HOME" },
+    { NULL, NULL }
+};
+
+static const ASM_MAPPING _mc6809asm_mc6809_mapping[] = {
+    { "*ixx", "(ix%+d)" },
+    { "*iyx", "(iy%+d)" },
+    { "*hl", "(hl)" },
+    { "jphl", "jp (hl)" },
+    { "di", "di" },
+    { "ei", "ei" },
+    { "ldahli",
+      "ld a, (hl)\n"
+      "inc\thl" },
+    { "ldahlsp",
+      "ld hl, %d\n"
+      "add\thl, sp" },
+    { "ldaspsp",
+      "ld iy, %d\n"
+      "add\tiy, sp\n"
+      "ld\tsp, iy" },
+    { "*pair", "(%s)" },
+    { "enter",
+      "push\tix\n"
+      "ld\tix,0\n"
+      "add\tix,sp" },
+    { "enters",
+      "call\t___sdcc_enter_ix\n" },
+    { "pusha",
+      "push af\n"
+      "push\tbc\n"
+      "push\tde\n"
+      "push\thl\n"
+      "push\tiy"
+    },
+    { "popa",
+      "pop\tiy\n"
+      "pop\thl\n"
+      "pop\tde\n"
+      "pop\tbc\n"
+      "pop\taf"
+    },
+    { "adjustsp", "lda sp, (sp%+d)" },
+    { "profileenter",
+      "ld a,3\n"
+      "rst\t$08"
+    },
+    { "profileexit",
+      "ld a,4\n"
+      "rst\t$08"
+    },
+    { NULL, NULL }
+};
+
+const ASM_MAPPINGS _asxxxx_mc6809 = {
+    &asm_asxxxx_mapping,
+    _asxxxx_mc6809_mapping
+};
diff --git a/sdcc/src/mc6809/peep.c b/sdcc/src/mc6809/peep.c
new file mode 100644
index 000000000..922a58de2
--- /dev/null
+++ b/sdcc/src/mc6809/peep.c
@@ -0,0 +1,1287 @@
+/*-------------------------------------------------------------------------
+  peep.c - source file for peephole optimizer helper functions
+
+  Written By - Philipp Klaus Krause
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the
+  Free Software Foundation; either version 2, or (at your option) any
+  later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+  In other words, you are welcome to use, share and improve this program.
+  You are forbidden to forbid anyone else to use, share and improve
+  what you give them.   Help stamp out software-hoarding!
+-------------------------------------------------------------------------*/
+
+#include "common.h"
+#include "SDCCicode.h"
+#include "m6809.h"
+#include "SDCCglobl.h"
+#include "SDCCpeeph.h"
+#include "gen.h"
+
+#define NOTUSEDERROR() do {werror(E_INTERNAL_ERROR, __FILE__, __LINE__, "error in notUsed()");} while(0)
+
+#if 0
+#define D(_s) { printf _s; fflush(stdout); }
+#else
+#define D(_s)
+#endif
+
+#define ISINST(l, i) (!STRNCASECMP((l), (i), sizeof(i) - 1) && (!(l)[sizeof(i) - 1] || isspace((unsigned char)((l)[sizeof(i) - 1]))))
+
+typedef enum
+{
+  S4O_CONDJMP,
+  S4O_WR_OP,
+  S4O_RD_OP,
+  S4O_TERM,
+  S4O_VISITED,
+  S4O_ABORT,
+  S4O_CONTINUE
+} S4O_RET;
+
+static struct
+{
+  lineNode *head;
+} _G;
+
+extern bool mc6809_regs_used_as_parms_in_calls_from_current_function[MAX_IDX + 1];
+extern bool mc6809_symmParm_in_calls_from_current_function;
+extern bool mc6809_regs_preserved_in_calls_from_current_function[MAX_IDX + 1];
+
+/*-----------------------------------------------------------------*/
+/* univisitLines - clear "visited" flag in all lines               */
+/*-----------------------------------------------------------------*/
+static void
+unvisitLines (lineNode *pl)
+{
+  for (; pl; pl = pl->next)
+    pl->visited = FALSE;
+}
+
+#define AOP(op) op->aop
+#define AOP_SIZE(op) AOP(op)->size
+
+static bool
+isReturned(const char *what)
+{
+  symbol *sym;
+  sym_link *sym_lnk;
+  int size;
+  lineNode *l;
+
+  if(strncmp(what, "iy", 2) == 0)
+    return FALSE;
+  if(strlen(what) != 1)
+    return TRUE;
+
+  l = _G.head;
+  do
+  {
+    l = l->next;
+  } while(l->isComment || l->ic == NULL || l->ic->op != FUNCTION);
+
+  sym = OP_SYMBOL(IC_LEFT(l->ic));
+
+  if(sym && IS_DECL(sym->type))
+    {
+      // Find size of return value.
+      specifier *spec;
+      if(sym->type->select.d.dcl_type != FUNCTION)
+        NOTUSEDERROR();
+      spec = &(sym->etype->select.s);
+      if(spec->noun == V_VOID || spec->noun == V_INT && spec->b_longlong) // long long is not returned via registers
+        size = 0;
+      else if(spec->noun == V_CHAR || spec->noun == V_BOOL)
+        size = 1;
+      else if(spec->noun == V_INT && !(spec->b_long))
+        size = 2;
+      else
+        size = 4;
+
+      // Check for returned pointer.
+      sym_lnk = sym->type;
+      while (sym_lnk && !IS_PTR (sym_lnk))
+        sym_lnk = sym_lnk->next;
+      if(IS_PTR(sym_lnk))
+        size = 2;
+    }
+  else
+    {
+      NOTUSEDERROR();
+      size = 4;
+    }
+
+  {
+    switch(*what)
+      {
+      case 'd':
+        return(size >= 4);
+      case 'e':
+        return(size >= 3);
+      case 'h':
+        return(size >= 2);
+      case 'l':
+        return(size >= 1);
+      default:
+        return FALSE;
+      }
+  }
+}
+
+/*-----------------------------------------------------------------*/
+/* incLabelJmpToCount - increment counter "jmpToCount" in entry    */
+/* of the list labelHash                                           */
+/*-----------------------------------------------------------------*/
+static bool
+incLabelJmpToCount (const char *label)
+{
+  labelHashEntry *entry;
+
+  entry = getLabelRef (label, _G.head);
+  if (!entry)
+    return FALSE;
+  entry->jmpToCount++;
+  return TRUE;
+}
+
+/*-----------------------------------------------------------------*/
+/* findLabel -                                                     */
+/* 1. extracts label in the opcode pl                              */
+/* 2. increment "label jump-to count" in labelHash                 */
+/* 3. search lineNode with label definition and return it          */
+/*-----------------------------------------------------------------*/
+static lineNode *
+findLabel (const lineNode *pl)
+{
+  char *p;
+  lineNode *cpl;
+
+  /* 1. extract label in opcode */
+
+  /* In each z80 jumping opcode the label is at the end of the opcode */
+  p = strlen (pl->line) - 1 + pl->line;
+
+  /* scan backward until ',' or '\t' */
+  for (; p > pl->line; p--)
+    if (*p == ',' || isspace(*p))
+      break;
+
+  /* sanity check */
+  if (p == pl->line)
+    {
+      NOTUSEDERROR();
+      return NULL;
+    }
+
+  /* skip ',' resp. '\t' */
+  ++p;
+
+  /* 2. increment "label jump-to count" */
+  if (!incLabelJmpToCount (p))
+    return NULL;
+
+  /* 3. search lineNode with label definition and return it */
+  for (cpl = _G.head; cpl; cpl = cpl->next)
+    {
+      if (cpl->isLabel
+          && strncmp (p, cpl->line, strlen(p)) == 0)
+        {
+          return cpl;
+        }
+    }
+  return NULL;
+}
+
+/* Check if reading arg implies reading what. */
+static bool argCont(const char *arg, const char *what)
+{
+  wassert (arg);
+
+  while(isspace (*arg) || *arg == ',')
+    arg++;
+
+  if (arg[0] == '#' || arg[0] == '_')
+    return false;
+
+  if(arg[0] == '(' && arg[1] && arg[2] && (arg[2] != ')' && arg[3] != ')'))
+    return false;
+
+  if(*arg == '(')
+    arg++;
+
+  if (arg[0] == '#' || arg[0] == '_')
+    return false;
+    
+  // Get suitable end to avoid reading into further arguments.
+  const char *end = strchr(arg, ',');
+  if (!end)
+    end = arg + strlen(arg);
+
+  const char *found = StrStr(arg, what);
+
+  return(found && found < end);
+}
+
+static bool
+mc6809MightBeParmInCallFromCurrentFunction(const char *what)
+{}
+
+/* Check if the flag implies reading what. */
+static bool
+mc6809MightReadFlagCondition(const char *cond, const char *what)
+{
+  while(isspace (*cond))
+    cond++;
+
+  if(!STRNCASECMP(cond, "po", 2) || !STRNCASECMP(cond, "pe", 2))
+    return !strcmp(what, "pf");
+  if(tolower(cond[0]) == 'm' || tolower(cond[0]) == 'p')
+    return !strcmp(what, "sf");
+
+  // skip inverted conditions
+  if(tolower(cond[0]) == 'n')
+    cond++;
+
+  if(tolower(cond[0]) == 'c')
+    return !strcmp(what, "cf");
+  if(tolower(cond[0]) == 'z')
+    return !strcmp(what, "zf");
+  return true;
+}
+
+static bool
+mc6809MightReadFlag(const lineNode *pl, const char *what)
+{
+  if(ISINST(pl->line, "ld") ||
+     ISINST(pl->line, "or") ||
+     ISINST(pl->line, "cp") ||
+     ISINST(pl->line, "di") ||
+     ISINST(pl->line, "ei") ||
+     ISINST(pl->line, "im") ||
+     ISINST(pl->line, "in"))
+    return false;
+  if(ISINST(pl->line, "nop") ||
+     ISINST(pl->line, "add") ||
+     ISINST(pl->line, "sub") ||
+     ISINST(pl->line, "and") ||
+     ISINST(pl->line, "xor") ||
+     ISINST(pl->line, "dec") ||
+     ISINST(pl->line, "inc") ||
+     ISINST(pl->line, "cpl") ||
+     ISINST(pl->line, "bit") ||
+     ISINST(pl->line, "res") ||
+     ISINST(pl->line, "set") ||
+     ISINST(pl->line, "pop") ||
+     ISINST(pl->line, "rlc") ||
+     ISINST(pl->line, "rrc") ||
+     ISINST(pl->line, "sla") ||
+     ISINST(pl->line, "sra") ||
+     ISINST(pl->line, "srl") ||
+     ISINST(pl->line, "scf") ||
+     ISINST(pl->line, "cpd") ||
+     ISINST(pl->line, "cpi") ||
+     ISINST(pl->line, "ldd") ||
+     ISINST(pl->line, "ldi") ||
+     ISINST(pl->line, "neg") ||
+     ISINST(pl->line, "rld") ||
+     ISINST(pl->line, "rrd"))
+    return false;
+  if(ISINST(pl->line, "halt") ||
+     ISINST(pl->line, "rlca") ||
+     ISINST(pl->line, "rrca") ||
+     ISINST(pl->line, "cpdr") ||
+     ISINST(pl->line, "cpir") ||
+     ISINST(pl->line, "lddr") ||
+     ISINST(pl->line, "ldir") ||
+     ISINST(pl->line, "jdnz"))
+    return false;
+
+  if(ISINST(pl->line, "rl") ||
+     ISINST(pl->line, "rr") ||
+     ISINST(pl->line, "rla") ||
+     ISINST(pl->line, "rra") ||
+     ISINST(pl->line, "sbc") ||
+     ISINST(pl->line, "adc") ||
+     ISINST(pl->line, "ccf"))
+    return (!strcmp(what, "cf"));
+
+  if(ISINST(pl->line, "daa"))
+    return (!strcmp(what, "cf") || !strcmp(what, "nf") ||
+            !strcmp(what, "hf"));
+
+  if(ISINST(pl->line, "push"))
+    return (argCont(pl->line + 4, "af"));
+
+  if(ISINST(pl->line, "ex"))
+    return (argCont(pl->line + 2, "af"));
+
+  // catch c, nc, z, nz, po, pe, p and m
+  if(ISINST(pl->line, "jp") ||
+     ISINST(pl->line, "jr"))
+    return (strchr(pl->line, ',') && mc6809MightReadFlagCondition(pl->line + 2, what));
+
+  // flags don't matter according to calling convention
+  if(ISINST(pl->line, "reti") ||
+     ISINST(pl->line, "retn"))
+    return false;
+
+  if(ISINST(pl->line, "call"))
+    return (strchr(pl->line, ',') && mc6809MightReadFlagCondition(pl->line + 4, what));
+
+  if(ISINST(pl->line, "ret"))
+    return (pl->line[3] == '\t' && mc6809MightReadFlagCondition(pl->line + 3, what));
+
+  // we don't know anything about this
+  if(ISINST(pl->line, "rst"))
+    return true;
+
+  return true;
+}
+
+static bool
+mc6809MightRead(const lineNode *pl, const char *what)
+{
+  if(strcmp(what, "iyl") == 0 || strcmp(what, "iyh") == 0)
+    what = "iy";
+  if(strcmp(what, "ixl") == 0 || strcmp(what, "ixh") == 0)
+    what = "ix";
+
+  if(ISINST(pl->line, "call") && strcmp(what, "sp") == 0)
+    return TRUE;
+
+  if(strcmp(pl->line, "call\t__initrleblock") == 0)
+    return TRUE;
+
+  if(strcmp(pl->line, "call\t___sdcc_call_hl") == 0 && (strchr(what, 'h') != 0 || strchr(what, 'l') != 0))
+    return TRUE;
+
+  if(strcmp(pl->line, "call\t___sdcc_call_iy") == 0 && strstr(what, "iy") != 0)
+    return TRUE;
+
+  if(strncmp(pl->line, "call\t___sdcc_bcall_", 19) == 0)
+    if (strchr (what, pl->line[19]) != 0 || strchr (what, pl->line[20]) != 0 || strchr (what, pl->line[21]) != 0)
+      return TRUE;
+
+  if(ISINST(pl->line, "call") && strchr(pl->line, ',') == 0)
+    {
+      const symbol *f = findSym (SymbolTab, 0, pl->line + 6);
+      if (f)
+      {
+        const value *args = FUNC_ARGS (f->type);
+
+        if (IFFUNC_ISZ88DK_FASTCALL (f->type) && args) // Has one register argument of size up to 32 bit.
+          {
+            const unsigned int size = getSize (args->type);
+            wassert (!args->next); // Only one argment allowed in __z88dk_fastcall functions.
+            if (strchr(what, 'l') && size >= 1)
+              return TRUE;
+            if (strchr(what, 'h') && size >= 2)
+              return TRUE;
+            if (strchr(what, 'e') && size >= 3)
+              return TRUE;
+            if (strchr(what, 'd') && size >= 4)
+              return TRUE;
+          }
+        return FALSE;
+      }
+      else // Fallback needed for calls through function pointers and for calls to literal addresses.
+        return mc6809MightBeParmInCallFromCurrentFunction(what);
+    }
+
+  if(ISINST(pl->line, "reti") || ISINST(pl->line, "retn"))
+    return(strcmp(what, "sp") == 0);
+
+  if(ISINST(pl->line, "ret")) // --reserve-regs-iy uses ret in code gen for calls through function pointers
+    return(IY_RESERVED ? isReturned(what) || mc6809MightBeParmInCallFromCurrentFunction(what) : isReturned(what)) || strcmp(what, "sp") == 0;
+
+  if(!strcmp(pl->line, "ex\t(sp), hl") || !strcmp(pl->line, "ex\t(sp),hl"))
+    return(!strcmp(what, "h") || !strcmp(what, "l") || strcmp(what, "sp") == 0);
+  if(!strcmp(pl->line, "ex\t(sp), ix") || !strcmp(pl->line, "ex\t(sp),ix"))
+    return(!!strstr(what, "ix") || strcmp(what, "sp") == 0);
+  if(!strcmp(pl->line, "ex\t(sp), iy") || !strcmp(pl->line, "ex\t(sp),iy"))
+    return(!!strstr(what, "iy") || strcmp(what, "sp") == 0);
+  if(!strcmp(pl->line, "ex\tde, hl") || !strcmp(pl->line, "ex\tde,hl"))
+    return(!strcmp(what, "h") || !strcmp(what, "l") || !strcmp(what, "d") || !strcmp(what, "e"));
+  if(ISINST(pl->line, "ld"))
+    {
+      if(argCont(strchr(pl->line, ','), what))
+        return(true);
+      if(*(strchr(pl->line, ',') - 1) == ')' && strstr(pl->line + 3, what) && (strchr(pl->line, '#') == 0 || strchr(pl->line, '#') > strchr(pl->line, ',')))
+        return(true);
+      return(false);
+    }
+
+  //ld a, #0x00
+  if((ISINST(pl->line, "xor") || ISINST(pl->line, "sub")) &&
+     (!strcmp(pl->line+4, "a, a") || !strcmp(pl->line+4, "a,a") || (!strchr(pl->line, ',') && !strcmp(pl->line+4, "a"))))
+    return(false);
+
+  //ld a, #0x00
+  if(!strcmp(pl->line, "and\ta, #0x00") || !strcmp(pl->line, "and\ta,#0x00") || !strcmp(pl->line, "and\t#0x00"))
+    return(false);
+
+  //ld a, #0xff
+  if(!strcmp(pl->line, "or\ta, #0xff") || !strcmp(pl->line, "or\ta,#0xff") || !strcmp(pl->line, "or\t#0xff"))
+    return(false);
+
+  if(ISINST(pl->line, "adc") ||
+     ISINST(pl->line, "add") ||
+     ISINST(pl->line, "and") ||
+     ISINST(pl->line, "sbc") ||
+     ISINST(pl->line, "sub") ||
+     ISINST(pl->line, "xor"))
+    {
+      const char *arg = pl->line + 4;
+      while(isspace(*arg))
+        arg++;
+      if(arg[0] == 'a' && arg[1] == ',')
+        {
+          if(!strcmp(what, "a"))
+            return(true);
+          arg += 2;
+        }
+      else if(!strncmp(arg, "hl", 2) && arg[2] == ',') // add hl, rr
+        {
+          if(!strcmp(what, "h") || !strcmp(what, "l"))
+            return(true);
+          arg += 3;
+        }
+      else if(!strncmp(arg, "sp", 2) && arg[2] == ',') // add sp, rr
+        {
+          if(!strcmp(what, "sp"))
+            return(true);
+          arg += 3;
+        }
+      else if(arg[0] == 'i') // add ix/y, rr
+        {
+          if(!strncmp(arg, what, 2))
+            return(true);
+          arg += 3;
+        }
+      return(argCont(arg, what));
+    }
+
+  if(ISINST(pl->line, "or") || ISINST(pl->line, "cp") )
+    {
+      const char *arg = pl->line + 3;
+      while(isspace(*arg))
+        arg++;
+      if(*arg == 'a' && *(arg + 1) == ',')
+        {
+          if(!strcmp(what, "a"))
+            return(true);
+          arg += 2;
+        }
+      else if(!strncmp(arg, "hl", 2) && *(arg + 2) == ',')
+        {
+          if(!strcmp(what, "h") || !strcmp(what, "l"))
+            return(true);
+          arg += 3;
+        }
+      return(argCont(arg, what));
+    }
+
+  if(ISINST(pl->line, "neg"))
+    return(strcmp(what, "a") == 0);
+
+  if(ISINST(pl->line, "pop"))
+    return(strcmp(what, "sp") == 0);
+
+  if(ISINST(pl->line, "push"))
+    return(strstr(pl->line + 5, what) != 0 || strcmp(what, "sp") == 0);
+
+  if(ISINST(pl->line, "dec") ||
+     ISINST(pl->line, "inc"))
+    {
+      return(argCont(pl->line + 4, what));
+    }
+
+  if(ISINST(pl->line, "cpl"))
+    return(!strcmp(what, "a"));
+
+  if(ISINST(pl->line, "di") || ISINST(pl->line, "ei"))
+    return(false);
+
+  // Rotate and shift group
+  if(ISINST(pl->line, "rlca") ||
+     ISINST(pl->line, "rla")  ||
+     ISINST(pl->line, "rrca") ||
+     ISINST(pl->line, "rra")  ||
+     ISINST(pl->line, "daa"))
+    {
+      return(strcmp(what, "a") == 0);
+    }
+  if(ISINST(pl->line, "rl") ||
+     ISINST(pl->line, "rr"))
+    {
+      return(argCont(pl->line + 3, what));
+    }
+  if(ISINST(pl->line, "rlc") ||
+     ISINST(pl->line, "sla") ||
+     ISINST(pl->line, "rrc") ||
+     ISINST(pl->line, "sra") ||
+     ISINST(pl->line, "srl"))
+    {
+      return(argCont(pl->line + 4, what));
+    }
+  if(
+    (ISINST(pl->line, "rld") ||
+     ISINST(pl->line, "rrd")))
+    return(!!strstr("ahl", what));
+
+  // Bit set, reset and test group
+  if(ISINST(pl->line, "bit") ||
+     ISINST(pl->line, "set") ||
+     ISINST(pl->line, "res"))
+    {
+      return(argCont(strchr(pl->line + 4, ','), what));
+    }
+
+  if(ISINST(pl->line, "ccf") ||
+    ISINST(pl->line, "scf")  ||
+    ISINST(pl->line, "nop")  ||
+    ISINST(pl->line, "halt") )
+    return(false);
+
+  if(ISINST(pl->line, "jp") || ISINST(pl->line, "jr"))
+    return(false);
+
+  if(ISINST(pl->line, "djnz"))
+    return(strchr(what, 'b') != 0);
+
+  if((ISINST(pl->line, "ldd") || ISINST(pl->line, "lddr") || ISINST(pl->line, "ldi") || ISINST(pl->line, "ldir")))
+    return(strchr("bcdehl", *what));
+  if(ISINST(pl->line, "ldi"))
+    return(strchr("hl", *what) || strstr(strchr(pl->line + 4, ','), what) != 0);
+
+  if((ISINST(pl->line, "cpd") || ISINST(pl->line, "cpdr") || ISINST(pl->line, "cpi") || ISINST(pl->line, "cpir")))
+    return(strchr("abchl", *what));
+
+  if(ISINST(pl->line, "out"))
+    return(strstr(strchr(pl->line + 4, ','), what) != 0 || strstr(pl->line + 4, "(c)") && (!strcmp(what, "b") || !strcmp(what, "c")));
+  if(ISINST(pl->line, "in"))
+    return(!strstr(strchr(pl->line + 4, ','), "(c)") && !strcmp(what, "a") || strstr(strchr(pl->line + 4, ','), "(c)") && (!strcmp(what, "b") || !strcmp(what, "c")));
+
+  if(ISINST(pl->line, "ldh") || ISINST(pl->line, "in"))
+    return(strstr(strchr(pl->line + 3, ','), what) != 0 || (!strcmp(what, "c") && strstr(pl->line + 3, "(c)")));
+    
+  if(ISINST(pl->line, "lsdr") || ISINST(pl->line, "lidr") || ISINST(pl->line, "lsddr") || ISINST(pl->line, "lsidr"))
+    return(strchr("bcdehl", *what));
+
+  if (ISINST(pl->line, "ldhl"))
+    return(!strcmp(what, "sp"));
+
+  /* TODO: Can we know anything about rst? */
+  if(ISINST(pl->line, "rst"))
+    return(true);
+    
+  return(true);
+}
+
+static bool
+mc6809UncondJump(const lineNode *pl)
+{
+  if((ISINST(pl->line, "jp") || ISINST(pl->line, "jr")) &&
+     strchr(pl->line, ',') == 0)
+    return TRUE;
+  return FALSE;
+}
+
+static bool
+mc6809CondJump(const lineNode *pl)
+{
+  if(((ISINST(pl->line, "jp") || ISINST(pl->line, "jr")) &&
+      strchr(pl->line, ',') != 0) ||
+     ISINST(pl->line, "djnz"))
+    return TRUE;
+  return FALSE;
+}
+
+// TODO: z80 flags only partly implemented
+static bool
+mc6809SurelyWritesFlag(const lineNode *pl, const char *what)
+{
+  /* LD instruction is never change flags except LD A,I and LD A,R.
+    But it is most popular instruction so place it first */
+  if(ISINST(pl->line, "ld"))
+    {
+      if(!!strcmp(what, "pf") ||
+          !argCont(pl->line+3, "a"))
+        return false;
+      const char *p = strchr(pl->line+4, ',');
+      if (p == NULL)
+        return false; /* unknown instruction */
+      ++p;
+      return argCont(p, "i") || argCont(p, "r");
+    }
+
+  if(ISINST(pl->line, "rlca") ||
+     ISINST(pl->line, "rrca") ||
+     ISINST(pl->line, "rra")  ||
+     ISINST(pl->line, "rla"))
+    return (!!strcmp(what, "zf") && !!strcmp(what, "sf") && !!strcmp(what, "pf"));
+
+  if(ISINST(pl->line, "adc") ||
+     ISINST(pl->line, "and") ||
+     ISINST(pl->line, "sbc") ||
+     ISINST(pl->line, "sub") ||
+     ISINST(pl->line, "xor") ||
+     ISINST(pl->line, "and") ||
+     ISINST(pl->line, "rlc") ||
+     ISINST(pl->line, "rrc") ||
+     ISINST(pl->line, "sla") ||
+     ISINST(pl->line, "sra") ||
+     ISINST(pl->line, "srl") ||
+     ISINST(pl->line, "neg"))
+    return true;
+
+  if(ISINST(pl->line, "or") ||
+     ISINST(pl->line, "cp") ||
+     ISINST(pl->line, "rl") ||
+     ISINST(pl->line, "rr"))
+    return true;
+
+  if(ISINST(pl->line, "bit") ||
+     ISINST(pl->line, "cpd") ||
+     ISINST(pl->line, "cpi") ||
+     ISINST(pl->line, "rrd"))
+    return (!!strcmp(what, "cf"));
+
+  if(ISINST(pl->line, "cpdr") ||
+     ISINST(pl->line, "cpir"))
+    return (!!strcmp(what, "cf"));
+
+  if(ISINST(pl->line, "daa"))
+    return (!!strcmp(what, "nf"));
+
+  if(ISINST(pl->line, "scf") ||
+     ISINST(pl->line, "ccf"))
+    return (!!strcmp(what, "zf") && !!strcmp(what, "sf") && !!strcmp(what, "pf"));
+
+  if(ISINST(pl->line, "cpl"))
+    return (!!strcmp(what, "zf") && !!strcmp(what, "cf"));
+
+  // only for simple registers
+  if((ISINST(pl->line, "inc") ||
+      ISINST(pl->line, "dec")) && (strlen(pl->line+4) == 1))
+    return (!!strcmp(what, "cf"));
+
+  if(ISINST(pl->line, "add"))
+    return (argCont(pl->line + 4, "a") ||
+           (!!strcmp(what, "zf") && !!strcmp(what, "sf") && !!strcmp(what, "pf")));
+
+  // pop af writes
+  if(ISINST(pl->line, "pop"))
+    return (argCont(pl->line + 4, "af"));
+
+  // according to calling convention caller has to save flags
+  if(ISINST(pl->line, "ret") ||
+     ISINST(pl->line, "call"))
+    return true;
+
+  /* handle IN0 r,(n) and IN r,(c) instructions */
+  if(ISINST(pl->line, "in0") || (!strncmp(pl->line, "in\t", 3) &&
+     (!strcmp(pl->line+5, "(c)") || !strcmp(pl->line+5, "(bc)"))))
+    return (!!strcmp(what, "cf"));
+
+  return false;
+}
+
+static bool
+mc6809SurelyWrites(const lineNode *pl, const char *what)
+{}
+
+static bool
+mc6809SurelyReturns(const lineNode *pl)
+{
+  if(strcmp(pl->line, "ret") == 0)
+    return TRUE;
+  return FALSE;
+}
+
+/*-----------------------------------------------------------------*/
+/* scan4op - "executes" and examines the assembler opcodes,        */
+/* follows conditional and un-conditional jumps.                   */
+/* Moreover it registers all passed labels.                        */
+/*                                                                 */
+/* Parameter:                                                      */
+/*    lineNode **pl                                                */
+/*       scanning starts from pl;                                  */
+/*       pl also returns the last scanned line                     */
+/*    const char *pReg                                             */
+/*       points to a register (e.g. "ar0"). scan4op() tests for    */
+/*       read or write operations with this register               */
+/*    const char *untilOp                                          */
+/*       points to NULL or a opcode (e.g. "push").                 */
+/*       scan4op() returns if it hits this opcode.                 */
+/*    lineNode **plCond                                            */
+/*       If a conditional branch is met plCond points to the       */
+/*       lineNode of the conditional branch                        */
+/*                                                                 */
+/* Returns:                                                        */
+/*    S4O_ABORT                                                    */
+/*       on error                                                  */
+/*    S4O_VISITED                                                  */
+/*       hit lineNode with "visited" flag set: scan4op() already   */
+/*       scanned this opcode.                                      */
+/*    S4O_FOUNDOPCODE                                              */
+/*       found opcode and operand, to which untilOp and pReg are   */
+/*       pointing to.                                              */
+/*    S4O_RD_OP, S4O_WR_OP                                         */
+/*       hit an opcode reading or writing from pReg                */
+/*    S4O_CONDJMP                                                  */
+/*       hit a conditional jump opcode. pl and plCond return the   */
+/*       two possible branches.                                    */
+/*    S4O_TERM                                                     */
+/*       acall, lcall, ret and reti "terminate" a scan.            */
+/*-----------------------------------------------------------------*/
+static S4O_RET
+scan4op (lineNode **pl, const char *what, const char *untilOp,
+         lineNode **plCond)
+{
+  bool isFlag = (strlen(what) == 2 && what[1] == 'f');
+  for (; *pl; *pl = (*pl)->next)
+    {
+      if (!(*pl)->line || (*pl)->isDebug || (*pl)->isComment || (*pl)->isLabel)
+        continue;
+      D(("Scanning %s for %s\n", (*pl)->line, what));
+      /* don't optimize across inline assembler,
+         e.g. isLabel doesn't work there */
+      if ((*pl)->isInline)
+        {
+          D(("S4O_RD_OP: Inline asm\n"));
+          return S4O_ABORT;
+        }
+
+      if ((*pl)->visited)
+        {
+          D(("S4O_VISITED\n"));
+          return S4O_VISITED;
+        }
+
+      (*pl)->visited = TRUE;
+
+      if(isFlag)
+        {
+        if(mc6809MightReadFlag(*pl, what))
+          {
+            D(("S4O_RD_OP (flag)\n"));
+            return S4O_RD_OP;
+          }
+        }
+      else
+        {
+        if(mc6809MightRead(*pl, what))
+          {
+            D(("S4O_RD_OP\n"));
+            return S4O_RD_OP;
+          }
+        }
+
+      if(mc6809UncondJump(*pl))
+        {
+          *pl = findLabel (*pl);
+            if (!*pl)
+              {
+                D(("S4O_ABORT\n"));
+                return S4O_ABORT;
+              }
+        }
+      if(mc6809CondJump(*pl))
+        {
+          *plCond = findLabel (*pl);
+          if (!*plCond)
+            {
+              D(("S4O_ABORT\n"));
+              return S4O_ABORT;
+            }
+          D(("S4O_CONDJMP\n"));
+          return S4O_CONDJMP;
+        }
+
+      if(isFlag)
+        {
+        if(mc6809SurelyWritesFlag(*pl, what))
+          {
+            D(("S4O_WR_OP (flag)\n"));
+            return S4O_WR_OP;
+          }
+        }
+      else
+        {
+        if(mc6809SurelyWrites(*pl, what))
+          {
+            D(("S4O_WR_OP\n"));
+            return S4O_WR_OP;
+          }
+        }
+
+      /* Don't need to check for de, hl since mc6809MightRead() does that */
+      if(mc6809SurelyReturns(*pl))
+        {
+          D(("S4O_TERM\n"));
+          return S4O_TERM;
+        }
+    }
+  D(("S4O_ABORT\n"));
+  return S4O_ABORT;
+}
+
+/*-----------------------------------------------------------------*/
+/* doTermScan - scan through area 2. This small wrapper handles:   */
+/* - action required on different return values                    */
+/* - recursion in case of conditional branches                     */
+/*-----------------------------------------------------------------*/
+static bool
+doTermScan (lineNode **pl, const char *what)
+{
+  lineNode *plConditional;
+
+  for (;; *pl = (*pl)->next)
+    {
+      switch (scan4op (pl, what, NULL, &plConditional))
+        {
+          case S4O_TERM:
+          case S4O_VISITED:
+          case S4O_WR_OP:
+            /* all these are terminating conditions */
+            return TRUE;
+          case S4O_CONDJMP:
+            /* two possible destinations: recurse */
+              {
+                lineNode *pl2 = plConditional;
+                D(("CONDJMP trying other branch first\n"));
+                if (!doTermScan (&pl2, what))
+                  return FALSE;
+                D(("Other branch OK.\n"));
+              }
+            continue;
+          case S4O_RD_OP:
+          default:
+            /* no go */
+            return FALSE;
+        }
+    }
+}
+
+/* Regular 16 bit reg */
+static bool
+is16BitReg(const char *what)
+{
+  if(strlen(what) != 1)
+    return FALSE;
+  switch(*what)
+    {
+    case 'd':
+      return TRUE;
+    }
+  return FALSE;
+}
+
+/* Regular 8 bit reg */
+static bool
+is8BitReg(const char *what)
+{
+  if(strlen(what) != 1)
+    return FALSE;
+  switch(*what)
+    {
+    case 'a':
+    case 'b':
+      return TRUE;
+    }
+  return FALSE;
+}
+
+/* Regular reg */
+static bool
+isReg(const char *what)
+{
+  return is8BitReg(what) || is16BitReg(what);
+}
+
+/* Check that what is never read after endPl. */
+
+bool
+mc6809notUsed (const char *what, lineNode *endPl, lineNode *head)
+{
+  lineNode *pl;
+  D(("Checking for %s\n", what));
+
+  if(strcmp(what, "af") == 0)
+    {
+      if(!mc6809notUsed("a", endPl, head))
+        return FALSE;
+      what++;
+    }
+
+  if(strcmp(what, "f") == 0)
+    return mc6809notUsed("zf", endPl, head) && mc6809notUsed("cf", endPl, head) &&
+           mc6809notUsed("sf", endPl, head) && mc6809notUsed("pf", endPl, head) &&
+           mc6809notUsed("nf", endPl, head) && mc6809notUsed("hf", endPl, head);
+
+  if(strcmp(what, "iy") == 0)
+    {
+      if(IY_RESERVED)
+        return FALSE;
+      return(mc6809notUsed("iyl", endPl, head) && mc6809notUsed("iyh", endPl, head));
+    }
+
+  if(strcmp(what, "ix") == 0)
+    return(mc6809notUsed("ixl", endPl, head) && mc6809notUsed("ixh", endPl, head));
+
+  // P/V and L/V (rarbbits) are the same flag
+  if(!strcmp(what, "vf") || !strcmp(what, "lf"))
+    what = "pf";
+
+  // enable sp and flags
+  if(!is8BitReg(what) &&
+     strcmp(what, "sp") && strcmp(what+1, "f"))
+    return FALSE;
+
+  _G.head = head;
+
+  unvisitLines (_G.head);
+
+  pl = endPl->next;
+  if (!doTermScan (&pl, what))
+    return FALSE;
+
+  return TRUE;
+}
+
+bool
+mc6809notUsedFrom (const char *what, const char *label, lineNode *head)
+{
+  lineNode *cpl;
+
+  for (cpl = head; cpl; cpl = cpl->next)
+    {
+      if (cpl->isLabel && !strncmp (label, cpl->line, strlen(label)))
+        {
+          return mc6809notUsed (what, cpl, head);
+        }
+    }
+
+  return false;
+}
+
+bool
+mc6809canAssign (const char *op1, const char *op2, const char *exotic)
+{
+  const char *dst, *src;
+
+  // Indexed accesses: One is the indexed one, the other one needs to be a reg or immediate.
+  if(exotic)
+  {
+    if(!strcmp(exotic, "ix") || !strcmp(exotic, "iy"))
+    {
+      if(is8BitReg(op1))
+        return TRUE;
+    }
+    else if(!strcmp(op2, "ix") || !strcmp(op2, "iy"))
+    {
+      if(is8BitReg(exotic) || exotic[0] == '#')
+        return TRUE;
+    }
+
+    return FALSE;
+  }
+
+  // Everything else.
+  dst = op1;
+  src = op2;
+
+  // 8-bit regs can be assigned to each other directly.
+  if(is8BitReg(dst) && is8BitReg(src))
+    return TRUE;
+
+  // Same if at most one of them is (hl).
+  if((is8BitReg(dst)))
+    return TRUE;
+  if(!strcmp(dst, "(hl)") && (is8BitReg(src) ))
+    return TRUE;
+
+  // Can assign between a and (bc), (de), (hl+), (hl-)
+  if(!strcmp(dst, "a") &&
+     (!strcmp(src, "(bc)") || !strcmp(src, "(de)") || !strcmp(src, "(hl+)") || !strcmp(src, "(hl-)")))
+    return TRUE;
+  if((!strcmp(dst, "(bc)") || !strcmp(dst, "(de)") || !strcmp(src, "(hl+)") || !strcmp(src, "(hl-)"))
+     && !strcmp(src, "a"))
+    return TRUE;
+
+  // Can load immediate values directly into registers.
+  if((is8BitReg(dst) || !strcmp(src, "sp")) && src[0] == '#')
+    return TRUE;
+
+  if((!strcmp(dst, "a") || !strcmp(src, "sp")) && !strncmp(src, "(#", 2))
+    return TRUE;
+  if(!strncmp(dst, "(#", 2) && (!strcmp(src, "a") || !strcmp(src, "sp")))
+    return TRUE;
+
+  // Can load immediate values directly into (hl).
+  if(!strcmp(dst, "(hl)") && src[0] == '#')
+    return TRUE;
+
+  // Can load hl into sp
+  if(!strcmp(dst, "sp") && !strcmp(src, "hl"))
+    return TRUE;
+
+  return FALSE;
+}
+
+static const char *
+registerBaseName (const char *op)
+{
+  if (!strcmp (op, "d") || !strcmp (op, "e") || !strcmp (op, "(de)"))
+    return "de";
+  if (!strcmp (op, "b") || !strcmp (op, "c") || !strcmp (op, "(bc)"))
+    return "bc";
+  if (!strcmp (op, "h") || !strcmp (op, "l") || !strcmp (op, "(hl)") || !strcmp (op, "(hl+)")  || !strcmp (op, "(hl-)"))
+    return "hl";
+  if (!strcmp (op, "iyh") || !strcmp (op, "iyl") || strstr (op, "iy"))
+    return "iy";
+  if (!strcmp (op, "ixh") || !strcmp (op, "ixl") || strstr (op, "ix"))
+    return "ix";
+  if (!strcmp (op, "a"))
+    return "af";
+  return op;
+}
+
+int mc6809instructionSize(lineNode *pl)
+{
+  const char *op1start, *op2start;
+
+  /* move to the first operand:
+   * leading spaces are already removed, skip the mnemonic */
+  for (op1start = pl->line; *op1start && !isspace (*op1start); ++op1start);
+
+  /* skip the spaces between mnemonic and the operand */
+  while (isspace (*op1start))
+    ++op1start;
+  if (!(*op1start))
+    op1start = NULL;
+
+  if (op1start)
+    {
+      /* move to the second operand:
+       * find the comma and skip the following spaces */
+      op2start = strchr(op1start, ',');
+      if (op2start)
+        {
+          do
+            ++op2start;
+          while (isspace (*op2start));
+
+          if ('\0' == *op2start)
+            op2start = NULL;
+        }
+    }
+  else
+    op2start = NULL;
+
+  /* All ld instructions */
+  if(ISINST(pl->line, "ld"))
+    {
+      /* These 4 are the only cases of 4 byte long ld instructions. */
+      if(!STRNCASECMP(op1start, "ix", 2) || !STRNCASECMP(op1start, "iy", 2))
+        return(4);
+      if((argCont(op1start, "(ix)") || argCont(op1start, "(iy)")) && op2start[0] == '#')
+        return(4);
+
+      if(op1start[0] == '('               && STRNCASECMP(op1start, "(bc)", 4) &&
+         STRNCASECMP(op1start, "(de)", 4) && STRNCASECMP(op1start, "(hl" , 3) &&
+         STRNCASECMP(op2start, "hl", 2)   && STRNCASECMP(op2start, "a", 1)   &&
+         (STRNCASECMP(op2start, "sp", 2)) ||
+         op2start[0] == '('               && STRNCASECMP(op2start, "(bc)", 4) &&
+         STRNCASECMP(op1start, "(de)", 4) && STRNCASECMP(op2start, "(hl" , 3) &&
+         STRNCASECMP(op1start, "hl", 2)   && STRNCASECMP(op1start, "a", 1))
+        return(4);
+
+      /* These 4 are the only remaining cases of 3 byte long ld instructions. */
+      if(argCont(op2start, "(ix)") || argCont(op2start, "(iy)"))
+        return(3);
+      if(argCont(op1start, "(ix)") || argCont(op1start, "(iy)"))
+        return(3);
+      if((op1start[0] == '(' && STRNCASECMP(op1start, "(bc)", 4) && STRNCASECMP(op1start, "(de)", 4) && STRNCASECMP(op1start, "(hl", 3)) ||
+         (op2start[0] == '(' && STRNCASECMP(op2start, "(bc)", 4) && STRNCASECMP(op2start, "(de)", 4) && STRNCASECMP(op2start, "(hl", 3)))
+        return(3);
+      if(op2start[0] == '#' &&
+         (!STRNCASECMP(op1start, "bc", 2) || !STRNCASECMP(op1start, "de", 2) || !STRNCASECMP(op1start, "hl", 2) || !STRNCASECMP(op1start, "sp", 2)))
+        return(3);
+
+      /* These 3 are the only remaining cases of 2 byte long ld instructions. */
+      if(op2start[0] == '#')
+        return(2);
+      if(!STRNCASECMP(op1start, "i", 1) || !STRNCASECMP(op1start, "r", 1) ||
+         !STRNCASECMP(op2start, "i", 1) || !STRNCASECMP(op2start, "r", 1))
+        return(2);
+      if(!STRNCASECMP(op2start, "ix", 2) || !STRNCASECMP(op2start, "iy", 2))
+        return(2);
+
+      /* All other ld instructions */
+      return(1);
+    }
+
+  // load from sp with offset
+  if((ISINST(pl->line, "lda") || ISINST(pl->line, "ldhl")))
+    {
+      return(2);
+    }
+  // load from/to 0xffXX addresses
+  if((ISINST(pl->line, "ldh")))
+    {
+      if(!STRNCASECMP(pl->line, "(c)", 3))
+        return(1);
+      return(2);
+    }
+
+  /* Exchange */
+  if(ISINST(pl->line, "exx"))
+    return(1);
+  if(ISINST(pl->line, "ex"))
+    {
+      if(!op2start)
+        {
+          werrorfl(pl->ic->filename, pl->ic->lineno, W_UNRECOGNIZED_ASM, __FUNCTION__, 4, pl->line);
+          return(4);
+        }
+      if(argCont(op1start, "(sp)") && (!STRNCASECMP(op2start, "ix", 2) || !STRNCASECMP(op2start, "iy", 2)))
+        return(2);
+      return(1);
+    }
+
+  /* Push / pop */
+  if(ISINST(pl->line, "push") || ISINST(pl->line, "pop"))
+    {
+      if(!STRNCASECMP(op1start, "ix", 2) || !STRNCASECMP(op1start, "iy", 2))
+        return(2);
+      return(1);
+    }
+
+  /* 16 bit add / subtract / and */
+  if(ISINST(pl->line, "add") && (!STRNCASECMP(op1start, "ix", 2) || !STRNCASECMP(op1start, "iy", 2)))
+    return(2);
+
+  /* 8 bit arithmetic, two operands */
+  if(op2start &&  op1start[0] == 'a' &&
+     (ISINST(pl->line, "add") || ISINST(pl->line, "adc") || ISINST(pl->line, "sub") || ISINST(pl->line, "sbc") ||
+      ISINST(pl->line, "cp")  || ISINST(pl->line, "and") || ISINST(pl->line, "or")  || ISINST(pl->line, "xor")))
+    {
+      if(argCont(op2start, "(ix)") || argCont(op2start, "(iy)"))
+        return(3);
+      if(op2start[0] == '#')
+        return(2);
+      return(1);
+    }
+
+  if(ISINST(pl->line, "rlca") || ISINST(pl->line, "rla") || ISINST(pl->line, "rrca") || ISINST(pl->line, "rra"))
+    return(1);
+
+  /* Increment / decrement */
+  if(ISINST(pl->line, "inc") || ISINST(pl->line, "dec"))
+    {
+      if(!STRNCASECMP(op1start, "ix", 2) || !STRNCASECMP(op1start, "iy", 2))
+        return(2);
+      if(argCont(op1start, "(ix)") || argCont(op1start, "(iy)"))
+        return(3);
+      return(1);
+    }
+
+  if(ISINST(pl->line, "rlc") || ISINST(pl->line, "rl")  || ISINST(pl->line, "rrc") || ISINST(pl->line, "rr") ||
+     ISINST(pl->line, "sla") || ISINST(pl->line, "sra") || ISINST(pl->line, "srl"))
+    {
+      if(argCont(op1start, "(ix)") || argCont(op1start, "(iy)"))
+        return(4);
+      return(2);
+    }
+
+  if(ISINST(pl->line, "rld") || ISINST(pl->line, "rrd"))
+    return(2);
+
+  /* Bit */
+  if(ISINST(pl->line, "bit") || ISINST(pl->line, "set") || ISINST(pl->line, "res"))
+    {
+      if(argCont(op2start, "(ix)") || argCont(op2start, "(iy)"))
+        return(4);
+      return(2);
+    }
+
+  if(ISINST(pl->line, "jr") || ISINST(pl->line, "djnz"))
+    return(2);
+
+  if(ISINST(pl->line, "jp"))
+    {
+      if(!STRNCASECMP(op1start, "(hl)", 4))
+        return(1);
+      if(!STRNCASECMP(op1start, "(ix)", 4) || !STRNCASECMP(op1start, "(iy)", 4))
+        return(2);
+      return(3);
+    }
+
+  if((ISINST(pl->line, "reti") || ISINST(pl->line, "retn")))
+    return(2);
+
+  if(ISINST(pl->line, "ret") || ISINST(pl->line, "reti") || ISINST(pl->line, "rst"))
+    return(1);
+
+  if(ISINST(pl->line, "call"))
+    return(3);
+
+  if(ISINST(pl->line, "ldi") || ISINST(pl->line, "ldd") || ISINST(pl->line, "cpi") || ISINST(pl->line, "cpd"))
+    return(2);
+
+  if(ISINST(pl->line, "neg"))
+    return(2);
+
+  if(ISINST(pl->line, "daa") || ISINST(pl->line, "cpl")  || ISINST(pl->line, "ccf") || ISINST(pl->line, "scf") ||
+     ISINST(pl->line, "nop") || ISINST(pl->line, "halt") || ISINST(pl->line,  "ei") || ISINST(pl->line, "di"))
+    return(1);
+
+  if(ISINST(pl->line, "im"))
+    return(2);
+
+  if(ISINST(pl->line, "in") || ISINST(pl->line, "out") || ISINST(pl->line, "ot"))
+    return(2);
+
+  if(ISINST(pl->line, "out0"))
+    return(3);
+
+  if(ISINST(pl->line, "lddr") || ISINST(pl->line, "ldir"))
+    return(2);
+
+  if(ISINST(pl->line, ".db") || ISINST(pl->line, ".byte"))
+    {
+      int i, j;
+      for(i = 1, j = 0; pl->line[j]; i += pl->line[j] == ',', j++);
+      return(i);
+    }
+
+  if(ISINST(pl->line, ".dw") || ISINST(pl->line, ".word"))
+    {
+      int i, j;
+      for(i = 1, j = 0; pl->line[j]; i += pl->line[j] == ',', j++);
+      return(i * 2);
+    }
+
+  /* If the instruction is unrecognized, we shouldn't try to optimize.  */
+  /* For all we know it might be some .ds or similar possibly long line */
+  /* Return a large value to discourage optimization.                   */
+  if (pl->ic)
+    werrorfl(pl->ic->filename, pl->ic->lineno, W_UNRECOGNIZED_ASM, __func__, 999, pl->line);
+  else
+    werrorfl("unknown", 0, W_UNRECOGNIZED_ASM, __func__, 999, pl->line);
+  return(999);
+}
+
diff --git a/sdcc/src/mc6809/peep.h b/sdcc/src/mc6809/peep.h
new file mode 100644
index 000000000..f14769503
--- /dev/null
+++ b/sdcc/src/mc6809/peep.h
@@ -0,0 +1,28 @@
+/*-------------------------------------------------------------------------
+  peep.h - header file for peephole optimizer helper functions
+
+  Written By -  Philipp Klaus Krause
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the
+  Free Software Foundation; either version 2, or (at your option) any
+  later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+  In other words, you are welcome to use, share and improve this program.
+  You are forbidden to forbid anyone else to use, share and improve
+  what you give them.   Help stamp out software-hoarding!
+-------------------------------------------------------------------------*/
+
+bool mc6809notUsed(const char *what, lineNode *endPl, lineNode *head);
+bool mc6809notUsedFrom(const char *what, const char *label, lineNode *head);
+bool mc6809canAssign (const char *dst, const char *src, const char *exotic);
+int mc6809instructionSize(lineNode *node);
diff --git a/sdcc/src/mc6809/peeph.def b/sdcc/src/mc6809/peeph.def
new file mode 100644
index 000000000..d4efbf992
--- /dev/null
+++ b/sdcc/src/mc6809/peeph.def
@@ -0,0 +1,278 @@
+replace {
+	puls a
+	pshs a
+	lda	%1
+} by {
+	; Peephole 1a	- removed redundant puls a/pshs a
+	lda	%1
+}
+
+replace {
+	puls a
+	pshs a
+	lda	%1,s
+} by {
+	; Peephole 1b	- removed redundant puls a/pshs a
+	lda	%1,s
+}
+
+replace {
+	puls a
+	pshs a
+	clra
+} by {
+	; Peephole 1c	- removed redundant puls a/pshs a
+	clra
+}
+
+
+replace {
+	bcs	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2a	- eliminated jmp
+	bcc	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bcc	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2b	- eliminated jmp
+	bcs	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	beq	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2c	- eliminated jmp
+	bne	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bne	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2d	- eliminated jmp
+	beq	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	brclr	%3,%2,%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2e	- eliminated jmp
+	brset	%3,%2,%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	brset	%3,%2,%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2f	- eliminated jmp
+	brclr	%3,%2,%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bls	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2g	- eliminated jmp
+	bhi	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bhi	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2h	- eliminated jmp
+	bls	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	ble	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2i	- eliminated jmp
+	bgt	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bgt	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2j	- eliminated jmp
+	ble	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bge	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2k	- eliminated jmp
+	blt	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	blt	%1
+	jmp	%5
+%1:
+} by {
+	; Peephole 2l	- eliminated jmp
+	bge	%5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bmi     %1
+	jmp     %5
+%1:
+} by {
+	; Peephole 2m   - eliminated jmp
+	bpl     %5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace {
+	bpl     %1
+	jmp     %5
+%1:
+} by {
+	; Peephole 2n   - eliminated jmp
+	bmi     %5
+%1:
+} if labelInRange(%5), labelRefCountChange(%1 -1)
+
+replace restart {
+	jmp	%5
+} by {
+	; Peephole 3	- shortened jmp to bra
+	bra	%5
+} if labelInRange(%5)
+
+replace {
+	lda	%1
+	tsta
+} by {
+	; Peephole 4a	- eliminated redundant tsta
+	lda	%1
+}
+
+replace {
+	ldx	%1
+	tstx
+} by {
+	; Peephole 4b	- eliminated redundant tstx
+	ldx	%1
+}
+
+replace {
+	jmp	%5
+} by {
+	; Peephole 6a  - replaced jmp to rts with rts
+	rts
+} if optimizeReturn(), labelIsReturnOnly(%5), labelRefCountChange(%5 -1)
+
+replace {
+	bra	%5
+} by {
+	; Peephole 6b  - replaced jmp to rts with rts
+	rts
+} if optimizeReturn(), labelIsReturnOnly(%5), labelRefCountChange(%5 -1)
+
+replace {
+        bne     %1
+%1:
+} by {
+        ; Peephole 7a   - eliminated branch
+%1:
+} if labelRefCountChange(%1 -1)
+
+replace {
+        beq     %1
+%1:
+} by {
+        ; Peephole 7b   - eliminated branch
+%1:
+} if labelRefCountChange(%1 -1)
+
+replace restart {
+        bra     %1
+%1:
+} by {
+        ; Peephole 7c   - eliminated branch
+%1:
+} if labelRefCountChange(%1 -1)
+
+replace restart {
+	bra     %1
+%2:
+%1:
+} by {
+	; Peephole 7d   - eliminated branch
+%2:
+%1:
+} if labelRefCountChange(%1 -1)
+
+replace {
+	cmp	#%2
+	beq	%1
+} by {
+	; Peephole 10a   - combined cmp/beq
+	cbeqa	#%2,%1
+}
+
+replace {
+	cmp	*%2
+	beq	%1
+} by {
+	; Peephole 10b   - combined cmp/beq
+	cbeq	*%2,%1
+}
+
+replace {
+        dec     %2,s
+        bne     %1
+} by {
+        ; Peephole 10c   - combined dec/bne
+        dbnz    %2,s,%1
+}
+
+// should be one of the last peepholes
+replace restart {
+%1:
+} by {
+	; Peephole 500    removed redundant label %1
+} if labelRefCount(%1 0)
+
+replace restart {
+	jsr	%1
+	rts
+} by {
+	; Peephole 501 did tail call optimization.
+	jmp	%1
+} if optimizeReturn()
+
diff --git a/sdcc/src/mc6809/ralloc.c b/sdcc/src/mc6809/ralloc.c
new file mode 100644
index 000000000..f8207cdfd
--- /dev/null
+++ b/sdcc/src/mc6809/ralloc.c
@@ -0,0 +1,2059 @@
+/** @name MC6809 Register allocation functions.
+    @author Tim Stahlhut
+
+    Note: much of this is ripped straight from Michael Hope's Z80 code.
+
+    This code maps the virtual symbols and code onto the real
+    hardware.  It allocates based on usage and how long the varible
+    lives into registers or temporary memory on the stack.
+
+?    The stack frame is the common ix-bp style.  Basically:
+
+?    ix+4+n:     param 1
+?    ix+4:       param 0
+?    ix+2:       return address
+?    ix+0:       calling functions ix
+?    ix-n:       local varibles
+    ...
+    sp:         end of local varibles
+
+    There is currently no support for bit spaces or banked functions.
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License as
+    published by the Free Software Foundation; either version 2, or (at
+    your option) any later version.  This program is distributed in the
+    hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+    the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+    PURPOSE.  See the GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+    USA.  In other words, you are welcome to use, share and improve
+    this program.  You are forbidden to forbid anyone else to use,
+    share and improve what you give them.  Help stamp out
+    software-hoarding!
+*/
+
+#include "m6809.h"
+#include "SDCCicode.h"
+#include "dbuf_string.h"
+
+/* Flags to turn off optimisations.
+ */
+enum
+{
+  DISABLE_PACK_ACC = 0,
+  DISABLE_PACK_ASSIGN = 0,
+  DISABLE_PACK_ONE_USE = 0,
+  DISABLE_PACK_HL = 0,
+  DISABLE_PACK_IY = 0
+};
+
+/* Flags to turn on debugging code.
+ */
+enum
+{
+  D_ALLOC = 0,
+  D_ALLOC2 = 0,
+  D_ACCUSE2 = 0,
+  D_ACCUSE2_VERBOSE = 0,
+  D_HLUSE = 0,
+  D_HLUSE2 = 0,
+  D_HLUSE2_VERBOSE = 0,
+  D_FILL_GAPS = 0,
+  D_PACK_IY = 0,
+  D_PACK_HLUSE3 = 0
+};
+
+// #define D_ALLOC 1
+
+#if 1
+#define D(_a, _s)       if (_a)  { printf _s; fflush(stdout); }
+#else
+#define D(_a, _s)
+#endif
+
+#define DISABLE_PACKREGSFORSUPPORT      1
+#define DISABLE_PACKREGSFORACCUSE       1
+
+extern void genMC6809Code (iCode *);
+
+/** Local static variables */
+static struct
+{
+  bitVect *spiltSet;
+  set *stackSpil;
+  bitVect *regAssigned;
+  bitVect *totRegAssigned;      /* final set of LRs that got into registers */
+  short blockSpil;
+  int slocNum;
+  /* registers used in a function */
+  bitVect *funcrUsed;
+  int stackExtend;
+  int dataExtend;
+  int nRegs;
+} _G;
+
+static reg_info _mc6809_regs[] = {
+  {REG_GPR, A_IDX,    "a",  1},
+  {REG_GPR, B_IDX,    "b",  1},
+  {REG_GPR, D_IDX,    "d",  1},
+  {REG_PTR, X_IDX,    "x",  1},
+  {REG_PTR, Y_IDX,    "y",  1},
+  {REG_PTR, U_IDX,    "u",  1},
+  {REG_CND, CND_IDX,  "cc", 1},
+  {0,       DP_IDX,   "dp", 0},
+  {0,       S_IDX,    "s",  0},
+  {0,       PC_IDX,   "pc", 0}
+};
+
+reg_info *regsMC6809;
+
+/** Number of usable registers (all but cc ) */
+#define MC6809_MAX_REGS ((sizeof(_mc6809_regs)/sizeof(_mc6809_regs[0]))-1)
+
+void mc6809SpillThis (symbol *);
+static void freeAllRegs ();
+
+/** Returns pointer to register with index number
+ */
+reg_info *
+mc6809_regWithIdx (int idx)
+{
+  int i;
+
+  for (i = MIN_IDX; i < _G.nRegs; i++)
+    {
+      if (regsMC6809[i].rIdx == idx)
+        {
+          return &regsMC6809[i];
+        }
+    }
+
+  wassertl (0, "mc6809_regWithIdx not found");
+  exit (1);
+}
+
+/** Frees a register.
+ */
+static void
+freeReg (reg_info *reg)
+{
+  wassert (!reg->isFree);
+  reg->isFree = 1;
+  D (D_ALLOC, ("freeReg: freed %p\n", reg));
+}
+
+/** noOverLap - will iterate through the list looking for over lap
+ */
+static int
+noOverLap (set *itmpStack, symbol *fsym)
+{
+  symbol *sym;
+
+  for (sym = setFirstItem (itmpStack); sym; sym = setNextItem (itmpStack))
+    {
+      if (bitVectBitValue (sym->clashes, fsym->key))
+        return 0;
+    }
+  return 1;
+}
+
+/*-----------------------------------------------------------------*/
+/* isFree - will return 1 if the a free spil location is found     */
+/*-----------------------------------------------------------------*/
+DEFSETFUNC (mc6809_isFree)
+{
+  symbol *sym = item;
+  V_ARG (symbol **, sloc);
+  V_ARG (symbol *, fsym);
+
+  /* if already found */
+  if (*sloc)
+    return 0;
+
+  /* if it is free && and the itmp assigned to
+     this does not have any overlapping live ranges
+     with the one currently being assigned and
+     the size can be accomodated  */
+  if (sym->isFree && noOverLap (sym->usl.itmpStack, fsym) && getSize (sym->type) >= getSize (fsym->type))
+    {
+      *sloc = sym;
+      return 1;
+    }
+
+  return 0;
+}
+
+/*-----------------------------------------------------------------*/
+/* createStackSpil - create a location on the stack to spil        */
+/*-----------------------------------------------------------------*/
+static symbol *
+createStackSpil (symbol *sym)
+{
+  symbol *sloc = NULL;
+  struct dbuf_s dbuf;
+
+  D (D_ALLOC, ("createStackSpil: for sym %p (%s)\n", sym, sym->name));
+
+  /* could not then have to create one , this is the hard part
+     we need to allocate this on the stack : this is really a
+     hack!! but cannot think of anything better at this time */
+
+  dbuf_init (&dbuf, 128);
+  dbuf_printf (&dbuf, "sloc%d", _G.slocNum++);
+  sloc = newiTemp (dbuf_c_str (&dbuf));
+  dbuf_destroy (&dbuf);
+
+  /* set the type to the spilling symbol */
+  sloc->type = copyLinkChain (sym->type);
+  sloc->etype = getSpec (sloc->type);
+  SPEC_SCLS (sloc->etype) = S_AUTO;
+  SPEC_EXTR (sloc->etype) = 0;
+  SPEC_STAT (sloc->etype) = 0;
+  SPEC_VOLATILE (sloc->etype) = 0;
+
+  allocLocal (sloc);
+
+  sloc->isref = 1;              /* to prevent compiler warning */
+
+  wassertl (currFunc, "Local variable used outside of function.");
+
+  /* if it is on the stack then update the stack */
+  if (IN_STACK (sloc->etype))
+    {
+      if (currFunc)
+        currFunc->stack += getSize (sloc->type);
+      _G.stackExtend += getSize (sloc->type);
+    }
+  else
+    {
+      _G.dataExtend += getSize (sloc->type);
+    }
+
+  /* add it to the stackSpil set */
+  addSetHead (&_G.stackSpil, sloc);
+  sym->usl.spillLoc = sloc;
+  sym->stackSpil = 1;
+
+  /* add it to the set of itempStack set
+     of the spill location */
+  addSetHead (&sloc->usl.itmpStack, sym);
+
+  D (D_ALLOC, ("createStackSpil: created new %s for %s\n", sloc->name, sym->name));
+  return sym;
+}
+
+/*-----------------------------------------------------------------*/
+/* spillThis - spils a specific operand                            */
+/*-----------------------------------------------------------------*/
+void
+mc6809SpillThis (symbol * sym)
+{
+  int i;
+
+  D (D_ALLOC, ("mc6809SpillThis: spilling %p (%s)\n", sym, sym->name));
+
+  /* if this is rematerializable or has a spillLocation
+     we are okay, else we need to create a spillLocation
+     for it */
+  if (!(sym->remat || sym->usl.spillLoc) || (sym->usl.spillLoc && !sym->usl.spillLoc->onStack))
+    createStackSpil (sym);
+  else
+    D (D_ALLOC, ("Already has spilllocation %p, %s\n", sym->usl.spillLoc, sym->usl.spillLoc->name));
+
+  /* mark it as spilt & put it in the spilt set */
+  sym->isspilt = sym->spillA = 1;
+  _G.spiltSet = bitVectSetBit (_G.spiltSet, sym->key);
+
+  bitVectUnSetBit (_G.regAssigned, sym->key);
+  bitVectUnSetBit (_G.totRegAssigned, sym->key);
+
+  for (i = 0; i < sym->nRegs; i++)
+    {
+      if (sym->regs[i])
+        {
+          freeReg (sym->regs[i]);
+          sym->regs[i] = NULL;
+        }
+    }
+
+  if (sym->usl.spillLoc && !sym->remat)
+    {
+      sym->usl.spillLoc->allocreq++;
+    }
+  return;
+}
+
+/** Symbol has a given register.
+ */
+static bool
+symHasReg (symbol *sym, const reg_info *reg)
+{
+  int i;
+
+  for (i = 0; i < sym->nRegs; i++)
+    if (sym->regs[i] == reg)
+      return TRUE;
+
+  return FALSE;
+}
+
+/** Check the live to and if they have registers & are not spilt then
+    free up the registers
+*/
+static void
+deassignLRs (iCode *ic, eBBlock *ebp)
+{
+  symbol *sym;
+  int k;
+
+  for (sym = hTabFirstItem (liveRanges, &k); sym; sym = hTabNextItem (liveRanges, &k))
+    {
+
+      symbol *psym = NULL;
+      /* if it does not end here */
+      if (sym->liveTo > ic->seq)
+        continue;
+
+      /* if it was spilt on stack then we can
+         mark the stack spil location as free */
+      if (sym->isspilt)
+        {
+          if (sym->stackSpil)
+            {
+              sym->usl.spillLoc->isFree = 1;
+              sym->stackSpil = 0;
+            }
+          continue;
+        }
+
+      if (!bitVectBitValue (_G.regAssigned, sym->key))
+        continue;
+
+      /* special case check if this is an IFX &
+         the privious one was a pop and the
+         previous one was not spilt then keep track
+         of the symbol */
+      if (ic->op == IFX && ic->prev && ic->prev->op == IPOP && !ic->prev->parmPush && !OP_SYMBOL (IC_LEFT (ic->prev))->isspilt)
+        psym = OP_SYMBOL (IC_LEFT (ic->prev));
+
+      D (D_ALLOC, ("deassignLRs: in loop on sym %p nregs %u\n", sym, sym->nRegs));
+
+      if (sym->nRegs)
+        {
+          int i = 0;
+
+          bitVectUnSetBit (_G.regAssigned, sym->key);
+
+          /* free the remaining */
+          for (; i < sym->nRegs; i++)
+            {
+              if (psym)
+                {
+                  if (!symHasReg (psym, sym->regs[i]))
+                    freeReg (sym->regs[i]);
+                }
+              else
+                freeReg (sym->regs[i]);
+            }
+        }
+    }
+}
+
+/** Reassign this to registers.
+ */
+static void
+reassignLR (operand *op)
+{
+  symbol *sym = OP_SYMBOL (op);
+  int i;
+
+  D (D_ALLOC, ("reassingLR: on sym %p\n", sym));
+
+  /* not spilt any more */
+  sym->isspilt = sym->spillA = sym->blockSpil = sym->remainSpil = 0;
+  bitVectUnSetBit (_G.spiltSet, sym->key);
+
+  _G.regAssigned = bitVectSetBit (_G.regAssigned, sym->key);
+  _G.totRegAssigned = bitVectSetBit (_G.totRegAssigned, sym->key);
+
+  _G.blockSpil--;
+
+  for (i = 0; i < sym->nRegs; i++)
+    sym->regs[i]->isFree = 0;
+}
+
+/*------------------------------------------------------------------*/
+/* verifyRegsAssigned - make sure an iTemp is properly initialized; */
+/* it should either have registers or have beed spilled. Otherwise, */
+/* there was an uninitialized variable, so just spill this to get   */
+/* the operand in a valid state.                                    */
+/*------------------------------------------------------------------*/
+static void
+verifyRegsAssigned (operand *op, iCode *ic)
+{
+  symbol *sym;
+
+  if (!op)
+    return;
+  if (!IS_ITEMP (op))
+    return;
+
+  sym = OP_SYMBOL (op);
+  if (sym->isspilt)
+    return;
+  if (!sym->nRegs)
+    return;
+  if (sym->regs[0])
+    return;
+
+  mc6809SpillThis (sym);
+}
+
+/*-----------------------------------------------------------------*/
+/* rUmaskForOp :- returns register mask for an operand             */
+/*-----------------------------------------------------------------*/
+static bitVect *
+rUmaskForOp (const operand * op)
+{
+  bitVect *rumask;
+  symbol *sym;
+  int j;
+
+  /* only temporaries are assigned registers */
+  if (!IS_ITEMP (op))
+    return NULL;
+
+  sym = OP_SYMBOL_CONST (op);
+
+  /* if spilt or no registers assigned to it
+     then nothing */
+  if (sym->isspilt || !sym->nRegs)
+    return NULL;
+
+  rumask = newBitVect (_G.nRegs);
+
+  for (j = 0; j < sym->nRegs; j++)
+    {
+      if (!(sym->regs[j]) || sym->regs[j]->rIdx < 0 || sym->regs[j]->rIdx > CND_IDX)
+        {
+          werror (E_INTERNAL_ERROR, __FILE__, __LINE__, "rUmaskForOp: Register not found");
+          exit (0);
+        }
+      rumask = bitVectSetBit (rumask, sym->regs[j]->rIdx);
+    }
+
+  return rumask;
+}
+
+bitVect *
+mc6809_rUmaskForOp (const operand * op)
+{
+  return rUmaskForOp (op);
+}
+
+/** Returns bit vector of registers used in iCode.
+ */
+bitVect *
+mc6809_regsUsedIniCode (iCode * ic)
+{
+  bitVect *rmask = newBitVect (_G.nRegs);
+
+  /* do the special cases first */
+  if (ic->op == IFX)
+    {
+      rmask = bitVectUnion (rmask, rUmaskForOp (IC_COND (ic)));
+      goto ret;
+    }
+
+  /* for the jumptable */
+  if (ic->op == JUMPTABLE)
+    {
+      rmask = bitVectUnion (rmask, rUmaskForOp (IC_JTCOND (ic)));
+
+      goto ret;
+    }
+
+  /* of all other cases */
+  if (IC_LEFT (ic))
+    rmask = bitVectUnion (rmask, rUmaskForOp (IC_LEFT (ic)));
+
+  if (IC_RIGHT (ic))
+    rmask = bitVectUnion (rmask, rUmaskForOp (IC_RIGHT (ic)));
+
+  if (IC_RESULT (ic))
+    rmask = bitVectUnion (rmask, rUmaskForOp (IC_RESULT (ic)));
+
+ret:
+  return rmask;
+}
+
+/** For each instruction will determine the regsUsed.
+ */
+static void
+createRegMask (eBBlock ** ebbs, int count)
+{
+  int i;
+
+  /* for all blocks */
+  for (i = 0; i < count; i++)
+    {
+      iCode *ic;
+
+      if (ebbs[i]->noPath && (ebbs[i]->entryLabel != entryLabel && ebbs[i]->entryLabel != returnLabel))
+        continue;
+
+      /* for all instructions */
+      for (ic = ebbs[i]->sch; ic; ic = ic->next)
+        {
+
+          int j;
+
+          if (SKIP_IC2 (ic) || !ic->rlive)
+            continue;
+
+          /* first mark the registers used in this
+             instruction */
+
+          ic->rSurv = newBitVect(port->num_regs);
+          ic->rUsed = mc6809_regsUsedIniCode (ic);
+          _G.funcrUsed = bitVectUnion (_G.funcrUsed, ic->rUsed);
+
+          /* now create the register mask for those
+             registers that are in use : this is a
+             super set of ic->rUsed */
+          ic->rMask = newBitVect (_G.nRegs + 1);
+
+          /* for all live Ranges alive at this point */
+          for (j = 1; j < ic->rlive->size; j++)
+            {
+              symbol *sym;
+              int k;
+
+              /* if not alive then continue */
+              if (!bitVectBitValue (ic->rlive, j))
+                continue;
+
+              /* find the live range we are interested in */
+              if (!(sym = hTabItemWithKey (liveRanges, j)))
+                {
+                  werror (E_INTERNAL_ERROR, __FILE__, __LINE__, "createRegMask cannot find live range");
+                  exit (0);
+                }
+
+              /* if no register assigned to it */
+              if (!sym->nRegs || sym->isspilt)
+                continue;
+
+              /* for all the registers allocated to it */
+              for (k = 0; k < sym->nRegs; k++)
+                {
+                  if (!sym->regs[k])
+                    continue;
+                  ic->rMask = bitVectSetBit (ic->rMask, sym->regs[k]->rIdx);
+                  if (sym->liveTo != ic->key)
+                    ic->rSurv = bitVectSetBit (ic->rSurv, sym->regs[k]->rIdx);
+                }
+            }
+        }
+    }
+}
+
+/*-----------------------------------------------------------------*/
+/* regTypeNum - computes the type & number of registers required   */
+/*-----------------------------------------------------------------*/
+static void
+regTypeNum (void)
+{
+  symbol *sym;
+  int k;
+
+  /* for each live range do */
+  for (sym = hTabFirstItem (liveRanges, &k); sym; sym = hTabNextItem (liveRanges, &k))
+    {
+      /* if used zero times then no registers needed */
+      if ((sym->liveTo - sym->liveFrom) == 0 && getSize (sym->type) <= 4)
+        continue;
+      else if ((sym->liveTo - sym->liveFrom) == 0 && bitVectnBitsOn (sym->defs) <= 1)
+        {
+          iCode *dic = hTabItemWithKey (iCodehTab, bitVectFirstBit (sym->defs));
+          if (!dic || dic->op != CALL && dic->op != PCALL)
+            continue;
+        }
+
+      D (D_ALLOC, ("regTypeNum: loop on sym %p\n", sym));
+
+      /* if the live range is a temporary */
+      if (sym->isitmp)
+        {
+          /* if the type is marked as a conditional */
+          if (sym->regType == REG_CND)
+            continue;
+
+          /* if used in return only then we don't
+             need registers */
+          if (sym->ruonly || sym->accuse)
+            {
+              if (IS_AGGREGATE (sym->type) || sym->isptr)
+                sym->type = aggrToPtr (sym->type, FALSE);
+              continue;
+            }
+
+          /* if not then we require registers */
+          D (D_ALLOC,
+             ("regTypeNum: isagg %u nRegs %u type %p\n", IS_AGGREGATE (sym->type) || sym->isptr, sym->nRegs, sym->type));
+          sym->nRegs =
+            ((IS_AGGREGATE (sym->type)
+              || sym->isptr) ? getSize (sym->type = aggrToPtr (sym->type, FALSE)) : getSize (sym->type));
+          D (D_ALLOC, ("regTypeNum: setting nRegs of %s (%p) to %u\n", sym->name, sym, sym->nRegs));
+
+          D (D_ALLOC, ("regTypeNum: setup to assign regs sym %p\n", sym));
+
+          if (sym->nRegs > 8)
+            {
+              fprintf (stderr, "allocated more than 8 registers for type ");
+              printTypeChain (sym->type, stderr);
+              fprintf (stderr, "\n");
+            }
+
+          /* determine the type of register required */
+          /* Always general purpose */
+          sym->regType = REG_GPR;
+        }
+      else
+        {
+          /* for the first run we don't provide */
+          /* registers for true symbols we will */
+          /* see how things go                  */
+          D (D_ALLOC, ("regTypeNum: #2 setting num of %p to 0\n", sym));
+          sym->nRegs = 0;
+        }
+    }
+}
+
+/** Mark all registers as free.
+ */
+static void
+freeAllRegs ()
+{
+  int i;
+
+  D (D_ALLOC, ("freeAllRegs: running.\n"));
+
+  for (i = MIN_IDX; i < _G.nRegs; i++)
+    regsMC6809[i].isFree = 1;
+}
+
+/*-----------------------------------------------------------------*/
+/* deallocStackSpil - this will set the stack pointer back         */
+/*-----------------------------------------------------------------*/
+static
+DEFSETFUNC (deallocStackSpil)
+{
+  symbol *sym = item;
+
+  deallocLocal (sym);
+  return 0;
+}
+
+/** Register reduction for assignment.
+ */
+static int
+packRegsForAssign (iCode * ic, eBBlock * ebp)
+{
+  iCode *dic, *sic;
+
+  D (D_ALLOC, ("packRegsForAssign: running on ic %p\n", ic));
+
+  if (!IS_ITEMP (IC_RIGHT (ic)) || OP_SYMBOL (IC_RIGHT (ic))->isind || OP_LIVETO (IC_RIGHT (ic)) > ic->seq)
+    return 0;
+  
+  /* Avoid having multiple named address spaces in one iCode. */
+  if (IS_SYMOP (IC_RESULT (ic)) && SPEC_ADDRSPACE (OP_SYMBOL (IC_RESULT (ic))->etype))
+    return 0;
+
+  /* find the definition of iTempNN scanning backwards if we find a
+     a use of the true symbol in before we find the definition then
+     we cannot */
+  for (dic = ic->prev; dic; dic = dic->prev)
+    {
+      /* PENDING: Don't pack across function calls. */
+      if (dic->op == CALL || dic->op == PCALL || dic->op == INLINEASM || dic->op == CRITICAL || dic->op == ENDCRITICAL)
+        {
+          dic = NULL;
+          break;
+        }
+
+      if (SKIP_IC2 (dic))
+        continue;
+
+      if (dic->op == IFX)
+        {
+          if (IS_SYMOP (IC_COND (dic)) &&
+              (IC_COND (dic)->key == IC_RESULT (ic)->key || IC_COND (dic)->key == IC_RIGHT (ic)->key))
+            {
+              dic = NULL;
+              break;
+            }
+        }
+      else
+        {
+          if (IS_TRUE_SYMOP (IC_RESULT (dic)) && IS_OP_VOLATILE (IC_RESULT (dic)))
+            {
+              dic = NULL;
+              break;
+            }
+
+          if (IS_SYMOP (IC_RESULT (dic)) && IC_RESULT (dic)->key == IC_RIGHT (ic)->key)
+            {
+              if (POINTER_SET (dic))
+                dic = NULL;
+
+              break;
+            }
+
+          if (IS_SYMOP (IC_RIGHT (dic)) &&
+              (IC_RIGHT (dic)->key == IC_RESULT (ic)->key || IC_RIGHT (dic)->key == IC_RIGHT (ic)->key))
+            {
+              dic = NULL;
+              break;
+            }
+
+          if (IS_SYMOP (IC_LEFT (dic)) &&
+              (IC_LEFT (dic)->key == IC_RESULT (ic)->key || IC_LEFT (dic)->key == IC_RIGHT (ic)->key))
+            {
+              dic = NULL;
+              break;
+            }
+
+          if (IS_SYMOP (IC_RESULT (dic)) && IC_RESULT (dic)->key == IC_RESULT (ic)->key)
+            {
+              dic = NULL;
+              break;
+            }
+        }
+    }
+
+  if (!dic)
+    return 0;                   /* did not find */
+
+  /* if assignment then check that right is not a bit */
+  if (ASSIGNMENT (ic) && !POINTER_SET (ic))
+    {
+      sym_link *etype = operandType (IC_RESULT (dic));
+      if (IS_BITFIELD (etype))
+        {
+          /* if result is a bit too then it's ok */
+          etype = operandType (IC_RESULT (ic));
+          if (!IS_BITFIELD (etype))
+            {
+              return 0;
+            }
+        }
+    }
+
+  /* if the result is on stack or iaccess then it must be
+     the same atleast one of the operands */
+  if (OP_SYMBOL (IC_RESULT (ic))->onStack || OP_SYMBOL (IC_RESULT (ic))->iaccess)
+    {
+      /* the operation has only one symbol
+         operator then we can pack */
+      if ((IC_LEFT (dic) && !IS_SYMOP (IC_LEFT (dic))) || (IC_RIGHT (dic) && !IS_SYMOP (IC_RIGHT (dic))))
+        goto pack;
+
+      if (!((IC_LEFT (dic) &&
+             IC_RESULT (ic)->key == IC_LEFT (dic)->key) || (IC_RIGHT (dic) && IC_RESULT (ic)->key == IC_RIGHT (dic)->key)))
+        return 0;
+    }
+
+pack:
+  /* Keep assignment if it is an sfr write  - not all of code generation can deal with result in sfr */
+  if (IC_RESULT (ic) && IS_TRUE_SYMOP (IC_RESULT (ic)) && SPEC_OCLS (OP_SYMBOL (IC_RESULT (ic))->etype) && IN_REGSP (SPEC_OCLS (OP_SYMBOL (IC_RESULT (ic))->etype)) &&
+    (dic->op == LEFT_OP || dic->op == RIGHT_OP))
+    return 0;
+
+  /* found the definition */
+
+  /* delete from liverange table also
+     delete from all the points inbetween and the new
+     one */
+  for (sic = dic; sic != ic; sic = sic->next)
+    {
+      bitVectUnSetBit (sic->rlive, IC_RESULT (ic)->key);
+      if (IS_ITEMP (IC_RESULT (dic)))
+        bitVectSetBit (sic->rlive, IC_RESULT (dic)->key);
+    }
+
+  /* replace the result with the result of */
+  /* this assignment and remove this assignment */
+  bitVectUnSetBit (OP_SYMBOL (IC_RESULT (dic))->defs, dic->key);
+  IC_RESULT (dic) = IC_RESULT (ic);
+
+  if (IS_ITEMP (IC_RESULT (dic)) && OP_SYMBOL (IC_RESULT (dic))->liveFrom > dic->seq)
+    {
+      OP_SYMBOL (IC_RESULT (dic))->liveFrom = dic->seq;
+    }
+
+  remiCodeFromeBBlock (ebp, ic);
+  // PENDING: Check vs mcs51
+  bitVectUnSetBit (OP_SYMBOL (IC_RESULT (ic))->defs, ic->key);
+  hTabDeleteItem (&iCodehTab, ic->key, ic, DELETE_ITEM, NULL);
+  OP_DEFS (IC_RESULT (dic)) = bitVectSetBit (OP_DEFS (IC_RESULT (dic)), dic->key);
+  return 1;
+}
+
+/** Scanning backwards looks for first assig found.
+ */
+iCode *
+mc6809_findAssignToSym (operand * op, iCode * ic)
+{
+  iCode *dic;
+
+  for (dic = ic->prev; dic; dic = dic->prev)
+    {
+
+      /* if definition by assignment */
+      if (dic->op == '=' && !POINTER_SET (dic) && IC_RESULT (dic)->key == op->key)
+        /*      &&  IS_TRUE_SYMOP(IC_RIGHT(dic)) */
+        {
+
+          /* we are interested only if defined in far space */
+          /* or in stack space in case of + & - */
+
+          /* if assigned to a non-symbol then return
+             true */
+          if (!IS_SYMOP (IC_RIGHT (dic)))
+            break;
+
+          /* if the symbol is in far space then
+             we should not */
+          if (isOperandInFarSpace (IC_RIGHT (dic)))
+            return NULL;
+
+          /* for + & - operations make sure that
+             if it is on the stack it is the same
+             as one of the three operands */
+          if ((ic->op == '+' || ic->op == '-') && OP_SYMBOL (IC_RIGHT (dic))->onStack)
+            {
+
+              if (IC_RESULT (ic)->key != IC_RIGHT (dic)->key &&
+                  IC_LEFT (ic)->key != IC_RIGHT (dic)->key && IC_RIGHT (ic)->key != IC_RIGHT (dic)->key)
+                return NULL;
+            }
+
+          break;
+
+        }
+
+      /* if we find an usage then we cannot delete it */
+      if (IC_LEFT (dic) && IC_LEFT (dic)->key == op->key)
+        return NULL;
+
+      if (IC_RIGHT (dic) && IC_RIGHT (dic)->key == op->key)
+        return NULL;
+
+      if (POINTER_SET (dic) && IC_RESULT (dic)->key == op->key)
+        return NULL;
+    }
+
+  /* now make sure that the right side of dic
+     is not defined between ic & dic */
+  if (dic)
+    {
+      iCode *sic = dic->next;
+
+      for (; sic != ic; sic = sic->next)
+        if (IC_RESULT (sic) && IC_RESULT (sic)->key == IC_RIGHT (dic)->key)
+          return NULL;
+    }
+
+  return dic;
+
+
+}
+
+#if !DISABLE_PACKREGSFORSUPPORT
+// PENDING
+
+/*-----------------------------------------------------------------*/
+/* packRegsForSupport :- reduce some registers for support calls   */
+/*-----------------------------------------------------------------*/
+static int
+packRegsForSupport (iCode * ic, eBBlock * ebp)
+{
+  int change = 0;
+  /* for the left & right operand :- look to see if the
+     left was assigned a true symbol in far space in that
+     case replace them */
+  D (D_ALLOC, ("packRegsForSupport: running on ic %p\n", ic));
+
+  if (IS_ITEMP (IC_LEFT (ic)) && OP_SYMBOL (IC_LEFT (ic))->liveTo <= ic->seq)
+    {
+      iCode *dic = mc6809_findAssignToSym (IC_LEFT (ic), ic);
+      iCode *sic;
+
+      if (!dic)
+        goto right;
+
+      /* found it we need to remove it from the
+         block */
+      for (sic = dic; sic != ic; sic = sic->next)
+        bitVectUnSetBit (sic->rlive, IC_LEFT (ic)->key);
+
+      IC_LEFT (ic)->operand.symOperand = IC_RIGHT (dic)->operand.symOperand;
+      IC_LEFT (ic)->key = IC_RIGHT (dic)->operand.symOperand->key;
+      remiCodeFromeBBlock (ebp, dic);
+      bitVectUnSetBit (OP_SYMBOL (IC_RESULT (dic))->defs, dic->key);
+      hTabDeleteItem (&iCodehTab, dic->key, dic, DELETE_ITEM, NULL);
+      // PENDING: Check vs mcs51
+      change++;
+    }
+
+  /* do the same for the right operand */
+right:
+  if (!change && IS_ITEMP (IC_RIGHT (ic)) && OP_SYMBOL (IC_RIGHT (ic))->liveTo <= ic->seq)
+    {
+      iCode *dic = mc6809_findAssignToSym (IC_RIGHT (ic), ic);
+      iCode *sic;
+
+      if (!dic)
+        return change;
+
+      /* found it we need to remove it from the block */
+      for (sic = dic; sic != ic; sic = sic->next)
+        bitVectUnSetBit (sic->rlive, IC_RIGHT (ic)->key);
+
+      IC_RIGHT (ic)->operand.symOperand = IC_RIGHT (dic)->operand.symOperand;
+      IC_RIGHT (ic)->key = IC_RIGHT (dic)->operand.symOperand->key;
+
+      remiCodeFromeBBlock (ebp, dic);
+      bitVectUnSetBit (OP_SYMBOL (IC_RESULT (dic))->defs, dic->key);
+      hTabDeleteItem (&iCodehTab, dic->key, dic, DELETE_ITEM, NULL);
+      // PENDING: vs mcs51
+      change++;
+    }
+
+  return change;
+}
+#endif
+
+/** Will reduce some registers for single use.
+ */
+static iCode *
+packRegsForOneuse (iCode * ic, operand * op, eBBlock * ebp)
+{
+  bitVect *uses;
+  iCode *dic, *sic;
+
+  // PENDING: Disable
+  D (D_ALLOC, ("packRegsForOneUse: running on ic %p\n", ic));
+
+  /* if returning a literal then do nothing */
+  if (!IS_SYMOP (op))
+    return NULL;
+
+  /* only upto 2 bytes since we cannot predict
+     the usage of b, & acc */
+  if (getSize (operandType (op)) > 2)
+    return NULL;
+
+  if (ic->op != RETURN && ic->op != SEND)
+    return NULL;
+
+  /* this routine will mark the a symbol as used in one
+     instruction use only && if the defintion is local
+     (ie. within the basic block) && has only one definition &&
+     that definiion is either a return value from a
+     function or does not contain any variables in
+     far space */
+  uses = bitVectCopy (OP_USES (op));
+  bitVectUnSetBit (uses, ic->key);      /* take away this iCode */
+  if (!bitVectIsZero (uses))    /* has other uses */
+    return NULL;
+
+  /* if it has only one defintion */
+  if (bitVectnBitsOn (OP_DEFS (op)) > 1)
+    return NULL;                /* has more than one definition */
+
+  /* get that definition */
+  if (!(dic = hTabItemWithKey (iCodehTab, bitVectFirstBit (OP_DEFS (op)))))
+    return NULL;
+
+  /* found the definition now check if it is local */
+  if (dic->seq < ebp->fSeq || dic->seq > ebp->lSeq)
+    return NULL;                /* non-local */
+
+  /* now check if it is the return from a function call */
+  if (dic->op == CALL || dic->op == PCALL)
+    {
+      if (ic->op != SEND && ic->op != RETURN && !POINTER_SET (ic) && !POINTER_GET (ic))
+        {
+          OP_SYMBOL (op)->ruonly = 1;
+          return dic;
+        }
+      dic = dic->next;
+    }
+
+  /* otherwise check that the definition does
+     not contain any symbols in far space */
+  if (isOperandInFarSpace (IC_LEFT (dic)) ||
+      isOperandInFarSpace (IC_RIGHT (dic)) || IS_OP_RUONLY (IC_LEFT (ic)) || IS_OP_RUONLY (IC_RIGHT (ic)))
+    {
+      return NULL;
+    }
+
+  /* if pointer set then make sure the pointer is one byte */
+  if (POINTER_SET (dic))
+    return NULL;
+
+  if (POINTER_GET (dic))
+    return NULL;
+
+  sic = dic;
+
+  /* also make sure the intervenening instructions
+     don't have any thing in far space */
+  for (dic = dic->next; dic && dic != ic; dic = dic->next)
+    {
+      /* if there is an intervening function call then no */
+      if (dic->op == CALL || dic->op == PCALL)
+        return NULL;
+      /* if pointer set then make sure the pointer
+         is one byte */
+      if (POINTER_SET (dic))
+        return NULL;
+
+      if (POINTER_GET (dic))
+        return NULL;
+
+      /* if address of & the result is remat the okay */
+      if (dic->op == ADDRESS_OF && OP_SYMBOL (IC_RESULT (dic))->remat)
+        continue;
+
+      /* if left or right or result is in far space */
+      if (isOperandInFarSpace (IC_LEFT (dic)) ||
+          isOperandInFarSpace (IC_RIGHT (dic)) ||
+          isOperandInFarSpace (IC_RESULT (dic)) ||
+          IS_OP_RUONLY (IC_LEFT (dic)) || IS_OP_RUONLY (IC_RIGHT (dic)) || IS_OP_RUONLY (IC_RESULT (dic)))
+        {
+          return NULL;
+        }
+    }
+
+  /* Fixes #2646174, but there might be a better way */
+  if (ic->op == SEND)
+    return NULL;
+
+  /* Fixes #2982135, but there might be a better way */
+  if (ic->op == RETURN)
+    return NULL;
+
+  OP_SYMBOL (op)->ruonly = 1;
+  return sic;
+}
+
+/*-----------------------------------------------------------------*/
+/* isBitwiseOptimizable - requirements of JEAN LOUIS VERN          */
+/*-----------------------------------------------------------------*/
+static bool
+isBitwiseOptimizable (iCode * ic)
+{
+  sym_link *rtype = getSpec (operandType (IC_RIGHT (ic)));
+
+  /* bitwise operations are considered optimizable
+     under the following conditions (Jean-Louis VERN)
+
+     x & lit
+     bit & bit
+     bit & x
+     bit ^ bit
+     bit ^ x
+     x   ^ lit
+     x   | lit
+     bit | bit
+     bit | x
+   */
+  if (IS_LITERAL (rtype))
+    return TRUE;
+  return FALSE;
+}
+
+static iCode *
+packRegsForHLUse3 (iCode * lic, operand * op, eBBlock * ebp)
+{
+  int i, key;
+  symbol *sym;
+  iCode *ic, *dic;
+  bool isFirst = TRUE;
+  bool exstk = (currFunc && currFunc->stack > 127);
+
+  D (D_PACK_HLUSE3,
+     ("Checking HL on %p lic key %u first def %u line %u:\n", OP_SYMBOL (op), lic->key, bitVectFirstBit (OP_DEFS (op)),
+      lic->lineno));
+  if (D_PACK_HLUSE3)
+    piCode (lic, NULL);
+
+  if (OP_SYMBOL (op)->accuse)
+    {
+      return NULL;
+    }
+
+  if (OP_SYMBOL (op)->remat)
+    {
+      return NULL;
+    }
+
+  /* Only defined once */
+  if (bitVectnBitsOn (OP_DEFS (op)) > 1)
+    return NULL;
+
+  if ( getSize (operandType (op)) != 2 )
+    return NULL;
+
+  /* And this is the definition */
+  if (bitVectFirstBit (OP_DEFS (op)) != lic->key)
+    return NULL;
+
+  /* first check if any overlapping liverange has already been
+     assigned to DPTR */
+  if (OP_SYMBOL (op)->clashes)
+    {
+      for (i = 0; i < OP_SYMBOL (op)->clashes->size; i++)
+        {
+          if (bitVectBitValue (OP_SYMBOL (op)->clashes, i))
+            {
+              sym = hTabItemWithKey (liveRanges, i);
+              if (sym->accuse == ACCUSE_SCRATCH)
+                {
+                  return NULL;
+                }
+            }
+        }
+    }
+
+  /* Nothing else that clashes with this is using the scratch
+     register.  Scan through all of the intermediate instructions and
+     see if any of them could nuke HL.
+   */
+  dic = ic = hTabFirstItemWK (iCodeSeqhTab, OP_SYMBOL (op)->liveFrom);
+
+  for (; ic && ic->seq <= OP_SYMBOL (op)->liveTo; ic = hTabNextItem (iCodeSeqhTab, &key))
+    {
+      if (D_PACK_HLUSE3)
+        piCode (ic, NULL);
+      D (D_PACK_HLUSE3, ("(On %p: op: %u next: %p)\n", ic, ic->op, ic->next));
+
+      if (isFirst)
+        {
+          isFirst = FALSE;
+          if (ic->op == ADDRESS_OF)
+            continue;
+          if (POINTER_GET (ic))
+            continue;
+          if (ic->op == '=' && !POINTER_SET (ic))
+            continue;
+        }
+
+      if (IC_RESULT (ic) && IS_SYMOP (IC_RESULT (ic)) && (isOperandInDirSpace (IC_RESULT (ic)) || exstk))
+        return NULL;
+
+      if (IC_LEFT (ic) && IS_SYMOP (IC_LEFT (ic)) && isOperandInDirSpace (IC_LEFT (ic)))
+        return NULL;
+
+      if (IC_RIGHT (ic) && IS_SYMOP (IC_RIGHT (ic)) && isOperandInDirSpace (IC_RIGHT (ic)))
+        return NULL;
+
+      /* Handle the non left/right/result ones first */
+      if (ic->op == IFX)
+        continue;
+      if (ic->op == JUMPTABLE)
+        return NULL;
+
+      if (SKIP_IC2 (ic))
+        continue;
+
+      if (ic->op == CAST)
+        continue;
+
+      if (ic->op == IPUSH && isOperandEqual (op, IC_LEFT (ic)))
+        continue;
+
+      if (ic->op == SEND && isOperandEqual (op, IC_LEFT (ic)))
+        continue;
+
+      if (ic->op == CALL && isOperandEqual (op, IC_RESULT (ic)))
+        continue;
+
+      if (ic->op == LEFT_OP && isOperandLiteral (IC_RIGHT (ic)))
+        continue;
+
+      if (ic->op == '+' && (isOperandEqual (op, IC_LEFT (ic)) || isOperandEqual (op, IC_RIGHT (ic))))
+        continue;
+
+      if ((ic->op == '=' && !POINTER_SET (ic)) ||
+          ic->op == UNARYMINUS ||
+          ic->op == RETURN ||
+          ic->op == RIGHT_OP ||
+          (ic->op == '-'  && getSize (operandType (IC_RESULT (ic))) == 1) ||
+          ic->op == BITWISEAND ||
+          ic->op == '|' ||
+          ic->op == '>' || ic->op == '<' || ic->op == EQ_OP || (ic->op == '+' && getSize (operandType (IC_RESULT (ic))) == 1))
+        /* 16 bit addition uses add hl, rr */
+        continue;
+
+      if (ic->op == '*' && isOperandEqual (op, IC_LEFT (ic)))
+        continue;
+
+      if (POINTER_SET (ic) && isOperandEqual (op, IC_RESULT (ic)))
+        continue;
+
+      if (POINTER_GET (ic) && isOperandEqual (op, IC_LEFT (ic)))
+        continue;
+
+      if (IS_VALOP (IC_RIGHT (ic)) && (ic->op == EQ_OP || 0))
+        {
+          continue;
+        }
+
+      /* By default give up */
+      D (D_PACK_HLUSE3, ("packRegsForHLUse3 giving up at icode %u\n", (unsigned) (ic->op)));
+      return NULL;
+    }
+
+  D (D_PACK_HLUSE3, ("Succeeded!\n")) OP_SYMBOL (op)->accuse = ACCUSE_SCRATCH;
+  return dic;
+}
+
+static iCode *
+packRegsForIYUse (iCode * lic, operand * op, eBBlock * ebp)
+{
+  int i, key;
+  symbol *sym;
+  iCode *ic, *dic;
+  bitVect *uses;
+
+  D (D_PACK_IY,
+     ("Checking IY on %p lic key %u first def %u line %u:\n", OP_SYMBOL (op), lic->key, bitVectFirstBit (OP_DEFS (op)),
+      lic->lineno));
+  if (D_PACK_IY)
+    piCode (lic, NULL);
+
+  if (OP_SYMBOL (op)->accuse)
+    {
+      return NULL;
+    }
+
+  if (OP_SYMBOL (op)->remat)
+    {
+      return NULL;
+    }
+
+  /* Only defined once */
+  if (bitVectnBitsOn (OP_DEFS (op)) > 1)
+    return NULL;
+
+  /* And this is the definition */
+  if (bitVectFirstBit (OP_DEFS (op)) != lic->key)
+    return NULL;
+
+  /* first check if any overlapping liverange has already been
+     assigned to DPTR */
+  if (OP_SYMBOL (op)->clashes)
+    {
+      for (i = 0; i < OP_SYMBOL (op)->clashes->size; i++)
+        {
+          if (bitVectBitValue (OP_SYMBOL (op)->clashes, i))
+            {
+              sym = hTabItemWithKey (liveRanges, i);
+              if (sym->accuse == ACCUSE_IY)
+                {
+                  return NULL;
+                }
+            }
+        }
+    }
+
+  /* Only a few instructions can load into IY */
+  if (lic->op != '=')
+    {
+      return NULL;
+    }
+
+  if (getSize (operandType (op)) != 2)
+    {
+      D (D_PACK_IY, ("  + Dropping as operation has size is too big\n"));
+      return FALSE;
+    }
+
+  /* Nothing else that clashes with this is using the scratch
+     register.  Scan through all of the intermediate instructions and
+     see if any of them could nuke HL.
+   */
+  dic = ic = hTabFirstItemWK (iCodeSeqhTab, OP_SYMBOL (op)->liveFrom);
+  uses = OP_USES (op);
+
+  for (; ic && ic->seq <= OP_SYMBOL (op)->liveTo; ic = hTabNextItem (iCodeSeqhTab, &key))
+    {
+      if (D_PACK_IY)
+        piCode (ic, NULL);
+
+      if (ic->op == PCALL || ic->op == CALL || ic->op == JUMPTABLE)
+        return NULL;
+
+      if (SKIP_IC2 (ic))
+        continue;
+
+      /* Be pessamistic. */
+      if (ic->op == IFX)
+        return NULL;
+
+      D (D_PACK_IY, ("  op: %u uses %u result: %d left: %d right: %d\n", ic->op, bitVectBitValue (uses, ic->key),
+                     IC_RESULT (ic) && IS_SYMOP (IC_RESULT (ic)) ? isOperandInDirSpace (IC_RESULT (ic)) : -1,
+                     IC_LEFT (ic) && IS_SYMOP (IC_LEFT (ic)) ? isOperandInDirSpace (IC_LEFT (ic)) : -1,
+                     IC_RIGHT (ic) && IS_SYMOP (IC_RIGHT (ic)) ? isOperandInDirSpace (IC_RIGHT (ic)) : -1));
+
+      if (IC_RESULT (ic) && IS_SYMOP (IC_RESULT (ic)) && isOperandInDirSpace (IC_RESULT (ic)))
+        return NULL;
+
+      if (IC_RIGHT (ic) && IS_SYMOP (IC_RIGHT (ic)) && isOperandInDirSpace (IC_RIGHT (ic)))
+        return NULL;
+
+      if (IC_LEFT (ic) && IS_SYMOP (IC_LEFT (ic)) && isOperandInDirSpace (IC_LEFT (ic)))
+        return NULL;
+
+      /* Only certain rules will work against IY.  Check if this iCode uses
+         this symbol. */
+      if (bitVectBitValue (uses, ic->key) != 0)
+        {
+          if (ic->op == '=' && isOperandEqual (IC_RESULT (ic), op))
+            continue;
+
+          if (ic->op == GET_VALUE_AT_ADDRESS && isOperandEqual (IC_LEFT (ic), op))
+            continue;
+
+          if (isOperandEqual (IC_RESULT (ic), IC_LEFT (ic)) == FALSE)
+            return NULL;
+
+          if (IC_RIGHT (ic) && IS_VALOP (IC_RIGHT (ic)))
+            {
+              if (ic->op == '+' || ic->op == '-')
+                {
+                  /* Only works if the constant is small */
+                  if (operandLitValue (IC_RIGHT (ic)) < 4)
+                    continue;
+                }
+            }
+
+          return NULL;
+        }
+      else
+        {
+          /* This iCode doesn't use the sym.  See if this iCode preserves IY.
+           */
+          continue;
+        }
+
+      /* By default give up */
+      return NULL;
+    }
+
+  D (D_PACK_IY, ("Succeeded IY!\n"));
+
+  OP_SYMBOL (op)->accuse = ACCUSE_IY;
+  return dic;
+}
+
+/** Returns TRUE if this operation can use acc and if it preserves the value.
+ */
+static bool
+opPreservesA (iCode * uic)
+{
+  if (uic->op == IFX)
+    {
+      /* If we've gotten this far then the thing to compare must be
+         small enough and must be in A.
+       */
+      return TRUE;
+    }
+
+  if (uic->op == JUMPTABLE)
+    {
+      D (D_ACCUSE2, ("  + Dropping as operation is a Jumptable\n"));
+      return FALSE;
+    }
+
+  /* A pointer assign preserves A if A is the left value. */
+  if (uic->op == '=' && POINTER_SET (uic) && !IY_RESERVED)
+    {
+      return TRUE;
+    }
+
+  /* if the usage has only one operand then we can */
+  /* PENDING: check */
+  if (IC_LEFT (uic) == NULL || IC_RIGHT (uic) == NULL)
+    {
+      D (D_ACCUSE2, ("  + Dropping as operation has only one operand\n"));
+      return FALSE;
+    }
+
+  /* PENDING: check this rule */
+  if (getSize (operandType (IC_RESULT (uic))) > 1)
+    {
+      D (D_ACCUSE2, ("  + Dropping as operation has size is too big\n"));
+      return FALSE;
+    }
+
+  return FALSE;
+}
+
+/* Return TRUE if this operation can use A (it doesn't have to keep A unchanged) */
+static bool
+opCanUseA (iCode * uic)
+{
+  if (uic->op == IFX)
+    {
+      /* If we've gotten this far then the thing to compare must be
+         small enough and must be in A.
+       */
+      return TRUE;
+    }
+  if (uic->op == JUMPTABLE)
+    {
+      D (D_ACCUSE2, ("  + Dropping as operation is a Jumptable\n"));
+      return FALSE;
+    }
+
+  if (uic->op == '=' && !(IY_RESERVED && POINTER_SET (uic)))
+    {
+      return TRUE;
+    }
+
+  if ((uic->op == RIGHT_OP || uic->op == LEFT_OP) && IS_OP_LITERAL (IC_RIGHT (uic)))
+    {
+      return TRUE;
+    }
+
+  /* Somehow fails for unary minus. */
+  if (IC_LEFT (uic) == NULL || IC_RIGHT (uic) == NULL)
+    {
+      D (D_ACCUSE2, ("  + Dropping as operation has only one operand\n"));
+      return FALSE;
+    }
+
+  if (IS_BITWISE_OP (uic))
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+/** Returns true if this operand preserves the value of A.
+ */
+static bool
+opIgnoresA (iCode * ic, iCode * uic)
+{
+  /* A increment of an iTemp by a constant is OK. */
+  if (uic->op == '+' && IS_ITEMP (IC_LEFT (uic)) && IS_ITEMP (IC_RESULT (uic)) && IS_OP_LITERAL (IC_RIGHT (uic)))
+    {
+      unsigned int icount = (unsigned int) ulFromVal (OP_VALUE (IC_RIGHT (uic)));
+
+      /* Being an ITEMP means that we're already a symbol. */
+      if (icount == 1 && OP_KEY (IC_RESULT (uic)) == OP_KEY (IC_LEFT (uic)))
+        {
+          return TRUE;
+        }
+    }
+  else if (uic->op == '=' && !POINTER_SET (uic))
+    {
+      /* If they are equal and get optimised out then things are OK. */
+      if (isOperandEqual (IC_RESULT (uic), IC_RIGHT (uic)))
+        {
+          /* Straight assign is OK. */
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+/** Pack registers for acc use.
+    When the result of this operation is small and short lived it may
+    be able to be stored in the accumulator.
+
+    Note that the 'A preserving' list is currently emperical :)
+ */
+static void
+packRegsForAccUse2 (iCode * ic)
+{
+  iCode *uic;
+
+  D (D_ACCUSE2, ("packRegsForAccUse2: running on ic %p line %u\n", ic, ic->lineno));
+  if (D_ACCUSE2)
+    piCode (ic, NULL);
+
+  /* Filter out all but those 'good' commands */
+  if (!POINTER_GET (ic) &&
+      ic->op != '+' &&
+      ic->op != '-' &&
+      !IS_BITWISE_OP (ic) &&
+      ic->op != '=' &&
+      ic->op != EQ_OP &&
+      ic->op != '<' &&
+      ic->op != '>' &&
+      ic->op != CAST && ic->op != GETHBIT && !((ic->op == LEFT_OP || ic->op == RIGHT_OP) && IS_OP_LITERAL (IC_RIGHT (ic))))
+    {
+      D (D_ACCUSE2, ("  + Dropping as not a 'good' source command\n"));
+      return;
+    }
+
+  /* if + or - then it has to be one byte result.
+     MLH: Ok.
+   */
+  if ((ic->op == '+' || ic->op == '-' || ic->op == LEFT_OP || ic->op == RIGHT_OP) && getSize (operandType (IC_RESULT (ic))) > 1)
+    {
+      D (D_ACCUSE2, ("  + Dropping as it's a big one\n"));
+      return;
+    }
+
+  /* has only one definition */
+  if (bitVectnBitsOn (OP_DEFS (IC_RESULT (ic))) > 1)
+    {
+      D (D_ACCUSE2, ("  + Dropping as it has more than one definition\n"));
+      return;
+    }
+
+  /* Right.  We may be able to propagate it through if:
+     For each in the chain of uses the intermediate is OK.
+   */
+  /* Get next with 'uses result' bit on
+     If this->next == next
+     Validate use of next
+     If OK, increase count
+   */
+  /* and the usage immediately follows this iCode */
+  if (!(uic = hTabItemWithKey (iCodehTab, bitVectFirstBit (OP_USES (IC_RESULT (ic))))))
+    {
+      D (D_ACCUSE2, ("  + Dropping as usage does not follow first\n"));
+      return;
+    }
+
+  {
+    /* Create a copy of the OP_USES bit vect */
+    bitVect *uses = bitVectCopy (OP_USES (IC_RESULT (ic)));
+    int setBit;
+    iCode *scan = ic, *next;
+
+    do
+      {
+        setBit = bitVectFirstBit (uses);
+        next = hTabItemWithKey (iCodehTab, setBit);
+        if (scan->next == next)
+          {
+            D (D_ACCUSE2_VERBOSE, ("  ! Is next in line\n"));
+
+            bitVectUnSetBit (uses, setBit);
+
+            if (bitVectIsZero (uses) && opCanUseA (next))
+              {
+                D (D_ACCUSE2, ("  Arrived at last op safely.\n"));
+                break;
+              }
+            /* Still contigous. */
+            if (!opPreservesA (next))
+              {
+                D (D_ACCUSE2, ("  + Dropping as operation doesn't preserve A\n"));
+                return;
+              }
+            D (D_ACCUSE2_VERBOSE, ("  ! Preserves A, so continue scanning\n"));
+            scan = next;
+          }
+        /*else if (scan->next == NULL && bitVectnBitsOn (uses) == 1 && next != NULL)
+           {
+           if (next->prev == NULL)
+           {
+           if (!opPreservesA (next))
+           {
+           D (D_ACCUSE2, ("  + Dropping as operation doesn't preserve A #2\n"));
+           return;
+           }
+           bitVectUnSetBit (uses, setBit);
+           scan = next;
+           }
+           else
+           {
+           D (D_ACCUSE2, ("  + Dropping as last in list and next doesn't start a block\n"));
+           return;
+           }
+           } //This caused bug #1292721 */
+        else if (scan->next == NULL)
+          {
+            D (D_ACCUSE2, ("  + Dropping as hit the end of the list\n"));
+            D (D_ACCUSE2, ("  + Next in htab: %p\n", next));
+            return;
+          }
+        else
+          {
+            if (opIgnoresA (ic, scan->next))
+              {
+                /* Safe for now. */
+                scan = scan->next;
+                D (D_ACCUSE2_VERBOSE, ("  ! Op ignores A, so continue scanning\n"));
+              }
+            else
+              {
+                D (D_ACCUSE2, ("  + Dropping as parts are not consecuitive and intermediate might use A\n"));
+                return;
+              }
+          }
+      }
+    while (!bitVectIsZero (uses));
+
+    OP_SYMBOL (IC_RESULT (ic))->accuse = ACCUSE_A;
+    return;
+  }
+}
+
+/** Does some transformations to reduce register pressure.
+ */
+static void
+packRegisters (eBBlock * ebp)
+{
+  iCode *ic;
+  int change = 0;
+
+  D (D_ALLOC, ("packRegisters: entered.\n"));
+
+  while (1 && !DISABLE_PACK_ASSIGN)
+    {
+      change = 0;
+      /* look for assignments of the form */
+      /* iTempNN = TRueSym (someoperation) SomeOperand */
+      /*       ....                       */
+      /* TrueSym := iTempNN:1             */
+      for (ic = ebp->sch; ic; ic = ic->next)
+        {
+          /* find assignment of the form TrueSym := iTempNN:1 */
+          if (ic->op == '=' && !POINTER_SET (ic))
+            change += packRegsForAssign (ic, ebp);
+        }
+      if (!change)
+        break;
+    }
+
+  for (ic = ebp->sch; ic; ic = ic->next)
+    {
+      D (D_ALLOC, ("packRegisters: looping on ic %p\n", ic));
+
+      /* Safe: address of a true sym is always constant. */
+      /* if this is an itemp & result of a address of a true sym
+         then mark this as rematerialisable   */
+      if (ic->op == ADDRESS_OF &&
+          IS_ITEMP (IC_RESULT (ic)) && bitVectnBitsOn (OP_DEFS (IC_RESULT (ic))) == 1 && !IS_PARM (IC_RESULT (ic)) /* The receiving of the paramter isnot accounted for in DEFS */ &&
+          IS_TRUE_SYMOP (IC_LEFT (ic)) && !OP_SYMBOL (IC_LEFT (ic))->onStack)
+        {
+          OP_SYMBOL (IC_RESULT (ic))->remat = 1;
+          OP_SYMBOL (IC_RESULT (ic))->rematiCode = ic;
+          OP_SYMBOL (IC_RESULT (ic))->usl.spillLoc = NULL;
+        }
+
+      /* Safe: just propagates the remat flag */
+      /* if straight assignment then carry remat flag if this is the
+         only definition */
+      if (ic->op == '=' && !POINTER_SET (ic) && IS_SYMOP (IC_RIGHT (ic)) && OP_SYMBOL (IC_RIGHT (ic))->remat &&
+        !isOperandGlobal (IC_RESULT (ic)) && bitVectnBitsOn (OP_SYMBOL (IC_RESULT (ic))->defs) == 1 && !IS_PARM (IC_RESULT (ic)) && /* The receiving of the paramter isnot accounted for in DEFS */
+        !OP_SYMBOL (IC_RESULT (ic))->addrtaken)
+        {
+          OP_SYMBOL (IC_RESULT (ic))->remat = OP_SYMBOL (IC_RIGHT (ic))->remat;
+          OP_SYMBOL (IC_RESULT (ic))->rematiCode = OP_SYMBOL (IC_RIGHT (ic))->rematiCode;
+        }
+
+      /* if cast to a generic pointer & the pointer being
+         cast is remat, then we can remat this cast as well */
+      if (ic->op == CAST &&
+          IS_SYMOP (IC_RIGHT (ic)) && OP_SYMBOL (IC_RIGHT (ic))->remat &&
+          !isOperandGlobal (IC_RESULT (ic)) && bitVectnBitsOn (OP_DEFS (IC_RESULT (ic))) == 1 && !IS_PARM (IC_RESULT (ic)) && /* The receiving of the paramter isnot accounted for in DEFS */
+          !OP_SYMBOL (IC_RESULT (ic))->addrtaken)
+        {
+          sym_link *to_type = operandType (IC_LEFT (ic));
+          sym_link *from_type = operandType (IC_RIGHT (ic));
+          if ((IS_PTR (to_type) || IS_INT (to_type)) && IS_PTR (from_type))
+            {
+              OP_SYMBOL (IC_RESULT (ic))->remat = 1;
+              OP_SYMBOL (IC_RESULT (ic))->rematiCode = ic;
+              OP_SYMBOL (IC_RESULT (ic))->usl.spillLoc = NULL;
+            }
+        }
+
+      /* if this is a +/- operation with a rematerizable
+         then mark this as rematerializable as well */
+      if ((ic->op == '+' || ic->op == '-') &&
+          (IS_SYMOP (IC_LEFT (ic)) &&
+           IS_ITEMP (IC_RESULT (ic)) &&
+           IS_OP_LITERAL (IC_RIGHT (ic))) &&
+          OP_SYMBOL (IC_LEFT (ic))->remat &&
+          (!IS_SYMOP (IC_RIGHT (ic)) || !IS_CAST_ICODE (OP_SYMBOL (IC_RIGHT (ic))->rematiCode)) &&
+          bitVectnBitsOn (OP_DEFS (IC_RESULT (ic))) == 1)
+        {
+          OP_SYMBOL (IC_RESULT (ic))->remat = 1;
+          OP_SYMBOL (IC_RESULT (ic))->rematiCode = ic;
+          OP_SYMBOL (IC_RESULT (ic))->usl.spillLoc = NULL;
+        }
+
+      /* if the condition of an if instruction is defined in the
+         previous instruction then mark the itemp as a conditional */
+      if ((IS_CONDITIONAL (ic) ||
+           ((ic->op == BITWISEAND ||
+             ic->op == '|' ||
+             ic->op == '^') &&
+            isBitwiseOptimizable (ic))) &&
+          ic->next && ic->next->op == IFX &&
+          bitVectnBitsOn (OP_USES (IC_RESULT (ic))) == 1 &&
+          isOperandEqual (IC_RESULT (ic), IC_COND (ic->next)) && OP_SYMBOL (IC_RESULT (ic))->liveTo <= ic->next->seq)
+        {
+
+          OP_SYMBOL (IC_RESULT (ic))->regType = REG_CND;
+          continue;
+        }
+
+      /* some cases the redundant moves can
+         can be eliminated for return statements */
+      if (ic->op == RETURN || ic->op == SEND)
+        {
+          packRegsForOneuse (ic, IC_LEFT (ic), ebp);
+        }
+
+      /* if pointer set & left has a size more than
+         one and right is not in far space */
+      if (!DISABLE_PACK_ONE_USE && POINTER_SET (ic) && IS_SYMOP (IC_RESULT (ic)) &&
+          /* MLH: no such thing.
+             !isOperandInFarSpace(IC_RIGHT(ic)) && */
+          !OP_SYMBOL (IC_RESULT (ic))->remat &&
+          !IS_OP_RUONLY (IC_RIGHT (ic)) && getSize (aggrToPtr (operandType (IC_RESULT (ic)), FALSE)) > 1)
+        {
+          packRegsForOneuse (ic, IC_RESULT (ic), ebp);
+        }
+
+      /* if pointer get */
+      if (!DISABLE_PACK_ONE_USE && POINTER_GET (ic) && IS_SYMOP (IC_LEFT (ic)) &&
+          /* MLH: dont have far space
+             !isOperandInFarSpace(IC_RESULT(ic))&& */
+          !OP_SYMBOL (IC_LEFT (ic))->remat &&
+          !IS_OP_RUONLY (IC_RESULT (ic)) && getSize (aggrToPtr (operandType (IC_LEFT (ic)), FALSE)) > 1)
+        {
+          packRegsForOneuse (ic, IC_LEFT (ic), ebp);
+        }
+
+      /* pack registers for accumulator use, when the result of an
+         arithmetic or bit wise operation has only one use, that use is
+         immediately following the defintion and the using iCode has
+         only one operand or has two operands but one is literal & the
+         result of that operation is not on stack then we can leave the
+         result of this operation in acc:b combination */
+
+      if (!DISABLE_PACK_HL && IS_ITEMP (IC_RESULT (ic)))
+        if (!IY_RESERVED)
+          packRegsForHLUse3 (ic, IC_RESULT (ic), ebp);
+
+      if ((!OPTRALLOC_IY) && !DISABLE_PACK_IY && !IY_RESERVED && IS_ITEMP (IC_RESULT (ic)))
+        packRegsForIYUse (ic, IC_RESULT (ic), ebp);
+
+      if (!DISABLE_PACK_ACC && IS_ITEMP (IC_RESULT (ic)) &&
+          getSize (operandType (IC_RESULT (ic))) == 1)
+        packRegsForAccUse2 (ic);
+    }
+}
+
+/** Joins together two byte constant pushes into one word push.
+ */
+static iCode *
+joinPushes (iCode * lic)
+{
+  iCode *ic, *uic, *fic;
+
+  for (ic = lic; ic; ic = ic->next)
+    {
+      int first, second;
+      value *val;
+      struct dbuf_s dbuf;
+
+      uic = ic->next;
+
+      /* Anything past this? */
+      if (uic == NULL)
+        continue;
+
+      /* This and the next pushes? */
+      if (ic->op != IPUSH || uic->op != IPUSH)
+        continue;
+
+      /* Find call */
+      for(fic = uic; fic->op == IPUSH; fic = fic->next);
+      if (ic->op != CALL && fic->op != PCALL)
+        continue;
+      {
+        sym_link *dtype = operandType (IC_LEFT (fic));
+        sym_link *ftype = IS_FUNCPTR (dtype) ? dtype->next : dtype;
+        if (IFFUNC_ISSMALLC (ftype)) /* SmallC calling convention pushes 8-bit values as 16 bit */
+          continue;
+      }
+
+      /* Both literals? */
+      if (!IS_OP_LITERAL (IC_LEFT (ic)) || !IS_OP_LITERAL (IC_LEFT (uic)))
+        continue;
+
+      /* Both characters? */
+      if (getSize (operandType (IC_LEFT (ic))) != 1 || getSize (operandType (IC_LEFT (uic))) != 1)
+        {
+          continue;
+        }
+      /* Pull out the values, make a new type, and create the new iCode for it.
+       */
+      first = (int) operandLitValue (IC_LEFT (ic));
+      second = (int) operandLitValue (IC_LEFT (uic));
+
+      dbuf_init (&dbuf, 128);
+      dbuf_printf (&dbuf, "%uu", ((first << 8) | (second & 0xFF)) & 0xFFFFU);
+      val = constVal (dbuf_c_str (&dbuf));
+      dbuf_destroy (&dbuf);
+      SPEC_NOUN (val->type) = V_INT;
+      IC_LEFT (ic) = operandFromValue (val);
+
+      /* Now remove the second one from the list. */
+      ic->next = uic->next;
+      if (uic->next)
+        {
+          /* Patch up the reverse link */
+          uic->next->prev = ic;
+        }
+    }
+
+  return lic;
+}
+
+/** Serially allocate registers to the variables.
+    This was the main register allocation function.  It is called after
+    packing.
+    In the new register allocator it only serves to mark variables for the new register allocator.
+ */
+static void
+serialRegMark (eBBlock ** ebbs, int count)
+{
+  int i;
+  short int max_alloc_bytes = SHRT_MAX; // Byte limit. Set this to a low value to pass only few variables to the register allocator. This can be useful for debugging.
+
+  /* for all blocks */
+  for (i = 0; i < count; i++)
+    {
+      iCode *ic;
+
+      if (ebbs[i]->noPath && (ebbs[i]->entryLabel != entryLabel && ebbs[i]->entryLabel != returnLabel))
+        continue;
+
+      /* for all instructions do */
+      for (ic = ebbs[i]->sch; ic; ic = ic->next)
+        {
+          /* if this is an ipop that means some live
+             range will have to be assigned again */
+          if (ic->op == IPOP)
+            {
+              wassert (0);
+              reassignLR (IC_LEFT (ic));
+            }
+
+          /* if result is present && is a true symbol */
+          if (IC_RESULT (ic) && ic->op != IFX && IS_TRUE_SYMOP (IC_RESULT (ic)))
+            {
+              OP_SYMBOL (IC_RESULT (ic))->allocreq++;
+            }
+
+          /* take away registers from live
+             ranges that end at this instruction */
+          deassignLRs (ic, ebbs[i]);
+
+          /* some don't need registers */
+          if (SKIP_IC2 (ic) ||
+              ic->op == JUMPTABLE || ic->op == IFX || ic->op == IPUSH || ic->op == IPOP || (IC_RESULT (ic) && POINTER_SET (ic)))
+            {
+              continue;
+            }
+
+          /* now we need to allocate registers only for the result */
+          if (IC_RESULT (ic))
+            {
+              symbol *sym = OP_SYMBOL (IC_RESULT (ic));
+
+              D (D_ALLOC, ("serialRegAssign: in loop on result %p (%s)\n", sym, sym->name));
+
+              /* Make sure any spill location is definately allocated */
+              if (sym->isspilt && !sym->remat && sym->usl.spillLoc && !sym->usl.spillLoc->allocreq)
+                {
+                  sym->usl.spillLoc->allocreq++;
+                }
+
+              /* if it does not need or is spilt
+                 or is already assigned to registers (or marked for the new allocator)
+                 or will not live beyond this instructions */
+              if (!sym->nRegs ||
+                  sym->isspilt || bitVectBitValue (_G.regAssigned, sym->key) || sym->for_newralloc || (sym->liveTo <= ic->seq && (sym->nRegs <= 4 || ic->op != CALL && ic->op != PCALL)))
+                {
+                  D (D_ALLOC, ("serialRegAssign: won't live long enough.\n"));
+                  continue;
+                }
+
+              /* if some liverange has been spilt at the block level
+                 and this one live beyond this block then spil this
+                 to be safe */
+              if (_G.blockSpil && sym->liveTo > ebbs[i]->lSeq)
+                {
+                  D (D_ALLOC, ("serialRegAssign: \"spilling to be safe.\"\n"));
+                  sym->for_newralloc = 0;
+                  mc6809SpillThis (sym);
+                  continue;
+                }
+
+              if (sym->usl.spillLoc && !sym->usl.spillLoc->_isparm) // I have no idea where these spill locations come from. Sometime two symbols even have the same spill location, whic tends to mess up stack allocation. Those that come from previous iterations in this loop would be okay, but those from outside are a problem.
+                {
+                  sym->usl.spillLoc = 0;
+                  sym->isspilt = false;
+                }
+
+              if (sym->nRegs > 4) /* TODO. Change this once we can allocate bigger variables (but still spill when its a big return value). Also change in ralloc2.cc, operand_on-stack in that case*/
+                {
+                  D (D_ALLOC, ("Spilling %s (too large)\n", sym->name));
+                  sym->for_newralloc = 0;
+                  mc6809SpillThis (sym);
+                }
+              else if (max_alloc_bytes >= sym->nRegs)
+                {
+                  sym->for_newralloc = 1;
+                  max_alloc_bytes -= sym->nRegs;
+                }
+              else if (!sym->for_newralloc)
+                {
+                  mc6809SpillThis (sym);
+                  printf ("Spilt %s due to byte limit.\n", sym->name);
+                }
+            }
+        }
+    }
+}
+
+void
+MC6809RegFix (eBBlock ** ebbs, int count)
+{
+  int i;
+
+  /* Check for and fix any problems with uninitialized operands */
+  for (i = 0; i < count; i++)
+    {
+      iCode *ic;
+
+      if (ebbs[i]->noPath && (ebbs[i]->entryLabel != entryLabel && ebbs[i]->entryLabel != returnLabel))
+        continue;
+
+      for (ic = ebbs[i]->sch; ic; ic = ic->next)
+        {
+          deassignLRs (ic, ebbs[i]);
+
+          if (SKIP_IC2 (ic))
+            continue;
+
+          if (ic->op == IFX)
+            {
+              verifyRegsAssigned (IC_COND (ic), ic);
+              continue;
+            }
+
+          if (ic->op == JUMPTABLE)
+            {
+              verifyRegsAssigned (IC_JTCOND (ic), ic);
+              continue;
+            }
+
+          verifyRegsAssigned (IC_RESULT (ic), ic);
+          verifyRegsAssigned (IC_LEFT (ic), ic);
+          verifyRegsAssigned (IC_RIGHT (ic), ic);
+        }
+    }
+}
+
+void mc6809_init_asmops (void);
+
+/*-----------------------------------------------------------------*/
+/* New register allocator                                          */
+/*-----------------------------------------------------------------*/
+void
+mc6809_ralloc (ebbIndex *ebbi)
+{
+  eBBlock **ebbs = ebbi->bbOrder;
+  int count = ebbi->count;
+  iCode *ic;
+  int i;
+
+  D (D_ALLOC, ("\n-> mc6809_ralloc: entered for %s.\n", currFunc ? currFunc->name : "[no function]"));
+
+  setToNull ((void *) &_G.funcrUsed);
+  setToNull ((void *) &_G.totRegAssigned);
+  _G.stackExtend = _G.dataExtend = 0;
+
+  _G.nRegs = MC6809_MAX_REGS;
+  regsMC6809 = _mc6809_regs;
+
+  mc6809_init_asmops ();
+
+  /* change assignments this will remove some
+     live ranges reducing some register pressure */
+  for (i = 0; i < count; i++)
+    packRegisters (ebbs[i]);
+
+  /* liveranges probably changed by register packing
+     so we compute them again */
+  recomputeLiveRanges (ebbs, count, FALSE);
+
+  if (options.dump_i_code)
+    dumpEbbsToFileExt (DUMP_PACK, ebbi);
+
+  /* first determine for each live range the number of
+     registers & the type of registers required for each */
+  regTypeNum ();
+
+  /* Mark variables for assignment by the new allocator */
+  serialRegMark (ebbs, count);
+
+  joinPushes (iCodeLabelOptimize(iCodeFromeBBlock (ebbs, count)));
+
+  /* The new register allocator invokes its magic */
+  ic = mc6809_ralloc2_cc (ebbi);
+
+  if (options.dump_i_code)
+    {
+      dumpEbbsToFileExt (DUMP_RASSGN, ebbi);
+      dumpLiveRanges (DUMP_LRANGE, liveRanges);
+    }
+
+  genMC6809Code (ic);
+
+  /* free up any stackSpil locations allocated */
+  applyToSet (_G.stackSpil, deallocStackSpil);
+  _G.slocNum = 0;
+  setToNull ((void *) &_G.stackSpil);
+  setToNull ((void *) &_G.spiltSet);
+  /* mark all registers as free */
+  freeAllRegs ();
+
+  return;
+}
+
+/*-----------------------------------------------------------------*/
+/* assignRegisters - assigns registers to each live range as need  */
+/*-----------------------------------------------------------------*/
+void
+mc6809_assignRegisters (ebbIndex * ebbi)
+{
+    mc6809_ralloc (ebbi);
+}
+
diff --git a/sdcc/src/mc6809/ralloc.h b/sdcc/src/mc6809/ralloc.h
new file mode 100644
index 000000000..8718c3c90
--- /dev/null
+++ b/sdcc/src/mc6809/ralloc.h
@@ -0,0 +1,62 @@
+/*-------------------------------------------------------------------------
+
+  mc6809/ralloc.h - header file register allocation
+
+                Written By -  Sandeep Dutta . sandeep.dutta@usa.net (1998)
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+   
+   In other words, you are welcome to use, share and improve this program.
+   You are forbidden to forbid anyone else to use, share and improve
+   what you give them.   Help stamp out software-hoarding!  
+-------------------------------------------------------------------------*/
+#ifndef MC6809_RALLOC_H
+#define MC6809_RALLOC_H 1
+
+#include "SDCCicode.h"
+#include "SDCCBBlock.h"
+
+#include "reg_index.h"
+
+enum
+{
+  REG_PTR = 1,
+  REG_GPR = 2,
+  REG_CND = 4
+};
+
+/* definition for the registers */
+typedef struct reg_info
+{
+  short type;                   /* can have value 
+                                   REG_GPR, REG_PTR or REG_CND */
+  short rIdx;                   /* index into register table */
+  char *name;                   /* name */
+  unsigned isFree:1;            /* is currently unassigned  */
+} reg_info;
+
+extern reg_info *regsMC6809;
+
+void assignRegisters (eBBlock **, int);
+reg_info *regWithIdx (int);
+
+void mc6809_assignRegisters (ebbIndex *);
+bitVect *mc6809_rUmaskForOp (const operand * op);
+
+void mc6809SpillThis (symbol *);
+iCode *mc6809_ralloc2_cc(ebbIndex *ebbi);
+
+void MC6809RegFix (eBBlock ** ebbs, int count);
+#endif
diff --git a/sdcc/src/mc6809/ralloc2.cc b/sdcc/src/mc6809/ralloc2.cc
new file mode 100644
index 000000000..da8df1527
--- /dev/null
+++ b/sdcc/src/mc6809/ralloc2.cc
@@ -0,0 +1,930 @@
+// Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de, pkk@spth.de, 2010 - 2011
+//
+// (c) 2010-2012 Goethe-Universitt Frankfurt
+//
+// This program is free software; you can redistribute it and/or modify it
+// under the terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option) any
+// later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+// An optimal, polynomial-time register allocator.
+
+// #define DEBUG_RALLOC_DEC // Uncomment to get debug messages while doing register allocation on the tree decomposition.
+// #define DEBUG_RALLOC_DEC_ASS // Uncomment to get debug messages about assignments while doing register allocation on the tree decomposition (much more verbose than the one above).
+
+#include "SDCCralloc.hpp"
+#include "SDCCsalloc.hpp"
+
+extern "C"
+{
+  #include "m6809.h"
+  unsigned char dryMC6809iCode (iCode * ic);
+  bool mc6809_assignment_optimal;
+  bool mc6809_should_omit_frame_ptr;
+}
+
+#define REG_A 0
+#define REG_B 1
+#define REG_CC 2
+#define REG_DP 3
+#define REG_D 4
+#define REG_X 5
+#define REG_Y 6
+#define REG_U 7
+#define REG_S 8
+#define REG_PC 9
+
+template <class G_t, class I_t>
+float default_operand_cost(const operand *o, const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  float c = 0.0f;
+
+  operand_map_t::const_iterator oi, oi_end;
+
+  var_t byteregs[4];    // Todo: Change this when sdcc supports variables larger than 4 bytes in registers.
+  unsigned short int size;
+
+  if(o && IS_SYMOP(o))
+    {
+      boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key);
+      if(oi != oi_end)
+        {
+          var_t v = oi->second;
+
+          // In registers.
+          if(std::binary_search(a.local.begin(), a.local.end(), v))
+            {
+              c += 1.0f;
+              byteregs[I[v].byte] = a.global[v];
+              size = 1;
+
+              while(++oi != oi_end)
+                {
+                  v = oi->second;
+                  c += (std::binary_search(a.local.begin(), a.local.end(), v) ? 1.0f : std::numeric_limits<float>::infinity());
+                  byteregs[I[v].byte] = a.global[v];
+                  size++;
+                }
+
+              // Penalty for not placing 2- and 4-byte variables in register pairs
+              // Todo: Extend this once the register allcoator can use registers other than bc, de:
+              if ((size == 2 || size == 4) &&
+                  (byteregs[1] != byteregs[0] + 1 ))
+                c += 2.0f;
+              if (size == 4 &&
+                  (byteregs[3] != byteregs[2] + 1 ))
+                c += 2.0f;
+
+              // Code generator cannot handle variables only partially in A.
+              if(size > 1)
+                for(unsigned short int i = 0; i < size; i++)
+                  if(byteregs[i] == REG_A)
+                    c += std::numeric_limits<float>::infinity();
+
+              if(byteregs[0] == REG_A)
+                c -= 0.4f;
+              else if(OPTRALLOC_IY)
+                c += 0.1f;
+            }
+          // Spilt.
+          else
+            {
+              c += OP_SYMBOL_CONST(o)->remat ? 1.5f : 4.0f;
+              while(++oi != oi_end)
+                {
+                  v = oi->second;
+                  c += (!std::binary_search(a.local.begin(), a.local.end(), v) ? 4.0f : std::numeric_limits<float>::infinity());
+                }
+            }
+        }
+    }
+
+  return(c);
+}
+
+// Check that the operand is either fully in registers or fully in memory.
+template <class G_t, class I_t>
+static bool operand_sane(const operand *o, const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  if(!o || !IS_SYMOP(o))
+    return(true);
+ 
+  operand_map_t::const_iterator oi, oi_end;
+  boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key);
+  
+  if(oi == oi_end)
+    return(true);
+  
+  // In registers.
+  if(std::binary_search(a.local.begin(), a.local.end(), oi->second))
+    {
+      while(++oi != oi_end)
+        if(!std::binary_search(a.local.begin(), a.local.end(), oi->second))
+          return(false);
+    }
+  else
+    {
+       while(++oi != oi_end)
+        if(std::binary_search(a.local.begin(), a.local.end(), oi->second))
+          return(false);
+    }
+ 
+  return(true);
+}
+
+template <class G_t, class I_t>
+static float default_instruction_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  float c = 0.0f;
+
+  const iCode *ic = G[i].ic;
+
+  c += default_operand_cost(IC_RESULT(ic), a, i, G, I);
+  c += default_operand_cost(IC_LEFT(ic), a, i, G, I);
+  c += default_operand_cost(IC_RIGHT(ic), a, i, G, I);
+
+  return(c);
+}
+
+template <class G_t, class I_t>
+static bool inst_sane(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  const iCode *ic = G[i].ic;
+
+  return(operand_sane(IC_RESULT(ic), a, i, G, I) && operand_sane(IC_LEFT(ic), a, i, G, I) && operand_sane(IC_RIGHT(ic), a, i, G, I));
+}
+
+// Treat assignment separately to handle coalescing.
+template <class G_t, class I_t> static float
+assign_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{float c=0.0f; return c;}
+
+template <class G_t, class I_t> static float
+return_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{float c=0.0f; return c;}
+
+template <class G_t, class I_t> static float
+call_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{float c=0.0f; return c;}
+
+template <class G_t, class I_t> static float
+ifx_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  const iCode *ic = G[i].ic;
+
+  return(default_operand_cost(IC_COND(ic), a, i, G, I));
+}
+
+template <class G_t, class I_t> static float
+jumptab_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  const iCode *ic = G[i].ic;
+
+  return(default_operand_cost(IC_JTCOND(ic), a, i, G, I));
+}
+
+template <class I_t>
+static void add_operand_conflicts_in_node(const cfg_node &n, I_t &I)
+{
+  const iCode *ic = n.ic;
+  
+  const operand *result = IC_RESULT(ic);
+  const operand *left = IC_LEFT(ic);
+  const operand *right = IC_RIGHT(ic);
+
+  if(!result || !IS_SYMOP(result))
+    return;
+    
+  if(!(ic->op == UNARYMINUS || ic->op == '+' || ic->op == '-' || ic->op == '^' || ic->op == '|' || ic->op == BITWISEAND)) 
+    return; // Code generation can always handle all other operations. Todo: Handle ^, |, BITWISEAND and float UNARYMINUS there as well.
+   
+  operand_map_t::const_iterator oir, oir_end, oirs; 
+  boost::tie(oir, oir_end) = n.operands.equal_range(OP_SYMBOL_CONST(result)->key);
+  if(oir == oir_end)
+    return;
+    
+  operand_map_t::const_iterator oio, oio_end;
+  
+  if(left && IS_SYMOP(left))
+    for(boost::tie(oio, oio_end) = n.operands.equal_range(OP_SYMBOL_CONST(left)->key); oio != oio_end; ++oio)
+      for(oirs = oir; oirs != oir_end; ++oirs)
+        {
+          var_t rvar = oirs->second;
+          var_t ovar = oio->second;
+          if(I[rvar].byte < I[ovar].byte)
+            boost::add_edge(rvar, ovar, I);
+        }
+        
+  if(right && IS_SYMOP(right))
+    for(boost::tie(oio, oio_end) = n.operands.equal_range(OP_SYMBOL_CONST(right)->key); oio != oio_end; ++oio)
+      for(oirs = oir; oirs != oir_end; ++oirs)
+        {
+          var_t rvar = oirs->second;
+          var_t ovar = oio->second;
+          if(I[rvar].byte < I[ovar].byte)
+            boost::add_edge(rvar, ovar, I);
+        }
+}
+
+// Return true, iff the operand is placed (partially) in r.
+template <class G_t>
+static bool operand_in_reg(const operand *o, reg_t r, const i_assignment_t &ia, unsigned short int i, const G_t &G)
+{
+  if(!o || !IS_SYMOP(o))
+    return(false);
+
+  if(r >= port->num_regs)
+    return(false);
+
+  operand_map_t::const_iterator oi, oi_end;
+  for(boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key); oi != oi_end; ++oi)
+    if(oi->second == ia.registers[r][1] || oi->second == ia.registers[r][0])
+      return(true);
+
+  return(false);
+}
+
+// Return true, iff the operand is placed in a reg.
+template <class G_t>
+static bool operand_in_reg(const operand *o, const i_assignment_t &ia, unsigned short int i, const G_t &G)
+{
+  if(!o || !IS_SYMOP(o))
+    return(false);
+
+  operand_map_t::const_iterator oi, oi_end;
+  for(boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key); oi != oi_end; ++oi)
+    for(reg_t r = 0; r < port->num_regs; r++)
+      if(oi->second == ia.registers[r][1] || oi->second == ia.registers[r][0])
+        return(true);
+
+  return(false);
+}
+
+// Return true, iff the operand is placed in a reg.
+template <class G_t>
+static bool operand_byte_in_reg(const operand *o, int offset, reg_t r, const assignment &a, unsigned short int i, const G_t &G)
+{
+  if(!o || !IS_SYMOP(o))
+    return(false);
+
+  operand_map_t::const_iterator oi, oi2, oi3, oi_end;
+
+  for(boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key); offset && oi != oi_end; offset--, oi++);
+
+  if(oi == oi_end)
+    return(false);
+
+  return(a.global[oi->second] == r);
+}
+
+// Return true, iff the operand is placed on the stack.
+template <class G_t>
+bool operand_on_stack(const operand *o, const assignment &a, unsigned short int i, const G_t &G)
+{
+  if(!o || !IS_SYMOP(o))
+    return(false);
+
+  if(OP_SYMBOL_CONST(o)->remat)
+    return(false);
+
+  if(OP_SYMBOL_CONST(o)->_isparm && !IS_REGPARM (OP_SYMBOL_CONST(o)->etype))
+    return(true);
+    
+  if(IS_TRUE_SYMOP(o) && OP_SYMBOL_CONST(o)->onStack)
+    return(true);
+    
+  if(OP_SYMBOL_CONST(o)->nRegs > 4) // currently all variables > 4 Byte are spilt in ralloc.c.
+    return(true);
+
+  operand_map_t::const_iterator oi, oi_end;
+  for(boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key); oi != oi_end; ++oi)
+    if(a.global[oi->second] < 0)
+      return(true);
+
+  return(false);
+}
+
+template <class G_t>
+static bool operand_is_pair(const operand *o, const assignment &a, unsigned short int i, const G_t &G)
+{
+  if(!o || !IS_SYMOP(o))
+    return(false);
+
+  operand_map_t::const_iterator oi, oi2, oi3, oi_end;
+  boost::tie(oi, oi_end) = G[i].operands.equal_range(OP_SYMBOL_CONST(o)->key);
+  if(oi == oi_end)
+    return(false);
+  oi2 = oi;
+  ++oi2;
+  if(oi2 == oi_end)
+    return(false);
+  oi3 = oi2;
+  ++oi3;
+  if(oi3 != oi_end)
+    return(false);
+
+  if(a.global[oi->second] + 1 != a.global[oi2->second])
+    return(false);
+
+  return(true);
+}
+
+template <class G_t, class I_t>
+static bool Ainst_ok(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  const iCode *ic = G[i].ic;
+
+  const i_assignment_t &ia = a.i_assignment;
+
+  operand *const left = IC_LEFT(ic);
+  operand *const right = IC_RIGHT(ic);
+  const operand *const result = IC_RESULT(ic);
+
+  if(ia.registers[REG_A][1] < 0)
+    return(true);   // Register A not in use.
+
+  // Some instructions don't touch registers.
+  if(SKIP_IC2(ic))
+    return(true);
+
+  bool exstk = (mc6809_should_omit_frame_ptr || (currFunc && currFunc->stack > 127));
+
+  //std::cout << "Ainst_ok at " << G[i].ic->key << ": A = (" << ia.registers[REG_A][0] << ", " << ia.registers[REG_A][1] << "), inst " << i << ", " << ic->key << "\n";
+
+  // Check if the result of this instruction is placed in A.
+  bool result_in_A = operand_in_reg(IC_RESULT(ic), REG_A, ia, i, G);
+  
+  // Check if an input of this instruction is placed in A.
+  bool input_in_A;
+  switch(ic->op)
+    {
+    case IFX:
+      input_in_A = operand_in_reg(IC_COND(ic), REG_A, ia, i, G);
+      break;
+    case JUMPTABLE:
+      input_in_A = operand_in_reg(IC_JTCOND(ic), REG_A, ia, i, G);
+      break;
+    default:
+      input_in_A = operand_in_reg(left, REG_A, ia, i, G) || operand_in_reg(right, REG_A, ia, i, G);
+      break;
+    }
+
+  // sfr access needs to go through a.
+  if(input_in_A &&
+    (IS_TRUE_SYMOP (left) && IN_REGSP (SPEC_OCLS (OP_SYMBOL (left)->etype)) ||
+    IS_TRUE_SYMOP (right) && IN_REGSP (SPEC_OCLS (OP_SYMBOL (right)->etype))))
+    return(false);
+
+  if (ic->op == '^' || ic->op == BITWISEAND || ic->op == '|' || ic->op == '~') // Codegen can handle it all.
+    return(true);
+
+  if (ic->op == RIGHT_OP && getSize(operandType(result)) == 1 && IS_OP_LITERAL(right))
+    return(true);
+
+  // Can use non-destructive cp on == and < (> might swap operands).
+  if((ic->op == EQ_OP || ic->op == '<' && SPEC_USIGN(getSpec(operandType(left))) && SPEC_USIGN(getSpec(operandType(right)))) &&
+    getSize(operandType(IC_LEFT(ic))) == 1 && ifxForOp (IC_RESULT(ic), ic) && operand_in_reg(left, REG_A, ia, i, G) &&
+    (IS_OP_LITERAL (right) || operand_in_reg(right, REG_B, ia, i, G) || operand_in_reg(right, REG_D, ia, i, G) ))
+    return(true);
+
+  const cfg_dying_t &dying = G[i].dying;
+  const bool dying_A = result_in_A || dying.find(ia.registers[REG_A][1]) != dying.end() || dying.find(ia.registers[REG_A][0]) != dying.end();
+
+  if((ic->op == '+' || ic->op == '-' && !operand_in_reg(right, REG_A, ia, i, G) || ic->op == UNARYMINUS) &&
+    getSize(operandType(IC_RESULT(ic))) == 1 && dying_A)
+    return(true);
+
+  if((ic->op == '+' || ic->op == '-' && !operand_in_reg(right, REG_A, ia, i, G) || ic->op == UNARYMINUS || ic->op == '~') && // First byte of input and last byte of output may be in A.
+    IS_ITEMP(result) && dying_A &&
+    (IS_ITEMP(left) || IS_OP_LITERAL(left) || operand_on_stack(left, a, i, G)) &&
+    (!right || IS_ITEMP(right) || IS_OP_LITERAL(right) || operand_on_stack(right, a, i, G)))
+    {
+      
+      if((operand_byte_in_reg(left, 0, REG_A, a, i, G) || !operand_in_reg(left, REG_A, ia, i, G)) &&
+        (operand_byte_in_reg(right, 0, REG_A, a, i, G) || !operand_in_reg(right, REG_A, ia, i, G)) &&
+        (operand_byte_in_reg(result, getSize(operandType(IC_RESULT(ic))) - 1, REG_A, a, i, G) || !result_in_A))
+        return(true);
+    }
+
+  // First two bytes of input may be in A.
+  if(ic->op == IFX && dying_A && (getSize(operandType(left)) >= 1 &&
+    operand_byte_in_reg(left, 0, REG_A, a, i, G) || getSize(operandType(left)) >= 2 && !IS_FLOAT (operandType(left)) && operand_byte_in_reg(left, 1, REG_A, a, i, G)))
+    return(true);
+
+  // Can test register via inc / dec.
+  if(ic->op == IFX && getSize(operandType(left)) == 1 &&
+    (operand_byte_in_reg(left, 0, REG_B, a, i, G) || operand_byte_in_reg(left, 0, REG_D, a, i, G) ))
+    return(true);
+
+  // Plain assignment between registers
+  if(ic->op == CAST && getSize(operandType(IC_RESULT(ic))) == 1 &&
+    (operand_in_reg(result, REG_B, ia, i, G) || operand_in_reg(result, REG_D, ia, i, G) || operand_in_reg(result, REG_A, ia, i, G)) &&
+    (operand_in_reg(result, REG_B, ia, i, G) || operand_in_reg(result, REG_D, ia, i, G) ))
+    return(true);
+
+  // Last byte of output may be in A.
+  if((ic->op == GET_VALUE_AT_ADDRESS || ic->op == CAST && !operand_in_reg(right, REG_A, ia, i, G)) && IS_ITEMP(result) && operand_byte_in_reg(result, getSize(operandType(IC_RESULT(ic))) - 1, REG_A, a, i, G))
+    return(true);
+
+  if (ic->op == LEFT_OP && getSize(operandType(IC_RESULT(ic))) == 2 && IS_OP_LITERAL(right) && byteOfVal (OP_VALUE (IC_RIGHT(ic)), 0) == 7)
+    {
+      if(!operand_in_reg(left, REG_A, ia, i, G) || dying_A)
+        return(true);
+    }
+
+  // Left shift of 1 byte can always handle a.
+  if (ic->op == LEFT_OP && getSize(operandType(IC_RESULT(ic))) == 1 && IS_OP_LITERAL(right))
+    return(true);
+
+  // inc / dec does not affect a.
+  if ((ic->op == '+' || ic->op == '-') && IS_OP_LITERAL(right) && ulFromVal (OP_VALUE (IC_RIGHT(ic))) <= 2 &&
+    (getSize(operandType(IC_RESULT(ic))) == 2 && operand_is_pair(IC_RESULT(ic), a, i, G) || getSize(operandType(IC_RESULT(ic))) == 1 && operand_in_reg(result, ia, i, G) && operand_in_reg(result, ia, i, G)))
+    return(true);
+
+  // Code generator mostly cannot handle variables that are only partially in A.
+  if(operand_in_reg(left, REG_A, ia, i, G) && getSize(operandType(left)) != 1 ||
+    operand_in_reg(right, REG_A, ia, i, G) && getSize(operandType(right)) != 1 ||
+    operand_in_reg(result, REG_A, ia, i, G) && getSize(operandType(result)) != 1)
+    return(false);
+
+  if(ic->op == '!' && getSize(operandType(left)) <= 2 && dying_A)
+    return(true);
+
+  if(ic->op == '=' && POINTER_SET (ic))
+    return(dying_A || !(IS_BITVAR(getSpec(operandType (result))) || IS_BITVAR(getSpec(operandType (right)))));
+
+  if(1)
+    {
+      // Variable in A is not used by this instruction
+      if(ic->op == '+' && IS_ITEMP (left) && IS_ITEMP (IC_RESULT(ic)) && IS_OP_LITERAL (right) &&
+          ulFromVal (OP_VALUE (IC_RIGHT(ic))) == 1 &&
+          OP_KEY (IC_RESULT(ic)) == OP_KEY (IC_LEFT(ic)))
+        return(true);
+
+      if((ic->op == '=' || ic->op == CAST) && !POINTER_SET (ic) && isOperandEqual (result, right))
+        return(true);
+
+      if(ic->op == GOTO || ic->op == LABEL)
+        return(true);
+
+      if(ic->op == IPUSH) // Can handle anything.
+        return(true);
+
+      if(!result_in_A && !input_in_A)
+        return(false);
+    }
+
+  // Last use of operand in A.
+  if(input_in_A && dying_A)
+    {
+      if(ic->op != IFX &&
+        ic->op != RETURN &&
+        !((ic->op == RIGHT_OP || ic->op == LEFT_OP) &&
+          (IS_OP_LITERAL(right) || operand_in_reg(right, REG_A, ia, i, G) || getSize(operandType(IC_RESULT(ic))) == 1 && ia.registers[REG_B][1] < 0)) &&
+        !((ic->op == '=' || ic->op == CAST) && !(IY_RESERVED && POINTER_SET(ic))) &&
+        !IS_BITWISE_OP (ic) &&
+        !(ic->op == '~') &&
+        !(ic->op == '*' && (IS_ITEMP(IC_LEFT(ic)) || IS_OP_LITERAL(IC_LEFT(ic))) && (IS_ITEMP(IC_RIGHT(ic)) || IS_OP_LITERAL(IC_RIGHT(ic)))) &&
+        !((ic->op == '-' || ic->op == '+' || ic->op == EQ_OP) && IS_OP_LITERAL(IC_RIGHT(ic))))
+        {
+          //std::cout << "Last use: Dropping at " << i << ", " << ic->key << "(" << int(ic->op) << ")\n";
+          return(false);
+        }
+    }
+  // A is used, and has to be preserved for later use.
+  else if(input_in_A &&
+         ic->op != IFX &&
+         ic->op != JUMPTABLE)
+    {
+      //std::cout << "Intermediate use: Dropping at " << i << ", " << ic->key << "(" << int(ic->op) << "\n";
+      return(false);
+    }
+
+  // First use of operand in A.
+  if(result_in_A &&
+      !POINTER_GET(ic) &&
+      ic->op != '+' &&
+      ic->op != '-' &&
+      (ic->op != '*' || !IS_OP_LITERAL(IC_LEFT(ic)) && !IS_OP_LITERAL(right)) &&
+      !IS_BITWISE_OP(ic) &&
+      ic->op != GET_VALUE_AT_ADDRESS &&
+      ic->op != '=' &&
+      ic->op != EQ_OP &&
+      ic->op != '<' &&
+      ic->op != '>' &&
+      ic->op != CAST &&
+      ic->op != CALL &&
+      ic->op != PCALL &&
+      ic->op != GETHBIT &&
+      !((ic->op == LEFT_OP || ic->op == RIGHT_OP) && IS_OP_LITERAL(right)))
+    {
+      //std::cout << "First use: Dropping at " << i << ", " << ic->key << "(" << int(ic->op) << "\n";
+      return(false);
+    }
+
+  //std::cout << "Default OK\n";
+
+  return(true);
+}
+
+template <class G_t, class I_t>
+static bool IYinst_ok(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  const iCode *ic = G[i].ic;
+
+  const i_assignment_t &ia = a.i_assignment;
+
+  /*if(ic->key == 40)
+    std::cout << "1IYinst_ok: at (" << i << ", " << ic->key << ")\nIYL = (" << ia.registers[REG_IYL][0] << ", " << ia.registers[REG_IYL][1] << "), IYH = (" << ia.registers[REG_IYH][0] << ", " << ia.registers[REG_IYH][1] << ")inst " << i << ", " << ic->key << "\n";*/
+
+  bool exstk = (mc6809_should_omit_frame_ptr || (currFunc && currFunc->stack > 127));
+
+  const operand *left = IC_LEFT(ic);
+  const operand *right = IC_RIGHT(ic);
+  const operand *result = IC_RESULT(ic);
+
+  bool result_in_IY, unused_IY, input_in_IY;
+
+  switch(ic->op)
+    {
+    case IFX:
+      break;
+    case JUMPTABLE:
+      break;
+    default:
+      break;
+    }
+
+  //const std::set<var_t> &dying = G[i].dying;
+  
+  //bool dying_IYL = result_in_IYL || dying.find(ia.registers[REG_IYL][1]) != dying.end() || dying.find(ia.registers[REG_IYL][0]) != dying.end();
+  //bool dying_IYH = result_in_IYH || dying.find(ia.registers[REG_IYH][1]) != dying.end() || dying.find(ia.registers[REG_IYH][0]) != dying.end();
+
+  //bool result_only_IY = (result_in_IYL || unused_IYL || dying_IYL) && (result_in_IYH || unused_IYH || dying_IYH);
+
+  if(unused_IY)
+    return(true); // Register IY not in use.
+
+  if(SKIP_IC2(ic))
+    return(true);
+
+  if(exstk && (operand_on_stack(result, a, i, G) || operand_on_stack(left, a, i, G) || operand_on_stack(right, a, i, G))) // Todo: Make this more accurate to get better code when using --fomit-frame-pointer
+    return(false);
+
+  if(ic->op == CALL)
+    return(true);
+
+  if(!result_in_IY && !input_in_IY &&
+    !(IC_RESULT(ic) && isOperandInDirSpace(IC_RESULT(ic))) &&
+    !(IC_RIGHT(ic) && IS_TRUE_SYMOP(IC_RIGHT(ic))) &&
+    !(IC_LEFT(ic) && IS_TRUE_SYMOP(IC_LEFT(ic))))
+    return(true);
+
+  if(result_in_IY &&
+    (ic->op == '=' && !(POINTER_SET(ic) && isOperandInDirSpace(IC_RIGHT(ic))) ||
+    ic->op == CAST && getSize(operandType(IC_RESULT(ic))) <= getSize(operandType(IC_RIGHT(ic))) || 
+    ic->op == '+')) // todo: More instructions that can write iy.
+    return(true);
+
+  // Todo: Multiplication.
+
+  if(ic->op == LEFT_OP && result_in_IY && input_in_IY && IS_VALOP (IC_RIGHT (ic)) && operandLitValue (IC_RIGHT (ic)) < 8)
+    return(true);
+
+  if(ic->op == '-' && result_in_IY && input_in_IY && IS_VALOP (IC_RIGHT (ic)) && operandLitValue (IC_RIGHT (ic)) < 4)
+    return(true);
+
+  if(!result_in_IY && !input_in_IY &&
+    (ic->op == '=' || ic->op == CAST && getSize(operandType(IC_RIGHT (ic))) >= 2 && (getSize(operandType(IC_RESULT (ic))) <= getSize(operandType(IC_RIGHT (ic))) || !IS_SPEC(operandType(IC_RIGHT (ic))) || SPEC_USIGN(operandType(IC_RIGHT(ic))))) &&
+    operand_is_pair(IC_RESULT(ic), a, i, G)) // DirSpace access won't use iy here.
+    return(true);
+
+  if(ic->op == IPUSH) // todo: More instructions that can use IY.
+    return(true);
+
+  if(ic->op == GET_VALUE_AT_ADDRESS && isOperandInDirSpace(IC_RESULT(ic)))
+    return(false);
+
+  if(input_in_IY && !result_in_IY &&
+    (ic->op == '=' && !POINTER_SET(ic) ||
+     ic->op == CAST && getSize(operandType(IC_RESULT(ic))) <= getSize(operandType(IC_RIGHT(ic))) ||
+     ic->op == GET_VALUE_AT_ADDRESS))
+    return(true);
+
+  return(false);
+}
+
+template <class G_t, class I_t>
+static void set_surviving_regs(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{
+  iCode *ic = G[i].ic;
+  
+  bitVectClear(ic->rMask);
+  bitVectClear(ic->rSurv);
+  
+  cfg_alive_t::const_iterator v, v_end;
+  for (v = G[i].alive.begin(), v_end = G[i].alive.end(); v != v_end; ++v)
+    {
+      if(a.global[*v] < 0)
+        continue;
+      ic->rMask = bitVectSetBit(ic->rMask, a.global[*v]);
+
+      if(G[i].dying.find(*v) == G[i].dying.end())
+        if(!((IC_RESULT(ic) && !POINTER_SET(ic)) && IS_SYMOP(IC_RESULT(ic)) && OP_SYMBOL_CONST(IC_RESULT(ic))->key == I[*v].v))
+          ic->rSurv = bitVectSetBit(ic->rSurv, a.global[*v]);
+    }
+}
+
+template <class G_t, class I_t>
+static void assign_operand_for_cost(operand *o, const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{return;}
+
+template <class G_t, class I_t>
+static void assign_operands_for_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{return;}
+
+// Cost function.
+template <class G_t, class I_t>
+static float instruction_cost(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{float c=0.0f; return c;} 
+
+template <class I_t>
+float weird_byte_order(const assignment &a, const I_t &I)
+{float c=0.0f; return c;} 
+
+// Check for gaps, i.e. higher bytes of a variable being assigned to regs, while lower byte are not.
+template <class I_t>
+bool local_assignment_insane(const assignment &a, const I_t &I, var_t lastvar)
+{
+  varset_t::const_iterator v, v_end, v_old;
+  
+  for(v = a.local.begin(), v_end = a.local.end(); v != v_end;)
+    {
+      v_old = v;
+      ++v;
+      if(v == v_end)
+        {
+          if(*v_old != lastvar && I[*v_old].byte != I[*v_old].size - 1)
+            return(true);
+          break;
+        }
+      if(I[*v_old].v == I[*v].v)
+        {
+          if(I[*v_old].byte != I[*v].byte - 1)
+            return(true);
+        }
+      else
+        {
+          if(*v_old != lastvar && I[*v_old].byte != I[*v_old].size - 1 || I[*v].byte)
+            return(true);
+        }
+    }
+
+  return(false);
+}
+
+// For early removal of assignments that cannot be extended to valid assignments.
+template <class G_t, class I_t>
+static bool assignment_hopeless(const assignment &a, unsigned short int i, const G_t &G, const I_t &I, const var_t lastvar)
+{
+  if(local_assignment_insane(a, I, lastvar))
+    return(true);
+
+  const i_assignment_t &ia = a.i_assignment;
+
+  // Can only check for IYinst_ok() in some cases.
+  if(OPTRALLOC_IY &&
+      !IYinst_ok(a, i, G, I))
+    return(true);
+
+  return(false);
+}
+
+// Increase chance of finding good compatible assignments at join nodes.
+template <class T_t>
+static void get_best_local_assignment_biased(assignment &a, typename boost::graph_traits<T_t>::vertex_descriptor t, const T_t &T)
+{
+  const assignment_list_t &alist = T[t].assignments;
+
+  assignment_list_t::const_iterator ai, ai_end, ai_best;
+  for(ai = ai_best = alist.begin(), ai_end = alist.end(); ai != ai_end; ++ai)
+    {
+      if(ai->s < ai_best->s)
+        {
+          varset_t::const_iterator vi, vi_end;
+          for(vi = ai->local.begin(), vi_end = ai->local.end(); vi != vi_end; ++vi)
+            if(ai->global[*vi] == REG_A || OPTRALLOC_IY )
+              goto too_risky;
+          ai_best = ai;
+        }
+too_risky:
+      ;
+    }
+
+  a = *ai_best;
+  
+  std::set<var_t>::const_iterator vi, vi_end;
+  varset_t newlocal;
+  std::set_union(T[t].alive.begin(), T[t].alive.end(), a.local.begin(), a.local.end(), std::inserter(newlocal, newlocal.end()));
+  a.local = newlocal;
+}
+
+template <class G_t, class I_t>
+static float rough_cost_estimate(const assignment &a, unsigned short int i, const G_t &G, const I_t &I)
+{float c=0.0f; return c;}
+
+// Code for another ic is generated when generating this one. Mark the other as generated.
+static void extra_ic_generated(iCode *ic)
+{
+  if(ic->op == '>' || ic->op == '<' || ic->op == LE_OP || ic->op == GE_OP || ic->op == EQ_OP || ic->op == NE_OP ||
+    (ic->op == '^' || ic->op == '|' || ic->op == BITWISEAND) && (IS_OP_LITERAL (IC_LEFT (ic)) || IS_OP_LITERAL (IC_RIGHT (ic))))
+    {
+      iCode *ifx;
+      if (ifx = ifxForOp (IC_RESULT (ic), ic))
+        {
+          OP_SYMBOL (IC_RESULT (ic))->for_newralloc = false;
+          OP_SYMBOL (IC_RESULT (ic))->regType = REG_CND;
+          ifx->generated = true;
+        }
+    }
+}
+
+template <class T_t, class G_t, class I_t, class SI_t>
+static bool tree_dec_ralloc(T_t &T, G_t &G, const I_t &I, SI_t &SI)
+{
+  bool assignment_optimal;
+
+  con2_t I2(boost::num_vertices(I));
+  for(unsigned int i = 0; i < boost::num_vertices(I); i++)
+    {
+      I2[i].v = I[i].v;
+      I2[i].byte = I[i].byte;
+      I2[i].size = I[i].size;
+      I2[i].name = I[i].name;
+    }
+  typename boost::graph_traits<I_t>::edge_iterator e, e_end;
+  for(boost::tie(e, e_end) = boost::edges(I); e != e_end; ++e)
+    add_edge(boost::source(*e, I), boost::target(*e, I), I2);
+
+  assignment ac;
+  assignment_optimal = true;
+  tree_dec_ralloc_nodes(T, find_root(T), G, I2, ac, &assignment_optimal);
+
+  const assignment &winner = *(T[find_root(T)].assignments.begin());
+
+#ifdef DEBUG_RALLOC_DEC
+  std::cout << "Winner: ";
+  for(unsigned int i = 0; i < boost::num_vertices(I); i++)
+    {
+      std::cout << "(" << i << ", " << int(winner.global[i]) << ") ";
+    }
+  std::cout << "\n";
+  std::cout << "Cost: " << winner.s << "\n";
+  std::cout.flush();
+#endif
+
+  // Todo: Make this an assertion
+  if(winner.global.size() != boost::num_vertices(I))
+    {
+      std::cerr << "ERROR: No Assignments at root\n";
+      exit(-1);
+    }
+
+  for(unsigned int v = 0; v < boost::num_vertices(I); v++)
+    {
+      symbol *sym = (symbol *)(hTabItemWithKey(liveRanges, I[v].v));
+      if(winner.global[v] >= 0)
+        {
+         
+          sym->regs[I[v].byte] = regsMC6809 + winner.global[v];
+          sym->accuse = 0;
+          sym->isspilt = false;
+          sym->nRegs = I[v].size;
+        }
+      else
+        {
+          for(int i = 0; i < I[v].size; i++)
+            sym->regs[i] = 0;
+          sym->accuse = 0;
+          sym->nRegs = I[v].size;
+          mc6809SpillThis(sym);
+        }
+    }
+
+  for(unsigned int i = 0; i < boost::num_vertices(G); i++)
+    set_surviving_regs(winner, i, G, I);
+
+  set_spilt(G, I, SI);
+
+  return(!assignment_optimal);
+}
+
+// Omit the frame pointer for functions with low register pressure and few parameter accesses.
+template <class G_t>
+static bool omit_frame_ptr(const G_t &G)
+{
+  if(IY_RESERVED || mc6809_opts.noOmitFramePtr)
+    return(false);
+
+  if(options.omitFramePtr)
+    return(true);
+    
+  signed char omitcost = -16;
+  for(unsigned int i = 0; i < boost::num_vertices(G); i++)
+    {
+      if((int)G[i].alive.size() > port->num_regs - 4)
+        return(false);
+
+      const iCode *const ic = G[i].ic;
+      const operand *o;
+      o = IC_RESULT(ic);
+      if(o && IS_SYMOP(o) && OP_SYMBOL_CONST(o)->_isparm && !IS_REGPARM (OP_SYMBOL_CONST(o)->etype))
+        omitcost += 6;
+      o = IC_LEFT(ic);
+      if(o && IS_SYMOP(o) && OP_SYMBOL_CONST(o)->_isparm && !IS_REGPARM (OP_SYMBOL_CONST(o)->etype))
+        omitcost += 6;
+      o = IC_RIGHT(ic);
+      if(o && IS_SYMOP(o) && OP_SYMBOL_CONST(o)->_isparm && !IS_REGPARM (OP_SYMBOL_CONST(o)->etype))
+        omitcost += 6;
+
+      if(omitcost > 14) // Chosen greater than zero, since the peephole optimizer often can optimize the use of iy into use of hl, reducing the cost.
+        return(false);
+    }
+
+  return(true);
+}
+
+// Adjust stack location when deciding to omit frame pointer.
+void mc6809_move_parms(void)
+{
+  for(value *val = FUNC_ARGS (currFunc->type); val; val = val->next)
+    {
+      if(IS_REGPARM(val->sym->etype) || !val->sym->onStack)
+        continue;
+
+      val->sym->stack -= 2;
+    }
+}
+
+iCode *mc6809_ralloc2_cc(ebbIndex *ebbi)
+{
+  eBBlock **const ebbs = ebbi->bbOrder;
+  const int count = ebbi->count;
+
+#ifdef DEBUG_RALLOC_DEC
+  std::cout << "Processing " << currFunc->name << " from " << dstFileName << "\n"; std::cout.flush();
+#endif
+
+  cfg_t control_flow_graph;
+
+  con_t conflict_graph;
+
+  iCode *ic = create_cfg(control_flow_graph, conflict_graph, ebbi);
+
+  mc6809_should_omit_frame_ptr = omit_frame_ptr(control_flow_graph);
+  mc6809_move_parms();
+
+  if(options.dump_graphs)
+    dump_cfg(control_flow_graph);
+
+  if(options.dump_graphs)
+    dump_con(conflict_graph);
+
+  tree_dec_t tree_decomposition;
+
+  get_nice_tree_decomposition(tree_decomposition, control_flow_graph);
+
+  alive_tree_dec(tree_decomposition, control_flow_graph);
+
+  good_re_root(tree_decomposition);
+  nicify(tree_decomposition);
+  alive_tree_dec(tree_decomposition, control_flow_graph);
+
+  if(options.dump_graphs)
+    dump_tree_decomposition(tree_decomposition);
+
+  guessCounts (ic, ebbi);
+
+  scon_t stack_conflict_graph;
+
+  mc6809_assignment_optimal = !tree_dec_ralloc(tree_decomposition, control_flow_graph, conflict_graph, stack_conflict_graph);
+
+  MC6809RegFix (ebbs, count);
+
+  chaitin_salloc(stack_conflict_graph); // new Chaitin-style stack allocator
+
+  if(options.dump_graphs)
+    dump_scon(stack_conflict_graph);
+
+  return(ic);
+}
+
diff --git a/sdcc/src/mc6809/reg_index.h b/sdcc/src/mc6809/reg_index.h
new file mode 100644
index 000000000..c63b9f9bf
--- /dev/null
+++ b/sdcc/src/mc6809/reg_index.h
@@ -0,0 +1,57 @@
+/*-------------------------------------------------------------------------
+
+  mc6809/reg_index.h - header file register index
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+   
+   In other words, you are welcome to use, share and improve this program.
+   You are forbidden to forbid anyone else to use, share and improve
+   what you give them.   Help stamp out software-hoarding!  
+-------------------------------------------------------------------------*/
+#ifndef MC6809_REG_INDEX_H
+#define MC6809_REG_INDEX_H 1
+
+enum
+{
+  MIN_IDX=0,
+  A_IDX = MIN_IDX,    /* Accumulator A */
+  B_IDX,              /* Accumulator B */
+
+  XL_IDX,             /* Lower byte of X */
+  XH_IDX,             /* Upper byte of X */
+  YL_IDX,             /* Lower byte of Y */
+  YH_IDX,             /* Upper byte of Y */
+  UL_IDX,             /* Lower byte of U */
+  UH_IDX,             /* Upper byte of U */
+
+  CND_IDX,            /* Condition Register */
+
+  DP_IDX,             /* Direct page */
+
+  MAX_ASMOP_IDX=DP_IDX,
+
+  S_IDX,              /* Stack Pointer */
+
+  PC_IDX,             /* Program Counter */
+
+  X_IDX,              /* Index X */
+  Y_IDX,              /* Index Y */
+  U_IDX,              /* User Stack Pointer */
+  D_IDX,              /* Registers A and B combined */
+
+  MAX_IDX=D_IDX
+};
+
+#endif
diff --git a/sdcc/src/mc6809/support.c b/sdcc/src/mc6809/support.c
new file mode 100644
index 000000000..18d44a995
--- /dev/null
+++ b/sdcc/src/mc6809/support.c
@@ -0,0 +1,37 @@
+/** @file mc6809/support.c
+ */
+#include "m6809.h"
+#include <math.h>
+
+int
+convertFloat (MC6809_FLOAT * f, double native)
+{
+  unsigned long mantissa, exponent;
+  double f2;
+  wassert (f);
+  if (native != 0)
+    {
+      f2 = floor (log (fabs (native)) / log (2)) + 1;
+      mantissa = (unsigned long) (0x1000000 * fabs (native) / exp (f2 * log (2))) ;
+      mantissa &= 0xffffff;
+      exponent = (unsigned long) (f2 + 0x40) ;
+      if (native < 0)
+	exponent |= 0x80;
+    }
+  else
+    {
+      mantissa = 0;
+      exponent = 0;
+    }
+
+  f->w[0] = (WORD) mantissa;
+  f->w[1] = (BYTE) (mantissa >> 16);
+  f->w[1] |= exponent << 8;
+
+  f->b[0] = (BYTE) f->w[0];
+  f->b[1] = (BYTE) (f->w[0] >> 8);
+  f->b[2] = (BYTE) f->w[1];
+  f->b[3] = (BYTE) (f->w[1] >> 8);
+
+  return 0;
+}
diff --git a/sdcc/src/mc6809/support.h b/sdcc/src/mc6809/support.h
new file mode 100644
index 000000000..db588f329
--- /dev/null
+++ b/sdcc/src/mc6809/support.h
@@ -0,0 +1,20 @@
+/** @file mc6809/support.h
+    Support functions for the mc6809 port.
+*/
+#ifndef MC6809_SUPPORT_INCLUDE
+#define MC6809_SUPPORT_INCLUDE
+
+typedef unsigned short WORD;
+typedef unsigned char BYTE;
+
+typedef struct
+  {
+    WORD w[2];
+    BYTE b[4];
+  }
+MC6809_FLOAT;
+
+/** Convert a native float into 'mc6809' format */
+int convertFloat (MC6809_FLOAT * f, double native);
+
+#endif
-- 
