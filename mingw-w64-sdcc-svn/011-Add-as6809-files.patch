From 00287c58b36297e42da437c5936319d4f130dfda Mon Sep 17 00:00:00 2001
From: Tim Stahlhut <stahta01@gmail.com>
Date: Wed, 26 Aug 2020 12:52:35 -0400
Subject: Add m6809 sdas files

Add files from asxxxx version 5.00
---
 sdcc/sdas/as6809/Makefile.in | 137 ++++++++
 sdcc/sdas/as6809/clean.mk    |  25 ++
 sdcc/sdas/as6809/m09adr.c    | 278 +++++++++++++++
 sdcc/sdas/as6809/m09mch.c    | 646 +++++++++++++++++++++++++++++++++++
 sdcc/sdas/as6809/m09pst.c    | 500 +++++++++++++++++++++++++++
 sdcc/sdas/as6809/m6809.h     | 174 ++++++++++
 6 files changed, 1760 insertions(+)
 create mode 100644 sdcc/sdas/as6809/Makefile.in
 create mode 100644 sdcc/sdas/as6809/clean.mk
 create mode 100644 sdcc/sdas/as6809/m09adr.c
 create mode 100644 sdcc/sdas/as6809/m09mch.c
 create mode 100644 sdcc/sdas/as6809/m09pst.c
 create mode 100644 sdcc/sdas/as6809/m6809.h

diff --git a/sdcc/sdas/as6809/Makefile.in b/sdcc/sdas/as6809/Makefile.in
new file mode 100644
index 000000000..60d8918e4
--- /dev/null
+++ b/sdcc/sdas/as6809/Makefile.in
@@ -0,0 +1,137 @@
+#
+#
+#
+
+VERSION         = @VERSION@
+VERSIONHI       = @VERSIONHI@
+VERSIONLO       = @VERSIONLO@
+VERSIONP        = @VERSIONP@
+
+SHELL           = /bin/sh
+CC              = @CC@
+CPP             = @CPP@
+INSTALL         = @INSTALL@
+STRIP           = @STRIP@
+MAKEDEP         = @MAKEDEP@
+
+top_builddir    = @top_builddir@
+top_srcdir      = @top_srcdir@
+
+srcdir          = @srcdir@
+prefix          = @prefix@
+exec_prefix     = @exec_prefix@
+bindir          = @bindir@
+libdir          = @libdir@
+datadir         = @datadir@
+datarootdir     = @datarootdir@
+includedir      = @includedir@
+mandir          = @mandir@
+man1dir         = $(mandir)/man1
+man2dir         = $(mandir)/man2
+infodir         = @info@
+
+EXEEXT          = @EXEEXT@
+
+VPATH           = @srcdir@
+
+CPPFLAGS        = @CPPFLAGS@ -DSDCDB -DNOICE -DINDEXLIB -I. -I$(srcdir) -I$(srcdir)/../asxxsrc -I$(srcdir)/../../support/util
+CFLAGS          = @CFLAGS@ @WALL_FLAG@ $(CPPFLAGS)
+LDFLAGS         = @LDFLAGS@
+LIBS            = -lm
+
+OBJDIR = obj
+
+UTILLIB = $(srcdir)/../../support/util
+UTILSRC = dbuf.c dbuf_string.c
+UTILLIBOBJS = $(UTILSRC:%.c=$(OBJDIR)/%.o)
+
+ASXXLIB = $(srcdir)/../asxxsrc
+ASXXLIBSRC = asdbg.c asdata.c asexpr.c aslex.c aslist.c asmain.c asout.c assubr.c assym.c asmcro.c sdas.c strcmpi.c
+ASXXLIBOBJS = $(ASXXLIBSRC:%.c=$(OBJDIR)/%.o)
+
+SRC = m09pst.c m09mch.c m09adr.c
+OBJS = $(SRC:%.c=$(OBJDIR)/%.o)
+
+ASSOURCES = $(SRC) $(ASXXLIBSRC:%.c=$(ASXXLIB)/%.c) $(UTILSRC:%.c=$(UTILLIB)/%.c)
+
+ASOBJECTS = $(OBJS) $(ASXXLIBOBJS) $(UTILLIBOBJS)
+
+ASX = $(top_builddir)/bin/sdas6809$(EXEEXT)
+#DEST = $(DESTDIR)$(bindir)/sdas6809$(EXEEXT)
+DEST = sdas6809
+DESTPATH = $(DESTDIR)$(bindir)/
+
+transform       = @program_transform_name@
+
+# Compiling entire program or any subproject
+# ------------------------------------------
+all: checkconf $(ASX)
+
+$(ASX): $(ASOBJECTS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(ASOBJECTS) $(LIBS)
+
+# Compiling and installing everything and running test
+# ----------------------------------------------------
+install: all installdirs
+	$(INSTALL) $(ASX) $(DESTPATH)`echo $(DEST)|sed '$(transform)'`$(EXEEXT)
+	$(STRIP) $(DESTPATH)`echo $(DEST)|sed '$(transform)'`$(EXEEXT)
+
+# Deleting all the installed files
+# --------------------------------
+uninstall:
+	rm -f $(DESTPATH)`echo $(DEST)|sed '$(transform)'`$(EXEEXT)
+
+
+# Performing self-test
+# --------------------
+check:
+
+
+# Performing installation test
+# ----------------------------
+installcheck:
+
+
+# Creating installation directories
+# ---------------------------------
+installdirs:
+	$(INSTALL) -d $(DESTDIR)$(bindir)
+
+
+# Creating dependencies
+# ---------------------
+dep: Makefile.dep
+
+Makefile.dep: $(ASSOURCES) $(srcdir)/*.h
+	$(MAKEDEP) $(CPPFLAGS) $(filter %.c,$^) >Makefile.dep
+
+ifeq "$(findstring $(MAKECMDGOALS),uninstall check installcheck installdirs \
+                                   clean distclean mostlyclean realclean)" ""
+  -include Makefile.dep
+endif
+include $(srcdir)/clean.mk
+
+# My rules
+# --------
+$(OBJDIR)/.stamp:
+	mkdir -p $(OBJDIR)
+	touch $(OBJDIR)/.stamp
+
+$(OBJDIR)/%.o: %.c $(OBJDIR)/.stamp
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+$(OBJDIR)/%.o: $(ASXXLIB)/%.c $(OBJDIR)/.stamp
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+$(OBJDIR)/%.o: $(UTILLIB)/%.c $(OBJDIR)/.stamp
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+
+# Remaking configuration
+# ----------------------
+checkconf:
+	@if [ -f $(top_builddir)/devel ]; then\
+          $(MAKE) -f ../conf.mk srcdir="$(srcdir)" top_builddir="$(top_builddir)" freshconf;\
+        fi
+
+# End of Makefile
diff --git a/sdcc/sdas/as6809/clean.mk b/sdcc/sdas/as6809/clean.mk
new file mode 100644
index 000000000..2262b8fc6
--- /dev/null
+++ b/sdcc/sdas/as6809/clean.mk
@@ -0,0 +1,25 @@
+# Deleting all files created by building the program
+# --------------------------------------------------
+include $(top_builddir)/Makefile.common
+
+clean: mostlyclean
+	rm -f *.dep
+	rm -f $(ASOBJECTS) $(OBJDIR)/.stamp
+	if [ -d $(OBJDIR) ]; then rmdir $(OBJDIR); fi
+
+# Deleting all files created by configuring or building the program
+# -----------------------------------------------------------------
+distclean: clean
+	rm -f Makefile
+
+# Like clean but some files may still exist
+# -----------------------------------------
+mostlyclean:
+	rm -f *core *[%~] *.[oa]
+	rm -f .[a-z]*~
+	rm -f $(top_builddir)/bin/sdas6809$(EXEEXT)
+
+# Deleting everything that can reconstructed by this Makefile. It deletes
+# everything deleted by distclean plus files created by bison, etc.
+# -----------------------------------------------------------------------
+realclean: distclean
diff --git a/sdcc/sdas/as6809/m09adr.c b/sdcc/sdas/as6809/m09adr.c
new file mode 100644
index 000000000..7333ada0b
--- /dev/null
+++ b/sdcc/sdas/as6809/m09adr.c
@@ -0,0 +1,278 @@
+/* M09ADR.C */
+
+/*
+ *  Copyright (C) 1989-2009  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "asxxxx.h"
+#include "m6809.h"
+
+int aindx;
+
+int
+addr(esp)
+struct expr *esp;
+{
+	int c;
+
+	aindx = 0;
+	if ((c = getnb()) == '#') {
+		expr(esp, 0);
+		esp->e_mode = S_IMMED;
+	} else
+	if (c == '[') {
+		aindx = 0x90;
+		addr1(esp);
+		if (getnb() != ']') {
+			aerr();
+		}
+	} else {
+		unget(c);
+		addr1(esp);
+	}
+	return (esp->e_mode);
+}
+
+int
+addr1(esp)
+struct expr *esp;
+{
+	int c;
+
+	if (admode(abd)) {
+		comma(1);
+		if (!admode(xyus))
+			aerr();
+		esp->e_mode = S_IND;
+	} else
+	if ((c = getnb()) == ',') {
+		if (admode(xyus)) {
+			aindx |= 0x04;
+		} else
+		if (admode(auto2)) {
+			;
+		} else
+		if (!(aindx & 0x10) && admode(auto1)) {
+			;
+		} else {
+			aerr();
+		}
+		esp->e_mode = S_IND;
+	} else
+	if (c == '*') {
+		expr(esp, 0);
+		esp->e_mode = S_DIR;
+		if (comma(0)) {
+			if (admode(xyus)) {
+				esp->e_mode = S_OFST;
+			} else
+			if (admode(pcr)) {
+				esp->e_mode = S_PCR;
+			} else
+			if (admode(pc)) {
+				esp->e_mode = S_PC;
+			} else {
+				aerr();
+			}
+		}
+	} else {
+		unget(c);
+		expr(esp, 0);
+		if (comma(0)) {
+			if (admode(xyus)) {
+				esp->e_mode = S_OFST;
+			} else
+			if (admode(pcr)) {
+				esp->e_mode = S_PCR;
+			} else
+			if (admode(pc)) {
+				esp->e_mode = S_PC;
+			} else {
+				aerr();
+			}
+		} else {
+			esp->e_mode = S_EXT;
+		}
+	}
+	return (esp->e_mode);
+}
+
+	
+/*
+ * Enter admode() to search a specific addressing mode table
+ * for a match. Return the addressing value on a match or
+ * zero for no match.
+ */
+int
+admode(sp)
+struct adsym *sp;
+{
+	char *ptr;
+	int i, v;
+	char *ips;
+
+	ips = ip;
+	unget(getnb());
+
+	i = 0;
+	while ( *(ptr = &sp[i].a_str[0]) ) {
+		if (srch(ptr)) {
+			v = sp[i].a_val;
+			aindx |= (v | 0x80);
+			return(v);
+		}
+		i++;
+	}
+	ip = ips;
+	return(0);
+}
+
+/*
+ *      srch --- does string match ?
+ */
+int
+srch(str)
+char *str;
+{
+	char *ptr;
+	ptr = ip;
+
+	while (*ptr && *str) {
+		if (ccase[*ptr & 0x007F] != ccase[*str & 0x007F])
+			break;
+		ptr++;
+		str++;
+	}
+	if (ccase[*ptr & 0x007F] == ccase[*str & 0x007F]) {
+		ip = ptr;
+		return(1);
+	}
+
+	if (!*str)
+		if (any(*ptr," \t\n,];")) {
+			ip = ptr;
+			return(1);
+		}
+	return(0);
+}
+
+/*
+ *      any --- does str contain c?
+ */
+int
+any(c,str)
+int c;
+char *str;
+{
+	while (*str)
+		if(*str++ == c)
+			return(1);
+	return(0);
+}
+
+struct adsym	abd[] = {	/* a, b, or d indexed offset */
+    {	"a",	0x06	},
+    {	"b",	0x05	},
+    {	"d",	0x0B	},
+    {	"",	0x00	}
+};
+
+struct adsym	xyus[] = {	/* x, y, u, or s index register */
+    {	"x",	0x100	},
+    {	"y",	0x120	},
+    {	"u",	0x140	},
+    {	"s",	0x160	},
+    {	"",	0x000	}
+};
+
+struct adsym	auto1[] = {	/* auto increment/decrement by 1 */
+    {	"x+",	0x100	},
+    {	"-x",	0x102	},
+    {	"y+",	0x120	},
+    {	"-y",	0x122	},
+    {	"u+",	0x140	},
+    {	"-u",	0x142	},
+    {	"s+",	0x160	},
+    {	"-s",	0x162	},
+    {	"",	0x000	}
+};
+
+struct adsym	auto2[] = {	/* auto increment/decrement by 2 */
+    {	"x++",	0x101	},
+    {	"--x",	0x103	},
+    {	"y++",	0x121	},
+    {	"--y",	0x123	},
+    {	"u++",	0x141	},
+    {	"--u",	0x143	},
+    {	"s++",	0x161	},
+    {	"--s",	0x163	},
+    {	"",	0x000	}
+};
+
+struct adsym	pc[] = {	/* pc */
+    {	"pc",	0x0C	},
+    {	"",	0x00	}
+};
+
+struct adsym	pcr[] = {	/* pc relative */
+    {	"pcr",	0x0C	},
+    {	"",	0x00	}
+};
+
+struct adsym	regs[] = {	/* exg, tfr register coding */
+    {	"d",	0x100	},
+    {	"x",	0x101	},
+    {	"y",	0x102	},
+    {	"u",	0x103	},
+    {	"s",	0x104	},
+    {	"pc",	0x105	},
+    {	"a",	0x108	},
+    {	"b",	0x109	},
+    {	"cc",	0x10A	},
+    {	"dp",	0x10B	},
+    {	"",	0x000	}
+};
+
+struct adsym	stks[] = {	/* push/pull on system stack */
+    {	"cc",	0x01	},
+    {	"a",	0x02	},
+    {	"b",	0x04	},
+    {	"d",	0x06	},
+    {	"dp",	0x08	},
+    {	"x",	0x10	},
+    {	"y",	0x20	},
+    {	"u",	0x40	},
+    {	"pc",	0x80	},
+    {	"",	0x00	}
+};
+
+struct adsym	stku[] = {	/* push/pull on user stack */
+    {	"cc",	0x01	},
+    {	"a",	0x02	},
+    {	"b",	0x04	},
+    {	"d",	0x06	},
+    {	"dp",	0x08	},
+    {	"x",	0x10	},
+    {	"y",	0x20	},
+    {	"s",	0x40	},
+    {	"pc",	0x80	},
+    {	"",	0x00	}
+};
diff --git a/sdcc/sdas/as6809/m09mch.c b/sdcc/sdas/as6809/m09mch.c
new file mode 100644
index 000000000..aba7a5678
--- /dev/null
+++ b/sdcc/sdas/as6809/m09mch.c
@@ -0,0 +1,646 @@
+/* M09MCH.C */
+
+/*
+ *  Copyright (C) 1989-2009  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "asxxxx.h"
+#include "m6809.h"
+
+char	*cpu	= "Motorola 6809";
+char	*dsft	= "asm";
+
+#define	NB	512
+
+int	*bp;
+int	bm;
+int	bb[NB];
+
+/*
+ * Opcode Cycle Definitions
+ */
+#define	OPCY_SDP	((char) (0xFF))
+#define	OPCY_ERR	((char) (0xFE))
+
+/*	OPCY_NONE	((char) (0x80))	*/
+/*	OPCY_MASK	((char) (0x7F))	*/
+
+#define	OPCY_INDX	((char) (0x40))
+#define	OPCY_PSPL	((char) (0x20))
+
+#define	VALU_MASK	((char) (0x1F))
+
+#define	UN	((char) (OPCY_NONE | 0x00))
+#define	P2	((char) (OPCY_NONE | 0x01))
+#define	P3	((char) (OPCY_NONE | 0x02))
+
+#define	I3	((char) (OPCY_INDX | 0x03))
+#define	I4	((char) (OPCY_INDX | 0x04))
+#define	I5	((char) (OPCY_INDX | 0x05))
+#define	I6	((char) (OPCY_INDX | 0x06))
+#define	I7	((char) (OPCY_INDX | 0x07))
+
+#define	PP	((char) (OPCY_PSPL | 0x05))
+
+/*
+ * 6809 Cycle Count
+ *
+ *	opcycles = m09pg1[opcode]
+ */
+static char m09pg1[256] = {
+/*--*--* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+/*--*--* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */
+/*00*/   6,UN,UN, 6, 6,UN, 6, 6, 6, 6, 6,UN, 6, 6, 3, 6,
+/*10*/  P2,P3, 2, 4,UN,UN, 5, 9,UN, 2, 3,UN, 3, 2, 8, 6,
+/*20*/   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+/*30*/  I4,I4,I4,I4,PP,PP,PP,PP,UN, 5, 3,15,20,11,UN,19,
+/*40*/   2,UN,UN, 2, 2,UN, 2, 2, 2, 2, 2,UN, 2, 2,UN, 2,
+/*50*/   2,UN,UN, 2, 2,UN, 2, 2, 2, 2, 2,UN, 2, 2,UN, 2,
+/*60*/  I6,UN,UN,I6,I6,UN,I6,I6,I6,I6,I6,UN,I6,I6,I3,I6,
+/*70*/   7,UN,UN, 7, 7,UN, 7, 7, 7, 7, 7,UN, 7, 7, 4, 7,
+/*80*/   2, 2, 2, 4, 2, 2, 2,UN, 2, 2, 2, 2, 4, 7, 3,UN,
+/*90*/   4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 7, 5, 5,
+/*A0*/  I4,I4,I4,I6,I4,I4,I4,I4,I4,I4,I4,I4,I6,I7,I5,I5,
+/*B0*/   5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 7, 8, 6, 6,
+/*C0*/   2, 2, 2, 4, 2, 2, 2,UN, 2, 2, 2, 2, 3,UN, 3,UN,
+/*D0*/   4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
+/*E0*/  I4,I4,I4,I6,I4,I4,I4,I4,I4,I4,I4,I4,I5,I5,I5,I5,
+/*F0*/   5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6
+};
+
+static char m09pg2[256] = {
+/*--*--* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+/*--*--* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */
+/*00*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*10*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*20*/  UN, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+/*30*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,20,
+/*40*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*50*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*60*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*70*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*80*/  UN,UN,UN, 5,UN,UN,UN,UN,UN,UN,UN,UN, 5,UN, 4,UN,
+/*90*/  UN,UN,UN, 7,UN,UN,UN,UN,UN,UN,UN,UN, 7,UN, 6,UN,
+/*A0*/  UN,UN,UN,I7,UN,UN,UN,UN,UN,UN,UN,UN,I7,UN,I6,I6,
+/*B0*/  UN,UN,UN, 8,UN,UN,UN,UN,UN,UN,UN,UN, 8,UN, 7, 7,
+/*C0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN, 4,UN,
+/*D0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN, 6, 6,
+/*E0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,I6,I6,
+/*F0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN, 7, 7
+};
+
+static char m09pg3[256] = {
+/*--*--* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+/*--*--* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */
+/*00*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*10*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*20*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*30*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,20,
+/*40*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*50*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*60*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*70*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*80*/  UN,UN,UN, 5,UN,UN,UN,UN,UN,UN,UN,UN, 5,UN,UN,UN,
+/*90*/  UN,UN,UN, 7,UN,UN,UN,UN,UN,UN,UN,UN, 7,UN,UN,UN,
+/*A0*/  UN,UN,UN,I7,UN,UN,UN,UN,UN,UN,UN,UN,I7,UN,UN,UN,
+/*B0*/  UN,UN,UN, 8,UN,UN,UN,UN,UN,UN,UN,UN, 8,UN,UN,UN,
+/*C0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*D0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*E0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*F0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN
+};
+
+static char *Page[3] = {
+    m09pg1, m09pg2, m09pg3
+};
+
+static char m09idx[32] = {
+/*    ,R+	*/	2,	/*    ,R++	*/	3,
+/*    ,-R	*/	2,	/*    ,--R	*/	3,
+/*    ,R	*/	0,	/*   B,R	*/	1,
+/*   A,R	*/	1,	/*   ---	*/	0,
+/*   n,R     (8)*/	1,	/*   n,R    (16)*/	4,
+/*   ---	*/	0,	/*   D,R	*/	4,
+/*   n,PCR   (8)*/	1,	/*   n,PCR  (16)*/	5,
+/*   ---	*/	0,	/*   ---	*/	0,
+/*   ---	*/	0,	/*   [,R++]	*/	6,
+/*   ---	*/	0,	/*   [,--R]	*/	6,
+/*   [,R]	*/	3,	/*  [B,R]	*/	4,
+/*  [A,R]	*/	4,	/*   ---	*/	0,
+/*  [n,R]    (8)*/	4,	/*  [n,R]   (16)*/	7,
+/*   ---	*/	0,	/*  [D,R]	*/	7,
+/*  [n,PCR]  (8)*/	4,	/*  [n,PCR] (16)*/	8,
+/*   ---	*/	0,	/*  [n]		*/	5
+};
+
+static char m00cyc[24] = {
+	12,12, 3, 3, 3, 5, 5, 5,
+	 5, 6, 6, 6, 6,12, 3, 3,
+	 3, 8, 6, 8, 6, 6, 6,20
+};
+
+
+/*
+ * Process a machine op.
+ */
+VOID
+machine(mp)
+struct mne *mp;
+{
+	int op, rf, cpg, c;
+	struct expr e1;
+	int t1, v1, v2;
+	struct area *espa;
+	char id[NCPS];
+
+	cpg = 0;
+	clrexpr(&e1);
+	op = (int) mp->m_valu;
+	switch (rf = mp->m_type) {
+
+	case S_SDP:
+		opcycles = OPCY_SDP;
+		espa = NULL;
+		if (more()) {
+			expr(&e1, 0);
+			if (e1.e_flag == 0 && e1.e_base.e_ap == NULL) {
+				if (e1.e_addr & 0xFF) {
+					err('b');
+				}
+			}
+			if ((c = getnb()) == ',') {
+				getid(id, -1);
+				espa = alookup(id);
+				if (espa == NULL) {
+					err('u');
+				}
+			} else {
+				unget(c);
+			}
+		}
+		if (espa) {
+			outdp(espa, &e1, 0);
+		} else {
+			outdp(dot.s_area, &e1, 0);
+		}
+		lmode = SLIST;
+		break;
+
+	case S_INH2:
+		cpg += 0x01;
+
+	case S_INH1:
+		cpg += 0x10;
+
+	case S_INH:
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		break;
+
+	case S_BRA:
+		expr(&e1, 0);
+		outab(op);
+		if (mchpcr(&e1)) {
+			v1 = (int) (e1.e_addr - dot.s_addr - 1);
+			if ((v1 < -128) || (v1 > 127))
+				aerr();
+			outab(v1);
+		} else {
+			outrb(&e1, R_PCR);
+		}
+		if (e1.e_mode != S_USER)
+			rerr();
+		break;
+
+	case S_LBRA:
+		cpg += 0x10;
+
+	case S_LBSR:
+		expr(&e1, 0);
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		if (mchpcr(&e1)) {
+			v1 = (int) (e1.e_addr - dot.s_addr - 2);
+			outaw(v1);
+		} else {
+			outrw(&e1, R_PCR);
+		}
+		if (e1.e_mode != S_USER)
+			aerr();
+		break;
+
+	case S_PULS:
+		v1 = 0;
+		do {
+			if ((t1 = admode(stks)) == 0 || v1 & t1)
+				aerr();
+			v1 |= t1;
+		} while (more() && comma(1));
+		outab(op);
+		outab(v1);
+		break;
+
+	case S_PULU:
+		v1 = 0;
+		do {
+			if ((t1 = admode(stku)) == 0 || v1 & t1)
+				aerr();
+			v1 |= t1;
+		} while (more() && comma(1));
+		outab(op);
+		outab(v1);
+		break;
+
+	case S_EXG:
+		v1 = admode(regs);
+		comma(1);
+		v2 = admode(regs);
+		if ((v1 & 0x08) != (v2 & 0x08))
+			aerr();
+		outab(op);
+		outab((v1<<4)|v2);
+		break;
+
+	case S_ACC:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED)
+			e1.e_mode = S_IMB;
+		genout(cpg, op, rf, &e1);
+		break;
+
+	case S_STR1:
+		cpg += 0x10;
+
+	case S_SOP:
+	case S_STR:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED)
+			e1.e_mode = S_IMER;
+		genout(cpg, op, rf, &e1);
+		break;
+
+	case S_LR2:
+		cpg += 0x01;
+
+	case S_LR1:
+		cpg += 0x10;
+
+	case S_LR:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED)
+			e1.e_mode = S_IMW;
+		genout(cpg, op, rf, &e1);
+		break;
+
+	case S_LEA:
+		t1 = addr(&e1);
+		if (aindx) {
+			genout(cpg, op, rf, &e1);
+			break;
+		}
+		aerr();
+		break;
+
+	case S_CC:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED) {
+			e1.e_mode = S_IMB;
+			genout(cpg, op, rf, &e1);
+			break;
+		}
+		aerr();
+		break;
+
+	case S_6800:
+		m68out(op);
+		opcycles = m00cyc[op];
+		break;
+
+	default:
+		opcycles = OPCY_ERR;
+		err('o');
+		break;
+	}
+
+	if (opcycles == OPCY_NONE) {
+		v2 = 1;
+		opcycles = m09pg1[cb[0] & 0xFF];
+		if ((opcycles & OPCY_NONE) && (opcycles & OPCY_MASK)) {
+			v2 += 1;
+			opcycles = Page[opcycles & OPCY_MASK][cb[1] & 0xFF];
+		}
+		if (opcycles & OPCY_INDX) {
+			if (cb[v2] & 0x80) {
+				opcycles = (opcycles & VALU_MASK) + m09idx[cb[v2] & 0x1F];
+			} else {
+				opcycles = (opcycles & VALU_MASK) + 1;
+			}
+		} else
+		if (opcycles & OPCY_PSPL) {
+			for (t1=0x01,v1=0; t1 < 0x0100; t1 <<= 1) {
+				if (cb[1] & t1) {
+			    		v1 += 1;
+				}
+			}
+			opcycles = (opcycles & VALU_MASK) + v1;
+		}
+	}
+}
+
+/*
+ * General Output Routine
+ */
+VOID
+genout(cpg, op, rf, esp)
+int cpg, op, rf;
+struct expr *esp;
+{
+	int espv;
+	struct area *espa;
+	int disp, flag;
+
+	espv = (int) esp->e_addr;
+	espa = esp->e_base.e_ap;
+	switch (esp->e_mode) {
+
+	case S_IMB:
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		outrb(esp, R_NORM);
+		break;
+
+	case S_IMW:
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		outrw(esp, R_NORM);
+		break;
+
+	case S_DIR:
+		if (cpg)
+			outab(cpg);
+		if (rf == S_SOP) {
+			outab(op&0x0F);
+		} else {
+			outab(op|0x10);
+		}
+		outrb(esp, R_PAGN);
+		break;
+
+	case S_EXT:
+		if (cpg)
+			outab(cpg);
+		if (aindx) {
+			outab(op|0x20);
+			outab(aindx|0x0F);
+			outrw(esp, R_NORM);
+			break;
+		}
+		outab(op|0x30);
+		outrw(esp, R_NORM);
+		break;
+
+	case S_IND:
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		outab(aindx);
+		break;
+
+	case S_PC:
+		if (espa) {
+			aerr();
+			break;
+		}
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		if (pass == 0) {
+			dot.s_addr += 3;
+		} else
+		if (pass == 1) {
+			if (esp->e_addr >= dot.s_addr)
+				esp->e_addr -= fuzz;
+			dot.s_addr += 2;
+			disp = (int) esp->e_addr;
+			flag = 0;
+			if (disp < -128 || disp > 127)
+				++flag;
+			if (setbit(flag))
+				++dot.s_addr;
+		} else {
+			if (getbit()) {
+				outab(aindx|0x01);
+				outaw(espv);
+			} else {
+				outab(aindx);
+				outab(espv);
+			}
+		}
+		break;
+
+	case S_PCR:
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		if (pass == 0) {
+			dot.s_addr += 3;
+		} else
+		if (espa && espa != dot.s_area) {
+			outab(aindx|0x01);
+			outrw(esp, R_PCR);
+		} else
+		if (pass == 1) {
+			if (esp->e_addr >= dot.s_addr)
+				esp->e_addr -= fuzz;
+			dot.s_addr += 2;
+			disp = (int) (esp->e_addr - dot.s_addr);
+			flag = 0;
+			if (disp < -128 || disp > 127)
+				++flag;
+			if (setbit(flag))
+				++dot.s_addr;
+		} else {
+			if (getbit()) {
+				outab(aindx|0x01);
+				disp = (int) (espv - dot.s_addr - 2);
+				outaw(disp);
+			} else {
+				outab(aindx);
+				disp = (int) (espv - dot.s_addr - 1);
+				outab(disp);
+			}
+		}
+		break;
+
+	case S_OFST:
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		if (pass == 0) {
+			dot.s_addr += 3;
+		} else
+		if (espa) {
+			outab(aindx|0x09);
+			outrw(esp, R_NORM);
+		} else
+		if (pass == 1) {
+			if (esp->e_addr >= dot.s_addr)
+				esp->e_addr -= fuzz;
+			dot.s_addr += 1;
+			flag = 0;
+			if (espv < -128 || espv > 127)
+				++flag;
+			if (setbit(flag)) {
+				dot.s_addr += 2;
+			} else {
+				flag = aindx & 0x10;
+				if (espv < -16 || espv > 15)
+					++flag;
+				if (setbit(flag))
+					++dot.s_addr;
+			}
+		} else {
+			if (getbit()) {
+				outab(aindx|0x09);
+				outaw(espv);
+			} else {
+				if (getbit()) {
+					outab(aindx|0x08);
+					outab(espv);
+				} else {
+					outab((aindx & 0x60) | (espv & 0x1F));
+				}
+			}
+		}
+		break;
+
+	case S_IMER:
+	default:
+		aerr();
+	}
+}
+
+/*
+ * mc6800 compatibility output routine
+ */
+VOID
+m68out(i)
+int i;
+{
+	char *ptr;
+	int j;
+
+	ptr = (char *) &mc6800[i];
+	for (j=0; j<4 ; j++) {
+		if ((i = *ptr++) != 0) {
+			outab(i);
+		} else {
+			break;
+		}
+	}
+}
+
+/*
+ * Branch/Jump PCR Mode Check
+ */
+int
+mchpcr(esp)
+struct expr *esp;
+{
+	if (esp->e_base.e_ap == dot.s_area) {
+		return(1);
+	}
+	if (esp->e_flag==0 && esp->e_base.e_ap==NULL) {
+		/*
+		 * Absolute Destination
+		 *
+		 * Use the global symbol '.__.ABS.'
+		 * of value zero and force the assembler
+		 * to use this absolute constant as the
+		 * base value for the relocation.
+		 */
+		esp->e_flag = 1;
+		esp->e_base.e_sp = &sym[1];
+	}
+	return(0);
+}
+
+/*
+ * Machine specific initialization.
+ * Set up the bit table.
+ */
+VOID
+minit()
+{
+	/*
+	 * Byte Order
+	 */
+	hilo = 1;
+
+	bp = bb;
+	bm = 1;
+}
+
+/*
+ * Store `b' in the next slot of the bit table.
+ * If no room, force the longer form of the offset.
+ */
+int
+setbit(b)
+int b;
+{
+	if (bp >= &bb[NB])
+		return(1);
+	if (b)
+		*bp |= bm;
+	bm <<= 1;
+	if (bm == 0) {
+		bm = 1;
+		++bp;
+	}
+	return(b);
+}
+
+/*
+ * Get the next bit from the bit table.
+ * If none left, return a `1'.
+ * This will force the longer form of the offset.
+ */
+int
+getbit()
+{
+	register int f;
+
+	if (bp >= &bb[NB])
+		return (1);
+	f = *bp & bm;
+	bm <<= 1;
+	if (bm == 0) {
+		bm = 1;
+		++bp;
+	}
+	return (f);
+}
+
diff --git a/sdcc/sdas/as6809/m09pst.c b/sdcc/sdas/as6809/m09pst.c
new file mode 100644
index 000000000..c064a23fb
--- /dev/null
+++ b/sdcc/sdas/as6809/m09pst.c
@@ -0,0 +1,500 @@
+/* M09PST.C */
+
+/*
+ *  Copyright (C) 1989-2009  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "asxxxx.h"
+#include "m6809.h"
+
+/*
+ * Coding Banks
+ */
+struct	bank	bank[2] = {
+    /*	The '_CODE' area/bank has a NULL default file suffix.	*/
+    {	NULL,		"_CSEG",	NULL,		0,	0,	0,	0,	0	},
+    {	&bank[0],	"_DSEG",	"_DS",		1,	0,	0,	0,	B_FSFX	}
+};
+
+/*
+ * Coding Areas
+ */
+struct	area	area[2] = {
+    {	NULL,		&bank[0],	"_CODE",	0,	0,	0,	A_1BYTE|A_BNK|A_CSEG	},
+    {	&area[0],	&bank[1],	"_DATA",	1,	0,	0,	A_1BYTE|A_BNK|A_DSEG	}
+};
+
+/*
+ * Basic Relocation Mode Definition
+ *
+ *	#define		R_NORM	0000		No Bit Positioning
+ */
+char	mode0[32] = {	/* R_NORM */
+	'\200',	'\201',	'\202',	'\203',	'\204',	'\205',	'\206',	'\207',
+	'\210',	'\211',	'\212',	'\213',	'\214',	'\215',	'\216',	'\217',
+	'\220',	'\221',	'\222',	'\223',	'\224',	'\225',	'\226',	'\227',
+	'\230',	'\231',	'\232',	'\233',	'\234',	'\235',	'\236',	'\237'
+};
+
+/*
+ * Additional Relocation Mode Definitions
+ */
+
+/* None Required */
+
+/*
+ *     *m_def is a pointer to the bit relocation definition.
+ *	m_flag indicates that bit position swapping is required.
+ *	m_dbits contains the active bit positions for the output.
+ *	m_sbits contains the active bit positions for the input.
+ *
+ *	struct	mode
+ *	{
+ *		char *	m_def;		Bit Relocation Definition
+ *		a_uint	m_flag;		Bit Swapping Flag
+ *		a_uint	m_dbits;	Destination Bit Mask
+ *		a_uint	m_sbits;	Source Bit Mask
+ *	};
+ */
+struct	mode	mode[1] = {
+    {	&mode0[0],	0,	0x0000FFFF,	0x0000FFFF	}
+};
+
+/*
+ * Array of Pointers to mode Structures
+ */
+struct	mode	*modep[16] = {
+	&mode[0],	NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL
+};
+
+/*
+ * Mnemonic Structure
+ */
+struct	mne	mne[] = {
+
+	/* machine */
+
+    {	NULL,	"CSEG",		S_ATYP,		0,	A_CSEG|A_1BYTE	},
+    {	NULL,	"DSEG",		S_ATYP,		0,	A_DSEG|A_1BYTE	},
+
+    {	NULL,	".setdp",	S_SDP,		0,	0	},
+
+	/* system */
+
+    {	NULL,	"BANK",		S_ATYP,		0,	A_BNK	},
+    {	NULL,	"CON",		S_ATYP,		0,	A_CON	},
+    {	NULL,	"OVR",		S_ATYP,		0,	A_OVR	},
+    {	NULL,	"REL",		S_ATYP,		0,	A_REL	},
+    {	NULL,	"ABS",		S_ATYP,		0,	A_ABS	},
+    {	NULL,	"NOPAG",	S_ATYP,		0,	A_NOPAG	},
+    {	NULL,	"PAG",		S_ATYP,		0,	A_PAG	},
+
+    {	NULL,	"BASE",		S_BTYP,		0,	B_BASE	},
+    {	NULL,	"SIZE",		S_BTYP,		0,	B_SIZE	},
+    {	NULL,	"FSFX",		S_BTYP,		0,	B_FSFX	},
+    {	NULL,	"MAP",		S_BTYP,		0,	B_MAP	},
+
+    {	NULL,	".page",	S_PAGE,		0,	0	},
+    {	NULL,	".title",	S_HEADER,	0,	O_TITLE	},
+    {	NULL,	".sbttl",	S_HEADER,	0,	O_SBTTL	},
+    {	NULL,	".module",	S_MODUL,	0,	0	},
+    {	NULL,	".include",	S_INCL,		0,	0	},
+    {	NULL,	".area",	S_AREA,		0,	0	},
+    {	NULL,	".bank",	S_BANK,		0,	0	},
+    {	NULL,	".org",		S_ORG,		0,	0	},
+    {	NULL,	".radix",	S_RADIX,	0,	0	},
+    {	NULL,	".globl",	S_GLOBL,	0,	0	},
+    {	NULL,	".local",	S_LOCAL,	0,	0	},
+    {	NULL,	".if",		S_CONDITIONAL,	0,	O_IF	},
+    {	NULL,	".iff",		S_CONDITIONAL,	0,	O_IFF	},
+    {	NULL,	".ift",		S_CONDITIONAL,	0,	O_IFT	},
+    {	NULL,	".iftf",	S_CONDITIONAL,	0,	O_IFTF	},
+    {	NULL,	".ifdef",	S_CONDITIONAL,	0,	O_IFDEF	},
+    {	NULL,	".ifndef",	S_CONDITIONAL,	0,	O_IFNDEF},
+    {	NULL,	".ifgt",	S_CONDITIONAL,	0,	O_IFGT	},
+    {	NULL,	".iflt",	S_CONDITIONAL,	0,	O_IFLT	},
+    {	NULL,	".ifge",	S_CONDITIONAL,	0,	O_IFGE	},
+    {	NULL,	".ifle",	S_CONDITIONAL,	0,	O_IFLE	},
+    {	NULL,	".ifeq",	S_CONDITIONAL,	0,	O_IFEQ	},
+    {	NULL,	".ifne",	S_CONDITIONAL,	0,	O_IFNE	},
+    {	NULL,	".ifb",		S_CONDITIONAL,	0,	O_IFB	},
+    {	NULL,	".ifnb",	S_CONDITIONAL,	0,	O_IFNB	},
+    {	NULL,	".ifidn",	S_CONDITIONAL,	0,	O_IFIDN	},
+    {	NULL,	".ifdif",	S_CONDITIONAL,	0,	O_IFDIF	},
+    {	NULL,	".iif",		S_CONDITIONAL,	0,	O_IIF	},
+    {	NULL,	".iiff",	S_CONDITIONAL,	0,	O_IIFF	},
+    {	NULL,	".iift",	S_CONDITIONAL,	0,	O_IIFT	},
+    {	NULL,	".iiftf",	S_CONDITIONAL,	0,	O_IIFTF	},
+    {	NULL,	".iifdef",	S_CONDITIONAL,	0,	O_IIFDEF},
+    {	NULL,	".iifndef",	S_CONDITIONAL,	0,	O_IIFNDEF},
+    {	NULL,	".iifgt",	S_CONDITIONAL,	0,	O_IIFGT	},
+    {	NULL,	".iiflt",	S_CONDITIONAL,	0,	O_IIFLT	},
+    {	NULL,	".iifge",	S_CONDITIONAL,	0,	O_IIFGE	},
+    {	NULL,	".iifle",	S_CONDITIONAL,	0,	O_IIFLE	},
+    {	NULL,	".iifeq",	S_CONDITIONAL,	0,	O_IIFEQ	},
+    {	NULL,	".iifne",	S_CONDITIONAL,	0,	O_IIFNE	},
+    {	NULL,	".iifb",	S_CONDITIONAL,	0,	O_IIFB	},
+    {	NULL,	".iifnb",	S_CONDITIONAL,	0,	O_IIFNB	},
+    {	NULL,	".iifidn",	S_CONDITIONAL,	0,	O_IIFIDN},
+    {	NULL,	".iifdif",	S_CONDITIONAL,	0,	O_IIFDIF},
+    {	NULL,	".else",	S_CONDITIONAL,	0,	O_ELSE	},
+    {	NULL,	".endif",	S_CONDITIONAL,	0,	O_ENDIF	},
+    {	NULL,	".list",	S_LISTING,	0,	O_LIST	},
+    {	NULL,	".nlist",	S_LISTING,	0,	O_NLIST	},
+    {	NULL,	".equ",		S_EQU,		0,	O_EQU	},
+    {	NULL,	".gblequ",	S_EQU,		0,	O_GBLEQU},
+    {	NULL,	".lclequ",	S_EQU,		0,	O_LCLEQU},
+    {	NULL,	".byte",	S_DATA,		0,	O_1BYTE	},
+    {	NULL,	".db",		S_DATA,		0,	O_1BYTE	},
+    {	NULL,	".fcb",		S_DATA,		0,	O_1BYTE	},
+    {	NULL,	".word",	S_DATA,		0,	O_2BYTE	},
+    {	NULL,	".dw",		S_DATA,		0,	O_2BYTE	},
+    {	NULL,	".fdb",		S_DATA,		0,	O_2BYTE	},
+/*    {	NULL,	".3byte",	S_DATA,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".triple",	S_DATA,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".4byte",	S_DATA,		0,	O_4BYTE	},	*/
+/*    {	NULL,	".quad",	S_DATA,		0,	O_4BYTE	},	*/
+    {	NULL,	".blkb",	S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".ds",		S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".rmb",		S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".rs",		S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".blkw",	S_BLK,		0,	O_2BYTE	},
+/*    {	NULL,	".blk3",	S_BLK,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".blk4",	S_BLK,		0,	O_4BYTE	},	*/
+    {	NULL,	".ascii",	S_ASCIX,	0,	O_ASCII	},
+    {	NULL,	".ascis",	S_ASCIX,	0,	O_ASCIS	},
+    {	NULL,	".asciz",	S_ASCIX,	0,	O_ASCIZ	},
+    {	NULL,	".str",		S_ASCIX,	0,	O_ASCII	},
+    {	NULL,	".strs",	S_ASCIX,	0,	O_ASCIS	},
+    {	NULL,	".strz",	S_ASCIX,	0,	O_ASCIZ	},
+    {	NULL,	".fcc",		S_ASCIX,	0,	O_ASCII	},
+    {	NULL,	".define",	S_DEFINE,	0,	O_DEF	},
+    {	NULL,	".undefine",	S_DEFINE,	0,	O_UNDEF	},
+    {	NULL,	".even",	S_BOUNDARY,	0,	O_EVEN	},
+    {	NULL,	".odd",		S_BOUNDARY,	0,	O_ODD	},
+    {	NULL,	".bndry",	S_BOUNDARY,	0,	O_BNDRY	},
+    {	NULL,	".msg"	,	S_MSG,		0,	0	},
+    {	NULL,	".assume",	S_ERROR,	0,	O_ASSUME},
+    {	NULL,	".error",	S_ERROR,	0,	O_ERROR	},
+/*    {	NULL,	".msb",		S_MSB,		0,	0	},	*/
+/*    {	NULL,	".lohi",	S_MSB,		0,	O_LOHI	},	*/
+/*    {	NULL,	".hilo",	S_MSB,		0,	O_HILO	},	*/
+/*    {	NULL,	".8bit",	S_BITS,		0,	O_1BYTE	},	*/
+/*    {	NULL,	".16bit",	S_BITS,		0,	O_2BYTE	},	*/
+/*    {	NULL,	".24bit",	S_BITS,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".32bit",	S_BITS,		0,	O_4BYTE	},	*/
+    {	NULL,	".end",		S_END,		0,	0	},
+
+	/* Macro Processor */
+
+    {	NULL,	".macro",	S_MACRO,	0,	O_MACRO	},
+    {	NULL,	".endm",	S_MACRO,	0,	O_ENDM	},
+    {	NULL,	".mexit",	S_MACRO,	0,	O_MEXIT	},
+
+    {	NULL,	".narg",	S_MACRO,	0,	O_NARG	},
+    {	NULL,	".nchr",	S_MACRO,	0,	O_NCHR	},
+    {	NULL,	".ntyp",	S_MACRO,	0,	O_NTYP	},
+
+    {	NULL,	".irp",		S_MACRO,	0,	O_IRP	},
+    {	NULL,	".irpc",	S_MACRO,	0,	O_IRPC	},
+    {	NULL,	".rept",	S_MACRO,	0,	O_REPT	},
+
+    {	NULL,	".nval",	S_MACRO,	0,	O_NVAL	},
+
+    {	NULL,	".mdelete",	S_MACRO,	0,	O_MDEL	},
+
+	/* 6800 Compatibility */
+
+    {	NULL,	"ldaa",		S_ACC,		0,	0x86	},
+    {	NULL,	"ldab",		S_ACC,		0,	0xC6	},
+    {	NULL,	"oraa",		S_ACC,		0,	0x8A	},
+    {	NULL,	"orab",		S_ACC,		0,	0xCA	},
+    {	NULL,	"staa",		S_STR,		0,	0x87	},
+    {	NULL,	"stab",		S_STR,		0,	0xC7	},
+
+	/* if this is changed, change struct opdata mc6800[] */
+
+    {	NULL,	"aba",		S_6800,		0,	0	},
+    {	NULL,	"cba",		S_6800,		0,	1	},
+    {	NULL,	"clc",		S_6800,		0,	2	},
+    {	NULL,	"cli",		S_6800,		0,	3	},
+    {	NULL,	"clv",		S_6800,		0,	4	},
+    {	NULL,	"des",		S_6800,		0,	5	},
+    {	NULL,	"dex",		S_6800,		0,	6	},
+    {	NULL,	"ins",		S_6800,		0,	7	},
+    {	NULL,	"inx",		S_6800,		0,	8	},
+    {	NULL,	"psha",		S_6800,		0,	9	},
+    {	NULL,	"pshb",		S_6800,		0,	10	},
+    {	NULL,	"pula",		S_6800,		0,	11	},
+    {	NULL,	"pulb",		S_6800,		0,	12	},
+    {	NULL,	"sba",		S_6800,		0,	13	},
+    {	NULL,	"sec",		S_6800,		0,	14	},
+    {	NULL,	"sei",		S_6800,		0,	15	},
+    {	NULL,	"sev",		S_6800,		0,	16	},
+    {	NULL,	"tab",		S_6800,		0,	17	},
+    {	NULL,	"tap",		S_6800,		0,	18	},
+    {	NULL,	"tba",		S_6800,		0,	19	},
+    {	NULL,	"tpa",		S_6800,		0,	20	},
+    {	NULL,	"tsx",		S_6800,		0,	21	},
+    {	NULL,	"txs",		S_6800,		0,	22	},
+    {	NULL,	"wai",		S_6800,		0,	23	},
+
+	/* 6809 */
+
+    {	NULL,	"sty",		S_STR1,		0,	0x8F	},
+    {	NULL,	"sts",		S_STR1,		0,	0xCF	},
+
+    {	NULL,	"sta",		S_STR,		0,	0x87	},
+    {	NULL,	"stb",		S_STR,		0,	0xC7	},
+    {	NULL,	"std",		S_STR,		0,	0xCD	},
+    {	NULL,	"stx",		S_STR,		0,	0x8F	},
+    {	NULL,	"stu",		S_STR,		0,	0xCF	},
+    {	NULL,	"jsr",		S_STR,		0,	0x8D	},
+
+    {	NULL,	"cmpu",		S_LR2,		0,	0x83	},
+    {	NULL,	"cmps",		S_LR2,		0,	0x8C	},
+
+    {	NULL,	"cmpd",		S_LR1,		0,	0x83	},
+    {	NULL,	"cmpy",		S_LR1,		0,	0x8C	},
+    {	NULL,	"ldy",		S_LR1,		0,	0x8E	},
+    {	NULL,	"lds",		S_LR1,		0,	0xCE	},
+
+    {	NULL,	"subd",		S_LR,		0,	0x83	},
+    {	NULL,	"addd",		S_LR,		0,	0xC3	},
+    {	NULL,	"cmpx",		S_LR,		0,	0x8C	},
+    {	NULL,	"cpx",		S_LR,		0,	0x8C	},
+    {	NULL,	"ldd",		S_LR,		0,	0xCC	},
+    {	NULL,	"ldx",		S_LR,		0,	0x8E	},
+    {	NULL,	"ldu",		S_LR,		0,	0xCE	},
+
+    {	NULL,	"leax",		S_LEA,		0,	0x30	},
+    {	NULL,	"leay",		S_LEA,		0,	0x31	},
+    {	NULL,	"leas",		S_LEA,		0,	0x32	},
+    {	NULL,	"leau",		S_LEA,		0,	0x33	},
+
+    {	NULL,	"pshs",		S_PULS,		0,	0x34	},
+    {	NULL,	"puls",		S_PULS,		0,	0x35	},
+    {	NULL,	"pshu",		S_PULU,		0,	0x36	},
+    {	NULL,	"pulu",		S_PULU,		0,	0x37	},
+
+    {	NULL,	"exg",		S_EXG,		0,	0x1E	},
+    {	NULL,	"tfr",		S_EXG,		0,	0x1F	},
+
+    {	NULL,	"cwai",		S_CC,		0,	0x3C	},
+    {	NULL,	"orcc",		S_CC,		0,	0x1A	},
+    {	NULL,	"andcc",	S_CC,		0,	0x1C	},
+
+    {	NULL,	"swi3",		S_INH2,		0,	0x3F	},
+    {	NULL,	"swi2",		S_INH1,		0,	0x3F	},
+    {	NULL,	"swi1",		S_INH,		0,	0x3F	},
+
+    {	NULL,	"abx",		S_INH,		0,	0x3A	},
+    {	NULL,	"asla",		S_INH,		0,	0x48	},
+    {	NULL,	"aslb",		S_INH,		0,	0x58	},
+    {	NULL,	"asra",		S_INH,		0,	0x47	},
+    {	NULL,	"asrb",		S_INH,		0,	0x57	},
+    {	NULL,	"clra",		S_INH,		0,	0x4F	},
+    {	NULL,	"clrb",		S_INH,		0,	0x5F	},
+    {	NULL,	"coma",		S_INH,		0,	0x43	},
+    {	NULL,	"comb",		S_INH,		0,	0x53	},
+    {	NULL,	"daa",		S_INH,		0,	0x19	},
+    {	NULL,	"deca",		S_INH,		0,	0x4A	},
+    {	NULL,	"decb",		S_INH,		0,	0x5A	},
+    {	NULL,	"inca",		S_INH,		0,	0x4C	},
+    {	NULL,	"incb",		S_INH,		0,	0x5C	},
+    {	NULL,	"lsla",		S_INH,		0,	0x48	},
+    {	NULL,	"lslb",		S_INH,		0,	0x58	},
+    {	NULL,	"lsra",		S_INH,		0,	0x44	},
+    {	NULL,	"lsrb",		S_INH,		0,	0x54	},
+    {	NULL,	"mul",		S_INH,		0,	0x3D	},
+    {	NULL,	"nega",		S_INH,		0,	0x40	},
+    {	NULL,	"negb",		S_INH,		0,	0x50	},
+    {	NULL,	"nop",		S_INH,		0,	0x12	},
+    {	NULL,	"rola",		S_INH,		0,	0x49	},
+    {	NULL,	"rolb",		S_INH,		0,	0x59	},
+    {	NULL,	"rora",		S_INH,		0,	0x46	},
+    {	NULL,	"rorb",		S_INH,		0,	0x56	},
+    {	NULL,	"rti",		S_INH,		0,	0x3B	},
+    {	NULL,	"rts",		S_INH,		0,	0x39	},
+    {	NULL,	"sex",		S_INH,		0,	0x1D	},
+    {	NULL,	"swi",		S_INH,		0,	0x3F	},
+    {	NULL,	"sync",		S_INH,		0,	0x13	},
+    {	NULL,	"tsta",		S_INH,		0,	0x4D	},
+    {	NULL,	"tstb",		S_INH,		0,	0x5D	},
+
+    {	NULL,	"lbrn",		S_LBRA,		0,	0x21	},
+    {	NULL,	"lbhi",		S_LBRA,		0,	0x22	},
+    {	NULL,	"lbls",		S_LBRA,		0,	0x23	},
+    {	NULL,	"lblos",	S_LBRA,		0,	0x23	},
+    {	NULL,	"lbcc",		S_LBRA,		0,	0x24	},
+    {	NULL,	"lbhs",		S_LBRA,		0,	0x24	},
+    {	NULL,	"lbhis",	S_LBRA,		0,	0x24	},
+    {	NULL,	"lbcs",		S_LBRA,		0,	0x25	},
+    {	NULL,	"lblo",		S_LBRA,		0,	0x25	},
+    {	NULL,	"lbne",		S_LBRA,		0,	0x26	},
+    {	NULL,	"lbeq",		S_LBRA,		0,	0x27	},
+    {	NULL,	"lbvc",		S_LBRA,		0,	0x28	},
+    {	NULL,	"lbvs",		S_LBRA,		0,	0x29	},
+    {	NULL,	"lbpl",		S_LBRA,		0,	0x2A	},
+    {	NULL,	"lbmi",		S_LBRA,		0,	0x2B	},
+    {	NULL,	"lbge",		S_LBRA,		0,	0x2C	},
+    {	NULL,	"lblt",		S_LBRA,		0,	0x2D	},
+    {	NULL,	"lbgt",		S_LBRA,		0,	0x2E	},
+    {	NULL,	"lble",		S_LBRA,		0,	0x2F	},
+
+    {	NULL,	"lbra",		S_LBSR,		0,	0x16	},
+    {	NULL,	"lbsr",		S_LBSR,		0,	0x17	},
+
+    {	NULL,	"neg",		S_SOP,		0,	0x40	},
+    {	NULL,	"com",		S_SOP,		0,	0x43	},
+    {	NULL,	"lsr",		S_SOP,		0,	0x44	},
+    {	NULL,	"ror",		S_SOP,		0,	0x46	},
+    {	NULL,	"asr",		S_SOP,		0,	0x47	},
+    {	NULL,	"asl",		S_SOP,		0,	0x48	},
+    {	NULL,	"lsl",		S_SOP,		0,	0x48	},
+    {	NULL,	"rol",		S_SOP,		0,	0x49	},
+    {	NULL,	"dec",		S_SOP,		0,	0x4A	},
+    {	NULL,	"inc",		S_SOP,		0,	0x4C	},
+    {	NULL,	"tst",		S_SOP,		0,	0x4D	},
+    {	NULL,	"clr",		S_SOP,		0,	0x4F	},
+    {	NULL,	"jmp",		S_SOP,		0,	0x4E	},
+
+    {	NULL,	"suba",		S_ACC,		0,	0x80	},
+    {	NULL,	"subb",		S_ACC,		0,	0xC0	},
+    {	NULL,	"cmpa",		S_ACC,		0,	0x81	},
+    {	NULL,	"cmpb",		S_ACC,		0,	0xC1	},
+    {	NULL,	"sbca",		S_ACC,		0,	0x82	},
+    {	NULL,	"sbcb",		S_ACC,		0,	0xC2	},
+    {	NULL,	"anda",		S_ACC,		0,	0x84	},
+    {	NULL,	"andb",		S_ACC,		0,	0xC4	},
+    {	NULL,	"bita",		S_ACC,		0,	0x85	},
+    {	NULL,	"bitb",		S_ACC,		0,	0xC5	},
+    {	NULL,	"lda",		S_ACC,		0,	0x86	},
+    {	NULL,	"ldb",		S_ACC,		0,	0xC6	},
+    {	NULL,	"eora",		S_ACC,		0,	0x88	},
+    {	NULL,	"eorb",		S_ACC,		0,	0xC8	},
+    {	NULL,	"adca",		S_ACC,		0,	0x89	},
+    {	NULL,	"adcb",		S_ACC,		0,	0xC9	},
+    {	NULL,	"ora",		S_ACC,		0,	0x8A	},
+    {	NULL,	"orb",		S_ACC,		0,	0xCA	},
+    {	NULL,	"adda",		S_ACC,		0,	0x8B	},
+    {	NULL,	"addb",		S_ACC,		0,	0xCB	},
+
+    {	NULL,	"bra",		S_BRA,		0,	0x20	},
+    {	NULL,	"brn",		S_BRA,		0,	0x21	},
+    {	NULL,	"bhi",		S_BRA,		0,	0x22	},
+    {	NULL,	"bls",		S_BRA,		0,	0x23	},
+    {	NULL,	"blos",		S_BRA,		0,	0x23	},
+    {	NULL,	"bcc",		S_BRA,		0,	0x24	},
+    {	NULL,	"bhs",		S_BRA,		0,	0x24	},
+    {	NULL,	"bhis",		S_BRA,		0,	0x24	},
+    {	NULL,	"bcs",		S_BRA,		0,	0x25	},
+    {	NULL,	"blo",		S_BRA,		0,	0x25	},
+    {	NULL,	"bne",		S_BRA,		0,	0x26	},
+    {	NULL,	"beq",		S_BRA,		0,	0x27	},
+    {	NULL,	"bvc",		S_BRA,		0,	0x28	},
+    {	NULL,	"bvs",		S_BRA,		0,	0x29	},
+    {	NULL,	"bpl",		S_BRA,		0,	0x2A	},
+    {	NULL,	"bmi",		S_BRA,		0,	0x2B	},
+    {	NULL,	"bge",		S_BRA,		0,	0x2C	},
+    {	NULL,	"blt",		S_BRA,		0,	0x2D	},
+    {	NULL,	"bgt",		S_BRA,		0,	0x2E	},
+    {	NULL,	"ble",		S_BRA,		0,	0x2F	},
+    {	NULL,	"bsr",		S_BRA,		S_EOL,	0x8D	}
+};
+
+struct opdata mc6800[] = {
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;aba	*/
+	(char) 0xab, (char) 0xe0	/*	adda	,s+	*/	}},
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;cba	*/
+	(char) 0xa1, (char) 0xe0	/*	cmpa	,s+	*/	}},
+
+    {{	(char) 0x1c, (char) 0xfe,	/*	andcc	#0xFE	;clc	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1c, (char) 0xef,	/*	andcc	#0xEF	;cli	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1c, (char) 0xfd,	/*	andcc	#0xFD	;clv	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x32, (char) 0x7f,	/*	leas	-1,s	;des	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x30, (char) 0x1f,	/*	leax	-1,x	;dex	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x32, (char) 0x61,	/*	leas	1,s	;ins	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x30, (char) 0x01,	/*	leax	1,x	;inx	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x34, (char) 0x02,	/*	pshs	a	;psha	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;pshb	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x35, (char) 0x02,	/*	puls	a	;pula	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x35, (char) 0x04,	/*	puls	b	;pulb	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;sba	*/
+	(char) 0xa0, (char) 0xe0	/*	suba	,s+	*/	}},
+
+    {{	(char) 0x1a, (char) 0x01,	/*	orcc	#0x01	;sec	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1a, (char) 0x10,	/*	orcc	#0x10	;sei	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1a, (char) 0x02,	/*	orcc	#0x02	;sev	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x89,	/*	tfr	a,b	;tab	*/
+	(char) 0x4d, (char) 0x00	/*	tsta	*/	}},
+
+    {{	(char) 0x1f, (char) 0x8a,	/*	tfr	a,cc	;tap	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x98,	/*	tfr	b,a	;tba	*/
+	(char) 0x5d, (char) 0x00	/*	tstb	*/	}},
+
+    {{	(char) 0x1f, (char) 0xa8,	/*	tfr	cc,a	;tpa	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x41,	/*	tfr	s,x	;tsx	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x14,	/*	tfr	x,s	;txs	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x3c, (char) 0xff,	/*	cwai	#0xFF	;wai	*/
+	(char) 0x00, (char) 0x00	}}
+};
diff --git a/sdcc/sdas/as6809/m6809.h b/sdcc/sdas/as6809/m6809.h
new file mode 100644
index 000000000..3b3c7ae07
--- /dev/null
+++ b/sdcc/sdas/as6809/m6809.h
@@ -0,0 +1,174 @@
+/* m6809.h */
+
+/*
+ *  Copyright (C) 1989-2009  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+/*)BUILD
+	$(PROGRAM) =	AS6809
+	$(INCLUDE) = {
+		ASXXXX.H
+		M6809.H
+	}
+	$(FILES) = {
+		M09MCH.C
+		M09ADR.C
+		M09PST.C
+		ASMAIN.C
+		ASMCRO.C
+		ASDBG.C
+		ASLEX.C
+		ASSYM.C
+		ASSUBR.C
+		ASEXPR.C
+		ASDATA.C
+		ASLIST.C
+		ASOUT.C
+	}
+	$(STACK) = 3000
+*/
+
+/*
+ * Addressing types
+ */
+#define	S_EXT	30
+#define	S_IMMED	31
+#define	S_IMB	32
+#define	S_IMW	33
+#define	S_IMER	34
+#define	S_DIR	35
+#define	S_IND	36
+#define	S_OFST	37
+#define	S_PC	38
+#define	S_PCR	39
+
+/*
+ * 6809 Instruction types
+ */
+#define	S_BRA	40
+#define	S_LBRA	41
+#define	S_LBSR	42
+#define	S_SOP	43
+#define	S_ACC	44
+#define	S_STR1	45
+#define	S_STR	46
+#define	S_LR2	47
+#define	S_LR1	48
+#define	S_LR	49
+#define	S_LEA	50
+#define	S_PULS	51
+#define	S_PULU	52
+#define	S_EXG	53
+#define	S_CC	54
+#define	S_INH2	55
+#define	S_INH1	56
+#define	S_INH	57
+
+/*
+ * Other Information
+ */
+#define	S_FLAG	60
+
+/*
+ * 6800 Instruction types
+ */
+#define	S_6800	70
+
+/*
+ * Set Direct Pointer
+ */
+#define	S_SDP	80
+
+
+extern	int	aindx;
+
+struct	sdp
+{
+	a_uint	s_addr;
+	struct	area *	s_area;
+};
+
+struct adsym
+{
+	char	a_str[4];	/* addressing string */
+	int	a_val;		/* addressing mode value */
+};
+
+extern struct adsym abd[];
+extern struct adsym xyus[];
+extern struct adsym auto1[];
+extern struct adsym auto2[];
+extern struct adsym pc[];
+extern struct adsym pcr[];
+extern struct adsym regs[];
+extern struct adsym stks[];
+extern struct adsym stku[];
+
+struct opdata
+{
+	char	opcode[4];	/* byte data */
+};
+
+extern struct opdata mc6800[];
+
+
+	/* machine dependent functions */
+
+#ifdef	OTHERSYSTEM
+	
+	/* m09adr.c */
+extern	int		addr(struct expr *esp);
+extern	int		addr1(struct expr *esp);
+extern	int		admode(struct adsym *sp);
+extern	int		any(int c, char *str);
+extern	int		srch(char *str);
+
+	/* m09mch.c */
+extern	VOID		machine(struct mne *mp);
+extern	VOID		genout(int cpg, int op, int rf, struct expr *esp);
+extern	VOID		m68out(int i);
+extern	int		mchpcr(struct expr *esp);
+extern	VOID		minit(void);
+extern	int		setbit(int b);
+extern	int		getbit(void);
+extern	struct	sdp	sdp;
+
+#else
+
+	/* m09adr.c */
+extern	int		addr();
+extern	int		addr1();
+extern	int		admode();
+extern	int		any();
+extern	int		srch();
+
+	/* m09mch.c */
+extern	VOID		machine();
+extern	VOID		genout();
+extern	VOID		m68out();
+extern	int		mchpcr();
+extern	VOID		minit();
+extern	int		setbit();
+extern	int		getbit();
+extern	struct	sdp	sdp;
+
+#endif
+
-- 
